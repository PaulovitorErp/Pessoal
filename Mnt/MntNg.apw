#include "PROTHEUS.ch"
#include "RESTFUL.ch"
#include "fileio.ch"
#include "mntng.ch"
#include 'parmtype.ch'

#define VERSIONWS '3.5.5'
#define MINVERSIONAPP '1.11.1'
#define DATEVERSION '17/05/2024'

#define __AFIELDSO_SO__ 1
#define _OS_ 1
#define _SS_ 2
#define CANCELCODE 1
#define FINISHCODE 2

// Posições que definem a situação do insumo.
#define _REALIZED_       1
#define _FORESEEN_       2

// Posições do array de insumos que definem a operação.
#define _UPDATE_         1
#define _INSERT_         2
#define _DELETE_         3

#define _TAREFA_         1
#define _ETAPA_          2
#define _SEQETA_         3
#define _SEQTARE_        4
#define _CODFUNC_        5
#define _OK_             6
#define _ANSWERS_        7

// Posições dos detalhes dos insumos.
#define _SEQUENCE_       1
#define _TASK_           2
#define _KEYTASK_        3
#define _TYPE_           4
#define _CODE_           5
#define _KEYCODE_        6
#define _USECALE_        7
#define _RESOURCEAMOUNT_ 8
#define _AMOUNT_         9
#define _UNITY_          10
#define _COST_           11
#define _DESTINY_        12
#define _STARTDATE_      13
#define _STARTHOUR_      14
#define _ENDDATE_        15
#define _ENDHOUR_        16
#define _WAREHOUSE_      17
#define _LOT_            18
#define _SUBLOT_         19
#define _DATELOT_        20
#define _LOCATION_       21
#define _SERIALNUMBER_   22
#define _INPUTNOTE_      23
#define _HOURUNITY_      24
#define _SUPPLIER_       25
#define _STORE_          26
#define _WHITEM_         27
#define _WHREQUEST_      28
#define _SEQTASK_        29
#define _PERCENT_        30
#define _OCCURRENCES_    31
#define _SCNUM_          32
#define _SCITEM_         33

// Posições dos detalhes de ocorrências
#define _PROBLEM_        1
#define _CAUSE_          2
#define _KEYCAUSE_       3
#define _SOLUTION_       4
#define _KEYSOLUTION_    5
#define _OCCURNOTE_      6

#xtranslate @{Header <(cName)>} => ::GetHeader( <(cName)> )
#xtranslate @{Param <n>} => ::aURLParms\[ <n> \]
#xtranslate @{EndRoute} => EndCase
#xtranslate @{Route} => Do Case
#xtranslate @{When <path>} => Case NGIsRoute( ::aURLParms, <path> )
#xtranslate @{When <path> || <path2>} => Case NGIsRoute( ::aURLParms, <path> ) .or. NGIsRoute( ::aURLParms, <path2> )
#xtranslate @{Default} => Otherwise

//métodos que serão renomeados por motivos de Limitação de caracteres
#xtranslate EquipmentPicture => R01
#xtranslate WorkerPicture => R02
#xtranslate ObjectPicture => R03

#xtranslate OrderPicture => R04
#xtranslate OrderPictureRemove => R05
#xtranslate OrderCreate => R06
#xtranslate OrderUpdate => R07
#xtranslate OrderCancel => R08
#xtranslate OrderFinish => R09
#xtranslate OrderPictureList => R10

#xtranslate RequestCreate => R11
#xtranslate RequestPicture => R12
#xtranslate RequestPictureRemove => R13
#xtranslate RequestUpdate => R14
#xtranslate RequestOperation => R15
#xtranslate RequestRemove => R16
#xtranslate RequestPictureList => R17
#xtranslate EnvironmentInformation => R18

Static aInputs                := { { {}, {}, {} }, { {}, {}, {} } } // Array contendo todos os insumos recebidos do app MNTNG
Static aEtapas                := { {},{}, {} }
Static cBarra                 := If(isSRVunix(),"/","\")
Static cCurDir                := CurDir() + If(cBarra $ CurDir(), "" , cBarra )
Static cUserST1               := "" //Código do funcionário da manutenção T1_CODFUNC
Static cUserTQ4               := "" //Código do executante TQ4_CDEXEC
Static cUserLog               := "" //Código do usuário Protheus
Static lPortalOrigin          := .F. //Indica quando é sincronização do portal mobile
Static lOrderPermission       := .F. //Indica se deve validar ambiente para ordens de serviço
Static lRequestPermission     := .F. //Indica se deve validar ambiente para solicitações no login e sync
Static aPermissions           := {}//Permissões do grupo do usuário do portal mobile
Static lPeMntNg               := ExistBlock("MNTNG")
Static lPeMntLog              := ExistBlock('MNTNGLOG') .And. ExecBlock('MNTNGLOG', .F., .F.,{})
Static lDBOrderOk             := .F. //Indica se os campos de usuários para OS estão configurados
Static lDBRequestOk           := .F. //Indica se os campos de usuário oara SS estão configurados
Static lNewSync               := .T. // Indica se a sincronização é via chunked
Static cIsNull                := IIf( Upper(AllTrim(TcGetDB())) == "ORACLE","NVL",IIf( Upper(AllTrim(TcGetDB())) $ "DB2","COALESCE","ISNULL" ) )
Static lMigrated              := .F. // Indica se ambiente já foi migrado para sinc sem portal
Static cUserGrp				  := ''  // Código do grupo do usuário
Static lAppSimult			  := .T. // se app suporta acesso simultâneo de checklist

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTNG
WebService REST para comunicação do aplicativo MNT NG com o SIGAMNT

@author	Larissa Thaís de Farias
@author Marcelo Camargo
@author Vitor Emanuel Batista
@author William Rozin
@author Maria Elisandra de Paula
@since	08/01/2016
@version P12
@return	Nil
/*/
//---------------------------------------------------------------------
WsRestful MNTNG Description STR0001 // "WebService utilizado na aplicação mobile de Ordem de Serviço do módulo de Manutenção de Ativos (SIGAMNT)."

	WsData Value As Character Optional
	WsData Operation As Character Optional
	WsData LastSync As Character Optional
	WsData product As Character Optional
	WsData warehouse As Character Optional
	WsData itemType As Character Optional
	WsData itemCode As Character Optional
	WsData itemName As Character Optional
	WsData docCode As Character Optional

	WsMethod GET WorkerPicture Description STR0095 Path 'worker/picture/{email}' WsSyntax 'worker/picture/{email}' //"Download da imagem do funcionário"
	WsMethod GET EquipmentPicture Description STR0098 Path 'equipment/picture/{equipment}' WsSyntax 'equipment/picture/{equipment}' //"Download de imagem do equipamento"
	WsMethod GET ObjectPicture Description STR0099 Path 'picture/{object}' WsSyntax 'picture/{object}' //"Download de imagem pelo código do objeto"
	WsMethod GET OrderPictureList Description STR0100 Path 'pictures/{order}' WsSyntax 'pictures/{order}' //"Informações das imagens vinculadas à ordem de serviço"
	WsMethod GET RequestPictureList Description STR0101 Path 'service-request/{value}/list' WsSyntax 'service-request/{value}/list' //"Informações das imagens vinculadas à solicitação de serviço"
	WsMethod GET Version Description STR0102 Path 'version' WsSyntax 'version' //"Versão e data do web service"
	WsMethod GET V1Sync Description STR0103 Path '/v1/sync/{date}/' WsSyntax '/v1/sync/{date}/' //"Download de arquivos para o sincronismo"
	WsMethod GET V3Sync Description STR0200 Path '/v3/sync/{lastsync}/' WsSyntax '/v3/sync/{lastsync}' // "Sincronismo do app e Protheus (apenas uma entidade)"
	WsMethod GET DocList Description STR0211 Path 'doc/list/{itemType}/{itemCode}' WsSyntax 'doclist/{itemType}/{itemCode}' // "Lista de documentos de uma ordem ou solicitação"
	WsMethod GET Doc Description STR0212 Path 'doc/{itemName}' WsSyntax 'doc/{itemName}' // "Download de um documento de uma ordem ou solicitação"

	WsMethod GET CheckAll Description STR0148 Path '/check/all/' WsSyntax '/check/all/' //"Validações para utilização do MNTNG"
	WsMethod GET LGV2 Description STR0189 Path 'loginV2' WsSyntax 'loginV2' // "Retorna os detalhes de uma filial via Mingle"

    WSMETHOD GET SB2;
        DESCRIPTION STR0201; //"Retorna saldo do insumo";
        WSSYNTAX "product-sb2/{product}" ;
        PATH "product-sb2/{product}"

    WSMETHOD GET SBF;
        DESCRIPTION STR0202; //"Retorna saldo do insumo com endereçamento";
        WSSYNTAX "product-sbf/{product}/{warehouse}}" ;
        PATH "product-sbf/{product}/{warehouse}"

	WsMethod GET SpareParts Description STR0216 Path 'equipment/spare-parts/{itemcode}' WsSyntax 'equipment/spare-parts/{itemcode}' // Peças de reposição


	WsMethod POST Login Description STR0107 Path 'login' WsSyntax 'login' //"Autenticação do usuário"
	WsMethod POST Counter Description STR0108 Path 'counter' WsSyntax 'counter' //"Apontamento de contador"
	WsMethod POST PlayStop Description STR0109 Path 'playStop' WsSyntax 'playStop' //"Inicia ou finaliza um apontamento de mão de obra da ordem de serviço"
	WsMethod POST EquipmentPicture Description STR0110 Path 'upload/equipment/{equipment}' WsSyntax 'upload/equipment/{equipment}' //"Atualiza a imagem do equipamento no cadastro de bens"
	WsMethod POST WorkerPicture Description STR0111 Path 'upload/worker/{worker}' WsSyntax 'upload/worker/{worker}' //"Atualiza a imagem do funcionário no cadastro de funcionário da manutenção"
	WsMethod POST OrderPicture Description STR0112 Path 'upload/{operation}/{value}' WsSyntax 'upload/{operation}/{value}' //"Upload de imagem correspondendo a um problema ou solução da ordem de serviço"
	WsMethod POST OrderPictureRemove Description STR0113 Path 'picture/delete/{id}' WsSyntax 'picture/delete/{id}' //"Remove uma imagem da ordem de serviço"
	WsMethod POST OrderCreate Description STR0114 Path 'create' WsSyntax 'create' //"Inclusão de ordem de serviço"
	WsMethod POST OrderUpdate Description STR0115 Path 'update' WsSyntax 'update' //"Alteração de ordem de serviço"
	WsMethod POST OrderCancel Description STR0116 Path 'cancel' WsSyntax 'cancel' //"Cancelamento de ordem de serviço"
	WsMethod POST OrderFinish Description STR0117 Path 'finish' WsSyntax 'finish' //"Finalização de ordem de serviço"
	WsMethod POST RequestCreate Description STR0118 Path 'service-request' WsSyntax 'service-request' //"Inclusão de solicitação de serviço"
	WsMethod POST RequestPicture Description STR0119 Path 'service-request/{value}/{operation}' WsSyntax 'service-request/{value}/problem' //"Upload de imagem correspondendo a um problema da solicitação de serviço"
    WsMethod POST Groups Description STR0204 Path 'portal/groups' WsSyntax 'portal/groups' //'Migração de Grupos MNTNG Portal'
	WsMethod POST Permissions Description STR0205 Path 'portal/permissions' WsSyntax 'portal/permissions' //'Permissões de Grupos MNTNG Portal'
	WsMethod POST Users Description STR0206 Path 'portal/users' WsSyntax 'portal/users' //'Usuários de Grupos MNTNG Portal'
	WsMethod POST Filters Description STR0207 Path 'portal/filters' WsSyntax 'portal/filters' //'Filtros de Grupos MNTNG Portal'
	WsMethod POST EnvironmentInformation Description STR0208 Path 'portal/infos' WsSyntax 'portal/infos' //"Grava informações do ambiente obtidos por Migração do Portal Mobile"
	WsMethod POST Doc Description STR0213 Path 'doc/{itemType}/{itemCode}/{itemName}' WsSyntax 'doc/{itemType}/{itemCode}/{itemName}' // "Inclusão e upload de um documento de uma ordem ou solicitação"

	WsMethod DELETE RequestRemove Description STR0120 Path 'service-request/{value}/' WsSyntax 'service-request/{value}/' //"Remove uma solicitação de serviço"
	WsMethod DELETE RequestPictureRemove Description STR0121 Path 'service-request/{value}/image/' WsSyntax 'service-request/{value}/image/' //"Remove uma imagem da solicitação de serviço"
	WsMethod DELETE AC9 Description STR0214 Path 'ac9/{itemType}/{itemCode}/{docCode}' WsSyntax 'ac9/{itemType}/{itemCode}/{docCode}' // "Exclusão de um documento de uma ordem ou solicitação"

	WsMethod PUT RequestUpdate Description STR0122 Path 'service-request/{value}/' WsSyntax 'service-request/{value}/' //"Alteração de solicitação de serviço"
	WsMethod PUT RequestOperation Description STR0123 Path 'service-request/{value}/{operation}' WsSyntax 'service-request/{value}/{operation}' //"Operações da solicitação de serviço"

End WsRestful

//---------------------------------------------------------------------
/*/{Protheus.doc} Login
Retorna as filiais do usuário (ação do botão Listar filiais)

@author Maria Elisandra de Paula
@since 21/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WSMETHOD POST Login WsService Mntng

	Local lRet := .T.
	Local bLastError
	Local oError

	printf('Metodo POST Login: listar filiais via portal')

	::ClearResponse()
	::SetContentType( 'application/json' )

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )
	Begin Sequence

		If ( lRet := fCheckVars( Self ) )
			lRet := MultiBranchLogin( Self )
		EndIf

	End Sequence

	ErrorBlock( bLastError )

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} LGV2
Aciona login V2 -> detalhes da filial

@author Maria Elisandra de Paula
@param oSelf, instancia do ws
@since 14/06/2022
@return logic, se obteve sucesso no login
/*/
//---------------------------------------------------------------------
WSMETHOD GET LGV2 WsService Mntng

	Local lRet := .F.
	Local bLastError
	Local oError

	printf('inicio infos da filial')

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )
	Begin Sequence
		If ( lRet := fCheckVars( Self, .T. ) )
			lRet := fInfoMINGL( Self )
		EndIf
	End Sequence

	ErrorBlock( bLastError )

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} SB2
Aciona o envio do saldo do insumo

@author Maria Elisandra de Paula
@param oSelf, instancia do ws
@since 30/08/2022
@return logic, se obteve sucesso no login
/*/
//---------------------------------------------------------------------
WSMETHOD GET SB2 QUERYPARAM Page PATHPARAM product WsService mntng

	Local lRet := .T.
	Local bLastError
	Local oError
	Local aRet := {}

	printf('Metodo GET SB2')

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := fCheckVars( Self ) )

			aRet := fGetSalSb2( Self, ::product )
			if !aRet[1]
				PrintPostLog( Self, lRet, aRet )
			EndIf
		EndIf
	End Sequence

	ErrorBlock(bLastError)
	
Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} SBF
Aciona o envio de saldo do insumo com endereçamento

@author Maria Elisandra de Paula
@param oSelf, instancia do ws
@since 30/08/2022
@return logic, se obteve sucesso no login
/*/
//---------------------------------------------------------------------
WSMETHOD GET SBF QUERYPARAM Page PATHPARAM product, warehouse WsService mntng

	Local lRet := .T.
	Local bLastError
	Local oError
	Local aRet := {}

	printf('Metodo GET SBF')

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := fCheckVars( Self ) )

			aRet := fGetSalSbf( Self, ::product, ::warehouse )
			if !aRet[1]
				PrintPostLog( Self, lRet, aRet )
			EndIf
		EndIf
	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} Spare-Parts
Cria rota json para retorno de peças de reposição

@author Pedro Henrique Perez Trebilcock
@param itemcode, String, codigo do bem
@since 16/10/2023
@return logic, se obteve sucesso no login
/*/
//---------------------------------------------------------------------
WSMETHOD GET SpareParts PATHPARAM itemcode WsService mntng

	Local lRet := .T.
	Local bLastError
	Local oError
	Local aRet := {}

	printf('Metodo GET SpareParts')

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := fCheckVars( Self ) )

			aRet := fGetParts( Self, ::itemcode)
			if !aRet[1]
				lRet := .f.
				PrintPostLog( Self, lRet, aRet )
			EndIf
		EndIf
	End Sequence

	ErrorBlock(bLastError)

Return lRet


//---------------------------------------------------------------------
/*/{Protheus.doc} EquipmentPicture
Atualiza imagem do equipamento no cadastro de Bens

@author Maria Elisandra de Paula
@since 21/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WSMETHOD POST EquipmentPicture WsService Mntng

	Local lRet := .T.
	Local aRet := {}
	Local bLastError
	Local oError

	printf('Metodo POST EquipmentPicture')

	Private cUserName

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := fCheckVars( Self ) )

			Begin Transaction

				lRet := fCreateImg( @{Param 3}, Self, 'ST9' )
				PrintPostLog( Self, lRet )

			Recover
				DisarmTransaction()
			End Transaction

			CloseTransactions( aRet )

		EndIf
	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} WorkerPicture
Atualiza imagem do funcionário no cadastro de funcionário da manutenção

@author Maria Elisandra de Paula
@since 21/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WSMETHOD POST WorkerPicture WsService Mntng

	Local lRet := .T.
	Local aRet := {}
	Local bLastError
	Local oError

	Private cUserName

	printf('Metodo POST WorkerPicture')

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := fCheckVars( Self ) )

			Begin Transaction

				lRet := fCreateImg( @{Param 3}, Self, 'ST1' )
				PrintPostLog( Self, lRet )

			Recover
				DisarmTransaction()

			End Transaction

			CloseTransactions( aRet )

		EndIf

	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} OrderPicture
Upload de imagem correspondendo a um problema ou solução da ordem de serviço

@author Maria Elisandra de Paula
@since 21/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WSMETHOD POST OrderPicture PATHPARAM value, operation WsService Mntng

	Local lRet := .T.
	Local aRet := {}
	Local bLastError
	Local oError

	Private cUserName

	printf('Metodo POST OrderPicture' )

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := fCheckVars( Self ) )

			Begin Transaction

				aRet := fSaveImg( Self, ::value, Upper( ::operation ), 'STJ' )
				lRet := PrintPostLog( Self, lRet, aRet )

			Recover
				DisarmTransaction()

			End Transaction

			CloseTransactions( aRet )

		EndIf

	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} OrderPictureRemove
Remove imagem da ordem de serviço

@author Maria Elisandra de Paula
@since 21/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WSMETHOD POST OrderPictureRemove WsService Mntng

	Local lRet := .T.
	Local aRet := {}
	Local bLastError
	Local oError

	Private cUserName

	printf('Metodo POST OrderPictureRemove')

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := fCheckVars( Self ) )

			Begin Transaction

				aRet := DelOrderFile( @{Param 3}, Self )
				lRet := PrintPostLog( Self, lRet, aRet )

			Recover
				DisarmTransaction()

			End Transaction

			CloseTransactions( aRet )

		EndIf

	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} OrderCreate
Inclui ordem de serviço

@author Maria Elisandra de Paula
@since 21/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WSMETHOD POST OrderCreate WsService Mntng

	Local lTmpTbl := .F.
	Local lRet    := .T.
	Local aRet    := {}
	Local bLastError
	Local oError

	Private cUserName
	Private aNewSc   := {}

	printf('Metodo POST OrderCreate')

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := fCheckVars( Self ) )

			If ( lTmpTbl := AllTrim( SuperGetMv( 'MV_NGMNTES', .F., 'N' ) ) == 'S' .And. AllTrim( SuperGetMv( 'MV_MNTPRAL', .F., '2' ) ) == '1' .And. FindFunction( 'NewTrbAlt' ) )
				// Quando utilizado conceito de produto alternativo se faz necessária criação dos TRB's antes da
				// inicialização do begin transaction.
				NewTrbAlt()
			EndIf

			Begin Transaction

				aRet := createSO( Self )
				lRet := PrintPostLog( Self, lRet, aRet )

			Recover
				DisarmTransaction()

			End Transaction

			CloseTransactions( aRet )

		EndIf

	End Sequence
	If lTmpTbl
		oTempIns:Delete()
		oTempSLP:Delete()
	EndIf
	ErrorBlock(bLastError)

Return lRet


//---------------------------------------------------------------------
/*/{Protheus.doc} OrderUpdate
Altera ordem de serviço

@author Maria Elisandra de Paula
@since 21/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WSMETHOD POST OrderUpdate WsService Mntng

	Local lTmpTbl := .F.
	Local lRet    := .T.
	Local aRet    := {}
	Local bLastError
	Local oError

	Private cUserName
	Private aNewSc   := {}

	printf('Metodo POST OrderUpdate')

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := fCheckVars( Self ) )

			If ( lTmpTbl := AllTrim( SuperGetMv( 'MV_NGMNTES', .F., 'N' ) ) == 'S' .And. AllTrim( SuperGetMv( 'MV_MNTPRAL', .F., '2' ) ) == '1' .And. FindFunction( 'NewTrbAlt' ) )
				// Quando utilizado conceito de produto alternativo se faz necessária criação dos TRB's antes da
				// inicialização do begin transaction.
				NewTrbAlt()
			EndIf

			Begin Transaction

				aRet := updateSO( Self:GetContent(), Self )
				lRet := PrintPostLog( Self, lRet, aRet )

			Recover
				DisarmTransaction()

			End Transaction

			CloseTransactions( aRet )

		EndIf

	End Sequence
	If lTmpTbl
		oTempIns:Delete()
		oTempSLP:Delete()
	EndIf
	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} OrderCancel
Cancela ordem de serviço

@author Maria Elisandra de Paula
@since 21/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WSMETHOD POST OrderCancel WsService Mntng

	Local lRet := .T.
	Local aRet := {}
	Local bLastError
	Local oError

	Private cUserName

	printf('Metodo POST OrderCancel')

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := fCheckVars( Self ) )

			Begin Transaction

				aRet := cancelSO( Self )
				lRet := PrintPostLog( Self, lRet, aRet )

			Recover
				DisarmTransaction()

			End Transaction

			CloseTransactions( aRet )

		EndIf

	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} OrderFinish
Finaliza ordem de serviço

@author Maria Elisandra de Paula
@since 21/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WSMETHOD POST OrderFinish WsService Mntng

	Local lRet := .T.
	Local aRet := {}
	Local bLastError
	Local oError

	Private cUserName

	printf('Metodo POST OrderFinish')

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := fCheckVars( Self ) )

			Begin Transaction

				aRet := finishSO( Self )
				lRet := PrintPostLog( Self, lRet, aRet )

			Recover
				DisarmTransaction()

			End Transaction

			CloseTransactions( aRet )

		EndIf

	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} PlayStop
Inicia ou finaliza um apontamento de mão de obra da ordem de serviço

@author Maria Elisandra de Paula
@since 21/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WSMETHOD POST PlayStop WsService Mntng

	Local lRet := .T.
	Local aRet := {}
	Local bLastError
	Local oError

	Private cUserName

	printf('Metodo POST playStop')

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := fCheckVars( Self ) )

			Begin Transaction

				aRet := MNTNGInput( 2, Nil, Nil, Self:GetContent() )
				lRet := PrintPostLog( Self, lRet, aRet )

			Recover
				DisarmTransaction()

			End Transaction

			CloseTransactions( aRet )

		EndIf

	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} Counter
Realiza o apontamento de contador

@author Maria Elisandra de Paula
@since 21/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WSMETHOD POST Counter WsService Mntng

	Local lTmpTbl := .F.
	Local lRet    := .T.
	Local aRet    := {}
	Local bLastError
	Local oError

	Private cUserName
	Private aNewSc   := {}

	printf('Metodo POST counter')

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := fCheckVars( Self ) )

			If ( lTmpTbl := AllTrim( SuperGetMv( 'MV_NGMNTES', .F., 'N' ) ) == 'S' .And. AllTrim( SuperGetMv( 'MV_MNTPRAL', .F., '2' ) ) == '1' .And. FindFunction( 'NewTrbAlt' ) )
				// Quando utilizado conceito de produto alternativo se faz necessária criação dos TRB's antes da
				// inicialização do begin transaction.
				NewTrbAlt()
			EndIf

			Begin Transaction

				aRet := updCounter( Self:GetContent() )
				lRet := PrintPostLog( Self, lRet, aRet )

			Recover
				DisarmTransaction()

			End Transaction

			CloseTransactions( aRet )

		EndIf

	End Sequence
	If lTmpTbl
		oTempIns:Delete()
		oTempSLP:Delete()
	EndIf
	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} RequestCreate
Inclusão de solicitação de serviço

@author Maria Elisandra de Paula
@since 21/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WSMETHOD POST RequestCreate WsService Mntng

	Local lRet := .T.
	Local aRet := {}
	Local bLastError
	Local oError

	Private cUserName

	printf('Metodo POST RequestCreate')

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := fCheckVars( Self ) )

			Begin Transaction

				aRet := NGUpsertSR( Self, "create", Nil )
				lRet := PrintPostLog( Self, lRet, aRet )

			Recover
				DisarmTransaction()

			End Transaction

			CloseTransactions( aRet )

		EndIf

	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} RequestPicture
Upload de imagem correspondendo a um problema ou solução da solicitação de serviço

@author Maria Elisandra de Paula
@since 21/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WSMETHOD POST RequestPicture PATHPARAM value, operation WsService Mntng

	Local lRet := .T.
	Local aRet := {}
	Local bLastError
	Local oError

	Private cUserName

	printf('Metodo POST RequestPicture')

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := fCheckVars( Self ) )

			Begin Transaction

				aRet := fSaveImg( Self, ::value, Upper( ::operation ), 'TQB' )
				lRet := PrintPostLog( Self, lRet, aRet )

			Recover
				DisarmTransaction()

			End Transaction

			CloseTransactions( aRet )

		EndIf

	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} Post Doc
Método para gravar um arquivo no banco de conhecimento

@param itemType, string, tipo do item: 'order' ou 'request'
@param itemCode, string, código da os/ss
@param itemName, string, nome do documento

@author Maria Elisandra de paula
@since 12/07/2023
@return	boolean
/*/
//---------------------------------------------------------------------
WSMETHOD POST Doc PATHPARAM itemType, itemCode, itemName  WsService Mntng
	
	Local bLastError
	Local oError
	Local lRet  := .T.
	Local aRet  := {}
	Local cName := ''

	printf('Metodo Post Doc')

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := fCheckVars( Self ) )

			cName := DecodeUtf8( ::itemName )

			If Empty(cName)
				cName := ::itemName
			EndIf

			aRet := fDocCreate( Self, ::itemType, ::itemCode, cName )

			if !aRet[1]
				PrintPostLog( Self, lRet, aRet )
			EndIf
		EndIf
	End Sequence

	ErrorBlock(bLastError)
	
Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} Delete Doc
Método para deletar um arquivo no banco de conhecimeto

@param itemType, string, tipo do item: 'order' ou 'request'
@param itemCode, string, código do objeto na tabela AC9

@author Maria Elisandra de paula
@since 28/08/2023
@return	boolean
/*/
//---------------------------------------------------------------------
WSMETHOD DELETE AC9 PATHPARAM itemType, itemCode, docCode WsService Mntng

	Local lRet := .T.
	Local bLastError
	Local oError
	Local aRet := {}

	printf('Metodo Delete Doc')

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := fCheckVars( Self ) )

			aRet := fDeleteAC9( Self, ::itemType ,::itemCode, ::docCode )
			PrintPostLog( Self, lRet, aRet )
		EndIf
	End Sequence

	ErrorBlock(bLastError)
	
Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} Version
Retorna a versão atual do ws

@author Maria Elisandra de Paula
@since 29/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WsMethod GET Version WsService Mntng

	::ClearResponse()
	::SetContentType( 'application/json' )

	printf('Metodo GET Version')
	::SetStatus( 200 )
	::SetResponse( getVersion() )
Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} CheckAll
Validações para utilização do app

@author	Maria Elisandra de Paula
@since 30/01/2019
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WsMethod GET CheckAll WsService Mntng

	Local lRet := .T.
	Local bLastError
	Local oError

	printf('Metodo GET CheckAll via portal')

	::ClearResponse()
	::SetContentType( 'application/json' )

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence
		If ( lRet := fCheckVars( Self ) )
			lRet :=  CheckEnvironment( Self )
		EndIf
	End Sequence

	ErrorBlock( bLastError )

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} V1Sync
Gera e envia json de sincronismo (ação do botão Atualizar filial )

@author	Maria Elisandra de Paula
@since 29/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WsMethod GET V1Sync WsService Mntng

	Local lRet := .T.
	Local aRet := {}
	Local bLastError
	Local oError

	lNewSync := .F.

	printf('Metodo GET V1Sync: atualizar filial via portal')

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := fCheckVars( Self, .T. ) )

			aRet := DoSyncV1( Self, @{Param 3} )
			lRet := PrintPostLog( Self, lRet, aRet )
		EndIf

	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} V3SYNC
Envia pacote de dados de sincronismo (em pedaços)

@author	Maria Elisandra de Paula
@since 20/09/2022
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WsMethod GET V3SYNC PATHPARAM LastSync WsService Mntng

	Local lRet := .T.
	Local bLastError
	Local oError
	Local aRet := {}
	Local cMsg := 'Metodo V3SYNC ' + ::LastSync

	lNewSync := .T.

	If ValType( ::GetHeader( 'user' ) ) == 'C'
		cMsg := cMsg + " " + ::GetHeader( 'user' )
	EndIf

	printf(cMsg)

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := fCheckVars( Self, .T. ) )

			aRet := DoSyncV3( Self, ::lastsync )
			If !(lRet := aRet[1])
				PrintPostLog( Self, lRet, aRet )
			EndIf

		EndIf

	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} EquipmentPicture
Realiza download de imagem do equipamento

@author	Maria Elisandra de Paula
@since 29/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WsMethod GET EquipmentPicture WsService Mntng

	Local lRet := .T.
	Local bLastError
	Local oError

	printf('Metodo GET EquipmentPicture')

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := fCheckVars( Self ) )

			lRet := fEquiPic( @{Param 3}, Self )
			PrintPostLog( Self, lRet )

		EndIf
	End Sequence

	ErrorBlock(bLastError)

Return lRet


//---------------------------------------------------------------------
/*/{Protheus.doc} WorkerPicture
Download da imagem do funcionário

@author	Maria Elisandra de Paula
@since 29/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WsMethod GET WorkerPicture WsService Mntng

	Local lRet := .T.
	Local bLastError
	Local oError

	printf('Metodo GET WorkerPicture')

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := fCheckVars( Self ) )

			lRet := fWorkerPic( Self )
			PrintPostLog( Self, lRet )

		EndIf
	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} OrderPictureList
Retorna uma lista de imagens vinculadas a ordem de serviço

@author	Maria Elisandra de Paula
@since 29/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WsMethod GET OrderPictureList WsService Mntng

	Local lRet := .T.
	Local bLastError
	Local oError

	printf('Metodo GET OrderPictureList')

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := fCheckVars( Self ) )

			lRet := OrderPics( @{Param 2}, Self )
			PrintPostLog( Self, lRet )

		EndIf
	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} ObjectPicture
Realiza download de imagem recebendo o código do objeto

@author	Maria Elisandra de Paula
@since 29/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WsMethod GET ObjectPicture WsService Mntng

	Local lRet := .T.
	Local bLastError
	Local oError

	printf('Metodo GET ObjectPicture')

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := fCheckVars( Self ) )

			lRet := PicFromRepo( @{Param 2}, Self )
			PrintPostLog( Self, lRet )

		EndIf
	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} RequestPictureList
Retorna lista de imagens vinculadas a solicitação de serviço

@author	Maria Elisandra de Paula
@since 29/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WsMethod GET RequestPictureList WsService Mntng

	Local lRet := .T.
	Local bLastError
	Local oError

	printf('Metodo GET RequestPictureList')

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := fCheckVars( Self ) )

			lRet := listImgSR( @{Param 2}, Self )
			PrintPostLog( Self, lRet )

		EndIf
	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} GET Doc
Método para retornar um arquivo do banco de conhecimento

@param itemName, string, nome do documento

@author Maria Elisandra de paula
@since 12/07/2023
@return	boolean
/*/
//---------------------------------------------------------------------
WSMETHOD GET Doc PATHPARAM itemName WsService Mntng

	Local lRet := .T.
	Local bLastError
	Local oError
	Local aRet := {}

	printf('Metodo Get doc')

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := fCheckVars( Self ) )

			aRet := fGetDoc( Self, DecodeUTF8( self:itemName ) )
			If !aRet[1]
				PrintPostLog( Self, lRet, aRet )
			EndIf
		EndIf
	End Sequence

	ErrorBlock(bLastError)
	
Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} Get DocList
Método para retorna uma lista com documentos de uma ordem/solicitação

@param itemType, string, tipo de base: 'order' ou 'request'
@param itemCode, string, código da ordem ou solicitação

@author Maria Elisandra de paula
@since 12/07/2023
@return	boolean
/*/
//---------------------------------------------------------------------
WSMETHOD GET DocList PATHPARAM itemType, itemCode WsService Mntng

	Local lRet := .T.
	Local bLastError
	Local oError
	Local aRet := {}

	printf('Metodo Get DocList')

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := fCheckVars( Self ) )

			aRet := fGetDocs( Self, ::itemType, ::itemCode )
			if !aRet[1]
				PrintPostLog( Self, lRet, aRet )
			EndIf
		EndIf
	End Sequence

	ErrorBlock(bLastError)
	
Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} RequestOperation
 Realiza as operações que alteram a situação da solicitação de serviço
'distribute', 'finish', 'feedback'

@author Maria Elisandra de paula
@since 22/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WSMETHOD PUT RequestOperation PATHPARAM value, operation WsService Mntng

	Local aRet := {.T., ""}
	Local bLastError
	Local oError
	Local lRet  := .T.

	printf('Metodo PUT: RequestOperation ' + ::operation )

	/*O ErrorBlock logo abaixo tem controle de transação e deve ser usado da seguinte forma
	Begin Sequence
		...operações antes de abrir a empresa (sem controle de transação)
		Begin Transaction
		...operações após abrir a empresa (controle de transação)
			Recover
				DisarmTransaction()
		End Transaction
	End Sequence
	*/
	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )
	
	Begin Sequence

		If ( lRet := fCheckVars( Self ) )

			Begin Transaction

				aRet := NGUpsertSR( Self, ::operation , ::value )
				lRet := PrintPostLog( Self, lRet, aRet )

			Recover
				DisarmTransaction()

			End Transaction

			CloseTransactions( aRet )

		EndIf

	End Sequence

	ErrorBlock(bLastError)

Return lRet


//---------------------------------------------------------------------
/*/{Protheus.doc} RequestUpdate
 Alterações na solicitação de serviço

@author Maria Elisandra de paula
@since 22/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WSMETHOD PUT RequestUpdate WsService Mntng

	Local aRet := {.T., ""}
	Local bLastError
	Local oError
	Local lRet  := .T.

	printf('Metodo PUT: RequestUpdate')

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := fCheckVars( Self ) )

			Begin Transaction

				aRet := NGUpsertSR( Self, "update", @{Param 2} )
				lRet := PrintPostLog( Self, lRet, aRet )

			Recover
				DisarmTransaction()

			End Transaction

			CloseTransactions( aRet )

		EndIf

	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} RequestRemove
Remove solicitação de serviço

@author Maria Elisandra de paula
@since 22/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WsMethod DELETE RequestRemove WsService Mntng

	Local aRet := {.T., ""}
	Local bLastError
	Local oError
	Local lRet := .T.

	printf('Metodo DELETE: Request')

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := fCheckVars( Self ) )

			Begin Transaction

				aRet := removeSR( Self, @{Param 2} )
				lRet := PrintPostLog( Self, lRet, aRet )

			Recover
				DisarmTransaction()

			End Transaction

			CloseTransactions( aRet )

		EndIf

	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} RequestPictureRemove
Remove imagem da solicitação de serviço

@author Maria Elisandra de paula
@since 22/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WsMethod DELETE RequestPictureRemove WsService Mntng

	Local aRet := {.T., ""}
	Local bLastError
	Local oError
	Local lRet := .T.

	printf('Metodo DELETE: RequestPictureRemove')

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := fCheckVars( Self ) )

			Begin Transaction

				aRet := delImageSR( Self, @{Param 2} )
				lRet := PrintPostLog( Self, lRet, aRet )

			Recover
				DisarmTransaction()

			End Transaction

			CloseTransactions( aRet )

		EndIf

	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} GCSync
Garbage collector para os pacotes gerados na pasta temporária. Remove
todos os pacotes velhos e que não estão em uso, que passaram de um dia
para o outro quando já passamos da 01:00.

@author Marcelo Camargo
@since 07/2016
@return nil
/*/
//---------------------------------------------------------------------
Static Function GCSync
	Local cThreadId :=  AllTrim( Str( ThreadId() ) )
	Local aFiles := Directory( cCurDir + "tmp" + cBarra + cThreadId + cBarra + "*", "HSD" )
	Local nI
	Local cDate

	For nI := 1 To Len( aFiles )
		cDate := DToC( aFiles[ nI, 3 ] )
		FErase( cCurDir + "tmp" + cBarra + cThreadId + cBarra + aFiles[ nI, 1 ] )
	Next nI

	DirRemove(cCurDir + "tmp" + cBarra + cThreadId )

Return

//----------------------------------------------------------------------------------
/*/{Protheus.doc} fEntities
Retorna as funções que serão acionadas para gerar dados conforme permissões

@author Maria Elisandra de Paula
@since 20/09/2022
@return array, entidades
/*/
//-----------------------------------------------------------------------------------
Static Function fEntities()

	Local aMethods := {}

	If lOrderPermission .And. lDBOrderOk

		//Entidades gerais para ordem de serviço
		aMethods := { 'sEquipment'  , 'sCostCenter', 'sOrder'     , 'sService'   ,;
						'sCheckSO'    , 'sInputSO'   , 'sAnswer'    , 'sTask'      ,;
						'sMaintenance', 'sPrevTask'  , 'sCheckMain' , 'sInputMain' ,;
						'sProduct'    , 'sWarehouse' , 'sWorker'    , 'sThirdPart' ,;
						'sTool'       , 'sChecklist' , 'sQuestion'  , 'sSpeciality' }

		If fHasPerms('finish-order')
			aAdd( aMethods, "sFault" )
		EndIf

		If fHasPerms('occurrences')
			aAdd( aMethods, 'sOccurrences' )
			aAdd( aMethods, 'sExceptionFamily' )
			aAdd( aMethods, 'sAssociated' )
		EndIf

		If fHasPerms('location-order')
			aAdd( aMethods, "sLocation" )
		EndIf

	Else
		aMethods := {}
	EndIf

	If lRequestPermission .And. RequestIsOk()

		//Entidades gerais para solicitação de serviço
		If aScan( aMethods, "sEquipment" ) == 0
			aAdd( aMethods, "sEquipment" )
		EndIf
		aAdd( aMethods, "sRequest" )
		aAdd( aMethods, "sRequestOrders" )

		If fHasPerms('generate-ss-os')
			aAdd( aMethods, "sWorkCenter" )

			If aScan( aMethods, "sCostCenter" ) == 0
				aAdd( aMethods, "sCostCenter" )
			EndIf

			If aScan( aMethods, "sService" ) == 0
				aAdd( aMethods, "sService" )
			EndIf
		EndIf

		//Incluir e editar
		If fHasPerms('create-ss') .Or. fHasPerms('edit-service-request') .Or. fHasPerms('distribute-ss')
			aAdd( aMethods, "sServiceType" )
			aAdd( aMethods, "sExecutor" )
		EndIf

		If fHasPerms('location-ss') .And. aScan( aMethods, "sLocation" ) == 0 
			aAdd( aMethods, "sLocation" )
		EndIf

	EndIf

Return aMethods

//----------------------------------------------------------------------------------
/*/{Protheus.doc} DoSyncV1
Realiza sincronismo v1

@author Maria Elisandra de Paula
@since 16/10/2018
@param oWS, objeto, webservice base
@param cDate, string, data referência para sincronizar.
@return array, [1] indica se obteve sucesso da operação, [2] vazio ou string de erro
/*/
//-----------------------------------------------------------------------------------
Static Function DoSyncV1( oWS, cDate )

	Local nI         := 0
	Local aMethodsV1 := {}
	Local aMethods   := { "sEquipment", "sFamily", "sCostCenter", "sArea", "sService", "sProduct", "sThirdPart", "sTool", "sLocation" }

	If !lDBOrderOk
		Return { .F., STR0149 } //"Os campos de usuário para ordens de serviço não estão configurados."
	EndIf

	//--------------------------------------------------------------------
	//modifica a estrutura do o array para enviar data para cada entidade
	//--------------------------------------------------------------------
	For nI := 1 to Len( aMethods )
		aAdd( aMethodsV1, { aMethods[ nI ], cDate, "" } )
	Next nI

	//------------------------------------------------
	// gera o pacote tar.gz de acordo com aMethodsV1
	//------------------------------------------------
	aReturn := CreateTarGz( oWS, aMethodsV1 )

Return aReturn

//----------------------------------------------------------------------------------
/*/{Protheus.doc} DoSyncV3
Envia dados via chuncked

@author Maria Elisandra de Paula
@since 20/09/2022
@param oWS, objeto, webservice base
@param cLastSync, string, data da última sincronização
@return array, [1] indica se obteve sucesso da operação, [2] vazio ou string de erro
/*/
//-----------------------------------------------------------------------------------
Static Function DoSyncV3( oWS, cLastSync )

	Local nI        := 0
	Local aResult   := {}
	Local cError    := ValidSync( )
	Local aRequest  := {}
	Local aEntities := {}
	Local lFirst    := .T.

	If !Empty( cError )
		Return { .F., cError }
	EndIf

	aRequest  := fHeaderArr(oWs,'entities')
	aEntities := fEntities()

	oWs:SetHeader( 'Transfer-Encoding','chunked' )
	oWs:SetHeader( 'Accept-Encoding','gzip' )
	oWs:SetResponse( '{"tables":[' )

	For nI := 1 to len(aRequest)

		cEntity := 's' + aRequest[nI]

		If aScan(aEntities, {|x| upper(x) == upper(cEntity) }) > 0

			If !lFirst
				oWs:SetResponse( ',' )
			Else
				lFirst := .F.
			EndIf

			aResult := &(cEntity)( oWs, cLastSync )

		EndIf

	Next nI

	oWs:SetResponse( ']}' )
	oWs:SetResponse('')
	oWs:SetStatus(200)

Return { .T., cError }

//---------------------------------------------------------------------
/*/{Protheus.doc} CreateTarGz
Inicia a sincronização e a construção de pacotes de todos os métodos.
Ao final, comprime-os e envia headers para forçar o download

@author Marcelo Camargo
@since 07/2016
@param oWS, objeto, webservice base
@param aMethods, array, nome das funções a serem executadas e data para parâmetro
@return array, [1] indica se obteve sucesso da operação, [2] vazio ou string de erro
/*/
//---------------------------------------------------------------------
Static Function CreateTarGz( oWS, aMethods )

	Local nI        := 0
	Local aGenFiles := { }
	Local aResult   := {}
	Local cSession  := GenFileName( 'session', .T. )
	Local cMsg      := IIf( aMethods[ 1, 2 ] == '0', 'completo', 'parcial' )

	//Funções jogadas para variaveis conforme explicação da função verifyFunction
	Local cTarCompress := "TarCompress"
	Local cGZCompress  := "GZCompress"
	Local aReturn      := { .T. , ""}

	printf( "-------------------------------------------------------------------" )
	printf( "Emp.: " + cEmpAnt + "   Fil.:" + cFilAnt  )
	printf( "Inicio geracao de pacote " + cMsg + " por " + UsrRetName( cUserLog )  )
	printf( 'DataBase: ' + Upper(AllTrim(TcGetDB())) + ' / Application Server em ' + IIf( isSRVunix(), 'Linux', 'Windows' ) + ;
		IIf( lPeMntNg, ' / Possui PE ', '/ Nao possui PE' ) )
	printf( "-------------------------------------------------------------------" )
	GCSync()

	For nI := 1 To Len( aMethods )

		aResult := &( aMethods[ nI,1 ] )( oWs, aMethods[ nI, 2 ] )

		If !aResult[ 1 ]
			printf( "Erro ao sincronizar " + aMethods[ nI ][ 1 ] +  ": " + aResult[ 2 ] )
			Return { .F., STR0124 + " " + aMethods[ nI ][ 1 ] +  ": " + aResult[ 2 ] } // "Erro ao sincronizar"
		EndIf

		//-------------------------------------------------------------
		// quando for data "0" não enviar os arquivos delete
		// quando for sRequestOrders não enviar os arquivos delete
		//-------------------------------------------------------------
		If aMethods[ nI, 2 ] <> "0" .And. aMethods[ nI,1 ] <> "sRequestOrders"
			aAdd( aGenFiles, aResult[ 2, 1 ] )
		EndIf

		aAdd( aGenFiles, aResult[ 2, 2 ] )
	Next nI

	&cTarCompress.(aGenFiles,cSession + ".tar")
	&cGZCompress.(cSession + ".tar",cSession + ".tar.gz")
	fDownload(oWS,cSession + ".tar.gz","sync.tar.gz")

	// Após o download, tentamos limpar os próprios vestígios
	For nI := 1 To Len( aGenFiles )
		FErase( aGenFiles[ nI ] )
	Next nI

	FErase( cSession + ".tar" )
	FErase( cSession + ".tar.gz" )

	GCSync()

	printf( "-------------------------------------------------------------------" )
	printf("Fim geracao de pacotes por " + UsrRetName( cUserLog ) )
	printf( "-------------------------------------------------------------------" )

Return aReturn

//---------------------------------------------------------------------
/*/{Protheus.doc} GenFileName
Obtém o nome a ser usado para criação do buffer para armazenar os dados
de sincronização

@author Marcelo Camargo
@since 07/2016
@param cSalt, string, nome base do método a sincronizar
@param [lUnique], boolean, determina se somente um nome dinâmico será dado como saída
@return Array, [1]nome do arquivo delete
               [2]nome do arquivo update
/*/
//---------------------------------------------------------------------
Static Function GenFileName( cSalt, lUnique )

	Local cThreadId := AllTrim( Str( ThreadId() ) )
	Local cUUID := AllTrim( Str( Randomize( 0, 1000000 ) ) ) + ;
		AllTrim( Str( Randomize( 0, 1000000 ) ) )
	Local cFileBase := cCurDir + "tmp" + cBarra + cThreadId + cBarra + cSalt + "_" + cThreadId + cUUID + "_"

	Default lUnique := .F.

	If !ExistDir( cCurDir + "tmp" )
		MakeDir( cCurDir + "tmp" )
	EndIf

	If !ExistDir( cCurDir + "tmp" + cBarra + cThreadId )
		MakeDir( cCurDir + "tmp" + cBarra + cThreadId)
	EndIf

	If lUnique
		Return cFileBase
	EndIf

Return { cFileBase + "delete.json", cFileBase + "update.json" }

/**
 * Modelo de entidade (empresa + filial) e funcionário para autenticação no
 * Protheus.
 **/
Class MntEntity
	Data EnterpriseCode As Character
	Data EnterpriseName As Character
	Data BranchCode As Character
	Data BranchName As Character
	Data WorkerCode As Character
	Data WorkerName As Character
	Data Localization As Character
	Data FailureControl As Logical
	Data UseTask As Logical
	Data ObligatoryChecklist As Logical
	Data Speciality As Character
	Data Unity As Character
	Data ExecutorCode As Character
	Data ExecutorName As Character
	Data RequesterName As Character
	Data RequesterCode As Character
	Data MultipleOrders As Character
	Data Facilities As Character
	Data SurveyRequest As Character
	Data PreventiveForRequest As Character
	Data Specialties As array
	Data IsValidForRequest As Logical
	Data isValidForOrder As Logical
	Data customTimeOut As Character
	Data Permissions As array
	Data LastAccess As Character
	Data Cnpj As Character
	Data CompanyName As Character
	Data Email As Character
	Data Release As Character

	Method New() Constructor
EndClass

Method New() Class MntEntity

	::ExecutorCode   := ""
	::ExecutorName   := ""
	::RequesterName  := ""
	::RequesterCode  := ""
	::MultipleOrders := ""
	::Facilities     := ""
	::SurveyRequest  := ""
	::Specialties    := {}
	::Permissions    := {}
	::Cnpj           := ""
	::CompanyName    := ""
	::Email          := ""

Return Self

Class Branches
	Data EnterpriseCode As Character
	Data EnterpriseName As Character
	Data BranchCode As Character
	Data BranchName As Character
	Data Localization As Character

	Method New() Constructor

EndClass

Method New() Class Branches

	::EnterpriseCode := ''
	::EnterpriseName := ''
	::BranchCode     := ''
	::BranchName     := ''
	::Localization   := ''
	
Return Self

/**
 * Modelo de anexo de ordem de serviço
 **/
Class MntOrderAttachment
	Data Id As Character
	Data Type As Character
	Data Date As Character
	Data FileName As Character
	Data Path As Character
	Data IsOwner As Logical
	Method New() Constructor
EndClass

Method New( cId ) Class MntOrderAttachment
	::Id := cId
	::IsOwner := .T.
Return Self

//---------------------------------------------------------------------
/*/{Protheus.doc} MultiBranchLogin
Retorna filiais (ação do botão Listar filiais)

@author Marcelo Camargo
@param  oSelf, objeto, instância do webservice
@since  24/01/2018
@return logic, se obteve sucesso no login
/*/
//---------------------------------------------------------------------
Static Function MultiBranchLogin( oSelf )

	Local aInfoUser   := {}
	Local aInfoLogin  := {}
	Local cJsonResp   := ''
	Local aBranches   := {}
	Local cName       := ''

	//--------------------------------
	//Recupera informações do usuário
	//--------------------------------
	aInfoLogin := GetInfoLogin( oSelf )

	If !aInfoLogin[1]
		SetRestFault( 403, EncodeUtf8(aInfoLogin[2] ) )
		Return .F.
	Else
		aBranches := aInfoLogin[2]
		aInfoUser := aInfoLogin[3]
	EndIf

	cName := NGEscape( aInfoUser[ 1, 4 ])

	Printf("Iniciando thread filiais")
	cJsonResp := StartJob( 'MNTNBRNCHS', GetEnvserver(), .T.,;
				aBranches, { lPortalOrigin, lOrderPermission,;
				lRequestPermission, lDBOrderOk, lDBRequestOk, aPermissions } )

	Printf("Finalizando thread filiais  ")

	oSelf:SetStatus( 200 )
	oSelf:SetResponse( FwhttpEncode( cJsonResp ))

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fPreLogin
Validações de login

@author Maria Elisandra de Paula
@param  oSelf, objeto, instância do webservice
@since  18/04/2022
@return boolean, se obteve sucesso
/*/
//---------------------------------------------------------------------
Static Function fPreLogin(oSelf)

	Local cMsg   := cEmpAnt + "/" + cFilAnt
	Local cError := ""

	If ValType( oSelf:GetHeader( 'version' ) ) != 'C'
		cError += STR0147 + CRLF // "Requisição inválida"
	EndIf

	If !fVersion( oSelf:GetHeader( 'version' ) ) // Valida versão do App x Web Service
		cError += STR0080 + CRLF // O aplicativo está desatualizado. Atualize-o para a última versão disponível.
	EndIf

	Do Case
		Case !lDBOrderOk .And. !lDBRequestOk
			cError += cMsg + " " + STR0195  + CRLF //"não possui todos os campos de usuario."
		Case lOrderPermission .And. !lDBOrderOk
			cError += cMsg + " " + STR0193  + CRLF // "não possui todos os campos de usuario para ordem de servico."
		Case lRequestPermission .And. !lDBRequestOk
			cError += cMsg + " " + STR0194 // "não possui os campos de usuario para solicitações."
	End Case

Return cError

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTNBRNCHS
Job que retorna filiais válidas para o usuário

@author Maria Elisandra de Paula
@param aBranches, array, filiais para validação
@param aMainStatics, array, variáveis statics
@since  18/04/2022
@return string, json de filiais
/*/
//---------------------------------------------------------------------
Function MNTNBRNCHS( aBranches, aMainStatics )

	Local cJsonResp := ""

	lPortalOrigin      := aMainStatics[1]
	lOrderPermission   := aMainStatics[2]
	lRequestPermission := aMainStatics[3]
	lDBOrderOk         := aMainStatics[4]
	lDBRequestOk       := aMainStatics[5]
	aPermissions       := aMainStatics[6]

	cJsonResp := fBranches( aBranches )
	cJsonResp := FWJsonSerialize(cJsonResp , .F. )

Return cJsonResp

//---------------------------------------------------------------------
/*/{Protheus.doc} fInfoMINGL
Retorna informações de uma filial

@author Maria Elisandra de Paula
@param oSelf, objeto, instância do ws

@since 28/06/2022
@return boolean, se obteve sucesso
/*/
//---------------------------------------------------------------------
Static Function fInfoMINGL( oSelf )
	
	Local cAliasQry  := ''
	Local oEntity    := MntEntity():New()
	Local cUserEmail := Trim( UsrRetMail( cUserLog ))
	Local cError     := fPreLogin( oSelf )
	Local cJsonResp  := ''	
	Local nIndex	 := 0
	Local aPermiUser := {}
	Local cUltAcesso := ''
	Local aNg1Key    := {}

	If !Empty( cError )
		Return fRetError( cError, oSelf )
	EndIf

	oEntity:EnterpriseCode      := cEmpAnt
	oEntity:BranchCode          := cFilAnt
	oEntity:EnterpriseName      := Alltrim( FWGrpName( cEmpAnt ) )
	oEntity:BranchName          := FWFilName( cEmpAnt, cFilAnt )
	oEntity:Localization        := oEntity:EnterpriseName + ' / ' + oEntity:BranchName
	oEntity:FailureControl      := SuperGetMv( 'MV_NGTNDFL', .F., 'S' ) == 'S'
	oEntity:UseTask             := SuperGetMv( 'MV_NGTARGE', .F., '2' ) == '1'
	oEntity:ObligatoryChecklist := SuperGetMv( 'MV_NGETAEX', .F., '1' ) == '1'
	oEntity:Unity               := SuperGetMv( 'MV_NGUNIDT', .F., 'S' )
	oEntity:RequesterName       := NGEscape( UsrRetName( cUserLog ) )
	oEntity:RequesterCode       := cUserLog
	oEntity:MultipleOrders      := SuperGetMv( 'MV_NGMULOS', .F., 'S' ) == 'S'
	oEntity:Facilities          := SuperGetMv( 'MV_NG1FAC', .F., '2') == '1'
	oEntity:SurveyRequest       := SuperGetMv( 'MV_NGPSATI', .F., 'N') == 'S'
	oEntity:PreventiveForRequest := SuperGetMv( 'MV_NGSSPRE', .F., 'N') == 'S'
	oEntity:IsValidForRequest   := RequestIsOk()
	oEntity:isValidForOrder     := lDBOrderOk
	oEntity:Email               := cUserEmail
	oEntity:Release             := GetRPORelease()

	If !lMigrated
		Printf("migracao do portal: NAO")
	Else

		Printf("migracao do portal: REALIZADA")
		aPermiUser := fGetPermis()

		For nIndex := 1 to Len( aPermiUser )

			aAdd( oEntity:Permissions, aPermiUser[nIndex] )

		Next nIndex

		cUltAcesso := fLastAcces( .T. )

		If !Empty(cUltAcesso)
		
			oEntity:LastAccess := cUltAcesso

		EndIf

		aNg1Key := fGet1Key()
		oEntity:Cnpj := aNg1Key[2]
		oEntity:CompanyName := aNg1Key[3]

	EndIf

	cAliasQry := GetNextAlias()

	BeginSql Alias cAliasQry
		SELECT T1.T1_CODFUNC, T1.T1_CODUSU, T1.T1_NOME, T0.T0_NOME
		FROM %table:ST1% T1
		LEFT OUTER JOIN %table:ST2% T2 
			ON T2.T2_FILIAL = %xFilial:ST2%
			AND T2.T2_CODFUNC = T1.T1_CODFUNC
			AND T2.%NotDel%
		LEFT OUTER JOIN %table:ST0% T0
			ON T0.T0_FILIAL = %xFilial:ST0%
			AND T0.T0_ESPECIA = T2.T2_ESPECIA
			AND T0.%NotDel%
		WHERE T1.T1_FILIAL = %xFilial:ST1% 
			AND UPPER(T1.T1_EMAIL) = %exp:Upper( cUserEmail )%
			AND T1.%NotDel%
	EndSql

	//---------------------------------------------------------
	// Informações de vínculo com funcionário da manutenção
	//---------------------------------------------------------
	If !(( cAliasQry )->( EoF() ))
		oEntity:WorkerCode := ( cAliasQry )->T1_CODFUNC
		oEntity:WorkerName := AllTrim( Capital( ( cAliasQry )->T1_NOME ) )
		oEntity:Speciality := STR0011 // "Sem especialidade"
		If !Empty( ( cAliasQry )->T0_NOME )
			oEntity:Speciality := AllTrim( Capital( ( cAliasQry )->T0_NOME ) )
		EndIf

		oEntity:Specialties := fSpecialties(( cAliasQry )->T1_CODFUNC)

	EndIf
	( cAliasQry )->( dbCloseArea() )

	//---------------------------------------------------------
	// Informações de vínculo com executante de solicitação
	//---------------------------------------------------------
	cAliasQry := GetNextAlias()
	BeginSql Alias cAliasQry
		SELECT TQ4_CDEXEC, TQ4_NMEXEC
		FROM %table:TQ4% TQ4
		WHERE TQ4.TQ4_FILIAL = %xFilial:TQ4%
			AND UPPER(TQ4.TQ4_EMAIL1) = %exp:Upper( cUserEmail )%
			AND TQ4.%NotDel%
	EndSql

	If !(( cAliasQry )->( EoF() ))
		oEntity:ExecutorCode := Alltrim(( cAliasQry )->TQ4_CDEXEC)
		oEntity:ExecutorName := AllTrim( Capital( ( cAliasQry )->TQ4_NMEXEC ) )
	EndIf
	( cAliasQry )->( dbCloseArea() )


	cJsonResp := JsonResult( FWJsonSerialize( { oEntity }, .F. ) )

	fLastAcces()

	oSelf:SetStatus( 200 )
	oSelf:SetResponse( FwhttpEncode( cJsonResp ) )

	Printf("infos da filial enviadas com sucesso")

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} OrderPics
Traz informações do banco de conhecimento sobre as imagens vinculadas a
uma ordem de serviço, incluindo se corresponde ao corpo da ordem ou à
finalização.

@author Marcelo Camargo
@since  11/01/2018
@param  cOrder, string, código da ordem de serviço
@param  oSelf, objeto, instância do webservice
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
Static Function OrderPics( cOrder, oSelf )

	Local cSolic    := ''
	Local aResponse := {}

	// Exige existência da ordem de serviço
	dbSelectArea( 'STJ' )
	dbSetOrder( 1 )
	If !dbSeek( FwxFilial( 'STJ' ) + cOrder )
		Return .F.
	EndIf

	cSolic := STJ->TJ_SOLICI

	aResponse := fListImg( cOrder, 'STJ' )

	If !Empty( cSolic )
		aResponse := fListImg( cSolic, 'TQB', aResponse, .F. )
	EndIf

	oSelf:SetStatus( 200 )
	oSelf:SetResponse( FWJsonSerialize( aResponse, .F. ) )

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fListImg
Retorna lista de imagens da SS ou OS

@author Maria Elisandra de Paula
@since 05/07/2022
@param cKey, string, chave para buscar entidade
@param cTable, string, tabela de ss ou os
@param aListiIni, array, lista inicial
@param lIsOwner, boolean, utilizado para o app identificar se a imagem 
pertence à entidade solicitada pois uma OS pode apresentar uma imagem de uma SS
@return array, lista de imagens em objeto 
/*/
//---------------------------------------------------------------------
Static Function fListImg( cKey, cTable, aListIni, lIsOwner )

	Local cFilEnt   := FwxFilial( cTable )
	Local cAliasQry := GetNextAlias()
	Local aResponse := {}
	Local oAttachment
	Local cCodEnt   := '% ( AC9.AC9_CODENT = ' + ValtoSql(cKey) + ;
	IIf(cTable == 'TQB', ' OR AC9.AC9_CODENT = ' + ValtoSql( FwxFilial('TQB') +cKey ) , '') + ')%'  // em alguns casos foi gravado chave com filial

	Default aListIni := {}
	Default lIsOwner := .T.

	aResponse := aListIni

	BeginSql Alias cAliasQry
		SELECT ACB.ACB_CODOBJ, ACB.ACB_OBJETO, ACB.ACB_DESCRI
		FROM %table:AC9% AC9
		INNER JOIN %table:ACB% ACB
			ON ACB.ACB_FILIAL = %xFilial:ACB%
			AND ACB.ACB_CODOBJ = AC9.AC9_CODOBJ
		WHERE AC9.AC9_FILIAL = %xFilial:AC9%
			AND AC9.AC9_ENTIDA = %exp:cTable%
			AND AC9.AC9_FILENT = %exp:cFilEnt%
			AND %exp:cCodEnt%
			AND AC9.%NotDel%
			AND ACB.%NotDel%
			AND RTRIM(SUBSTRING(ACB.ACB_DESCRI, 1, 8)) IN ('PROBLEM', 'SOLUTION', 'SIGNATUR')
	EndSql

	While !(( cAliasQry )->( EoF() ))

		oAttachment := MntOrderAttachment():New( ( cAliasQry )->ACB_CODOBJ )
		oAttachment:Type     := AllTrim( Lower( SubStr( ( cAliasQry )->ACB_DESCRI, 1, 8 ) ) )
		oAttachment:Date     := AllTrim( SubStr( ( cAliasQry )->ACB_DESCRI, 9 ) )
		oAttachment:FileName := AllTrim( ( cAliasQry )->ACB_OBJETO )
		oAttachment:Path     := '/picture/' + oAttachment:FileName
		oAttachment:IsOwner  := lIsOwner
		aAdd( aResponse, oAttachment )

		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )
Return aResponse

//---------------------------------------------------------------------
/*/{Protheus.doc} PicFromRepo
Recebe o objeto em formato Base64 e retorna a imagem corresponde a ele
do banco de conhecimento

@author Marcelo Camargo
@since  12/01/2018
@param  cObject, string, código do objeto gravado na ACB
@param  oSelf, objeto, instância do webservice
@return logic, se obteve sucesso
/*/
//---------------------------------------------------------------------
Static Function PicFromRepo( cObject, oSelf )

	Local cMsDocPath := If(isSRVunix(), Lower(StrTran( MsDocPath(),'\', '/')),MsDocPath())
	Local cFilePath  := cMsDocPath + cBarra + cObject
	If File( cFilePath )
		fImage( oSelf, cFilePath )
	ElseIf File( cFilePath + '.jpg' )
		// Fallback para extensão implícita
		fImage( oSelf, cFilePath + '.jpg' )
	Else
		Return .F.
	EndIf
Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} WorkerPic
Retorna a imagem do funcionário na ST1

@author	Larissa Thaís de Farias
@since 02/2016
@param oSelf, objeto, objeto do WS
@return logic, se obteve sucesso
/*/
//---------------------------------------------------------------------
Static Function fWorkerPic( oSelf )

	Local lRet      := .T.
	Local cBitmap   := ''
	Local cFilePath := ''

	dbSelectArea('ST1')
	dbSetOrder(6)
	If MsSeek( FwxFilial('ST1') + cUserLog ) .And. !Empty( ST1->T1_BITMAP )
		
		cBitmap := ST1->T1_BITMAP
		cFilePath := fPathBC( 'w' + cBitmap )

		lRet := ExtractBitmap( cBitmap, cFilePath ) .And. fImage( oSelf, cFilePath )
		
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} QFault
Query para irregularidades

@autor Maria Elisandra de Paula
@since 10/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de irregularidades
/*/
//---------------------------------------------------------------------
Static Function QFault( oWs, cDate, cOrigin )

	Local lBlock := NGCADICBASE("TP7_MSBLQL","A","TP7",.F.)
	Local cQuery := "SELECT TP7.TP7_CODIRE, TP7.TP7_NOME, "

	cQuery += fCaseDel('TP7')

	If lBlock
		cQuery += " CASE WHEN TP7.TP7_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
	Else
		cQuery += " '' AS BLOCKED "
	EndIf

	cQuery += " FROM " + RetSQLName('TP7') + " TP7 "
	cQuery += " WHERE TP7.TP7_FILIAL = " + ValToSql( FwxFilial("TP7") )

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "TP7_USERGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "TP7_USERGI" ) + " >= " + ValtoSql( cDate ) + ")"
	Else
		cQuery += " AND TP7.D_E_L_E_T_ = ' '"
	EndIf

	If lBlock
		cQuery += " AND TP7.TP7_MSBLQL <> '1' "
	EndIf

	cQuery := ChangeQuery(cQuery)

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sFault
Gera um JSON contendo as informações de Irregularidades para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sFault( oWs, cDate )

	Local cDelete   := ''
	Local lFirst    := .T.
	Local lFirstD   := .T.
    Local nCount    := 0
    Local cHrIn     := Time()
	Local cSubJSON  := ""
	Local cQuery    := QFault( oWs, cDate, "sFault" )
	Local cAliasQry := GeraTemp( cQuery, 'Fault' )
	Local nDelete   := 0
	Local nUpdate   := 0
	Local aFileName := {}
	Local cEntity   := 'fault'
	Local aInit     := fInitWrite(oWs, cEntity)
	
	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If fCondDel(cAliasQry)
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{"code":"' + NGEscape( ( cAliasQry )->TP7_CODIRE ) + '",'
			cSubJSON += '"name":"' + NGEscape( ( cAliasQry )->TP7_NOME ) + '"}'

			fWriteJson(cSubJSON, nUpdate, oWs)

		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + NGEscape( ( cAliasQry )->TP7_CODIRE ) + '"'

		EndIf

		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QEquipment
Query para equipamentos

@autor Maria Elisandra de Paula
@since 04/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de equipamentos
/*/
//---------------------------------------------------------------------
Static Function QEquipment( oWs, cDate, cOrigin )

	Local cQuery    := "SELECT ST9.T9_CODBEM "
	Local lFieldTaf := NGCADICBASE( 'TAF_USERGI', 'A', 'TAF', .F. ) .And. NGCADICBASE( 'TAF_USERGA', 'A', 'TAF', .F. )
	Local lBlock    := NGCADICBASE("T9_MSBLQL","A","ST9",.F.)

	If cOrigin == "sEquipment"

		cQuery += ", ST9.T9_NOME, ST9.T9_CCUSTO, ST9.T9_BARCODE, T9_LOCAL, " + IIf( !lPortalOrigin .And. fHasPerms('occurrences'), ' ST9.T9_CODFAMI, ', '' )
		//Busca data e hora do último apontamento de contador
		cQuery += cIsNull + "((SELECT MAX(TP_DTLEITU || '' || TP_HORA) "
		cQuery += "   FROM " + RetSQLName('STP') + " STP "
		cQuery += "   WHERE TP_FILIAL =  " + ValToSql(FwxFilial("STP"))
		cQuery += "     AND TP_CODBEM = ST9.T9_CODBEM "
		cQuery += "		AND STP.D_E_L_E_T_ = ' ' ) , '')  AS DTHRCOUNT , "

		//Busca data e hora do último apontamento do SEGUNDO contador
		cQuery += cIsNull + "((SELECT MAX(TPP_DTLEIT || '' || TPP_HORA) "
        cQuery += "   FROM " + RetSQLName('TPP') + " TPP "
        cQuery += "   WHERE TPP_FILIAL =  " + ValToSql(FwxFilial("TPP"))
		cQuery += "     AND TPP_CODBEM = ST9.T9_CODBEM " 
		cQuery += " 	AND TPP.D_E_L_E_T_ = ' ' ), '') AS DTHRCOUNT2 , "

		cQuery += cIsNull + "(CTT_DESC01,'') AS CCNAME,"
		cQuery += cIsNull + "(HB_NOME,'') AS CTNAME,"
		cQuery += cIsNull + "(TPE_TPCONT,'') TPE_TPCONT,"
		cQuery += cIsNull + "(TPE_POSCON,0) TPE_POSCON,"
		cQuery += cIsNull + "(TPE_LIMICO,0) TPE_LIMICO,"
		cQuery += cIsNull + "(T9_POSCONT,0 ) T9_POSCONT,"
		cQuery += cIsNull + "(T9_TPCONTA,'') T9_TPCONTA,"
		cQuery += cIsNull + "(T9_DTULTAC,'') T9_DTULTAC,"
		cQuery += cIsNull + "(T9_LIMICON,0)  T9_LIMICON,"
		cQuery += " T9_TEMCONT,"
		cQuery += " T9_CENTRAB,"
		cQuery += " ST9.T9_ESTRUTU,"

		cQuery += fCaseDel('ST9')

		cQuery += "CASE "
		cQuery += 	"WHEN ST9.T9_BITMAP = ' ' THEN 'FALSE' "
		cQuery += "ELSE "
		cQuery += 	"'TRUE' "
		cQuery += "END AS HASIMAGE,"

		If lBlock
			cQuery += " CASE WHEN ST9.T9_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
		Else
			cQuery += "'' AS BLOCKED "
		EndIf

	EndIf

	cQuery += " FROM " + RetSQLName( 'ST9' ) + " ST9 "
	cQuery += " INNER JOIN " + RetSQLName( 'CTT' ) + " CTT "
	cQuery += "    ON CTT_FILIAL = " + ValToSql( FwxFilial( "CTT" ) )
	cQuery += "		AND CTT_CUSTO = T9_CCUSTO "

	cQuery += fWhereCtt( oWs )
	cQuery += " AND CTT.D_E_L_E_T_ = ' ' "

	cQuery += " LEFT JOIN " + RetSQLName( 'SHB' ) + " SHB "
	cQuery += "		ON HB_FILIAL = " + ValToSql( FwxFilial( "SHB" ) )
	cQuery += "		AND HB_COD = T9_CENTRAB "
	cQuery += "     AND SHB.D_E_L_E_T_ = ' ' "

	cQuery += "	LEFT JOIN " + RetSQLName('TPE') + " TPE"
	cQuery += "		ON TPE_FILIAL = " + ValToSql(FwxFilial("TPE"))
	cQuery += "    	AND TPE_CODBEM = T9_CODBEM"
	cQuery += "     AND TPE.D_E_L_E_T_ = ' ' "

	cQuery += "  INNER JOIN " + RetSQLName('ST6') + " ST6  "
	cQuery += " 	ON ST6.T6_FILIAL = " + ValtoSql( FwxFilial("ST6") )
	cQuery += " 	AND  ST6.T6_CODFAMI = ST9.T9_CODFAMI "

	cQuery += fWhereSt6( oWs )
	cQuery += " AND ST6.D_E_L_E_T_ = ' '"

	If lMigrated

		// trecho que verifica as areas(STD) que não devem ser enviadas
		cQuery += " LEFT JOIN "+ RetSQLName('HP3') + " HP3_CTT "
		cQuery += "  ON  HP3_CTT.HP3_FILIAL = " + ValToSQL( FWxFilial( "HP3" ) )
		cQuery += "  AND HP3_CTT.HP3_FILORI = CTT.CTT_FILIAL "
		cQuery += "  AND HP3_CTT.HP3_CODGRP = " + ValToSQL( cUserGrp )
		cQuery += "  AND HP3_CTT.HP3_TABLE  = 'CTT' "
		cQuery += "  AND HP3_CTT.HP3_CODE   = CTT.CTT_CUSTO"
		cQuery += "  AND HP3_CTT.D_E_L_E_T_ = ' '"

		cQuery += " LEFT JOIN "+ RetSQLName('HP3') + " HP3_ST6 "
		cQuery += "  ON  HP3_ST6.HP3_FILIAL = " + ValToSQL( FWxFilial( "HP3" ) )
		cQuery += "  AND HP3_ST6.HP3_FILORI = ST6.T6_FILIAL "
		cQuery += "  AND HP3_ST6.HP3_CODGRP = " + ValToSQL( cUserGrp )
		cQuery += "  AND HP3_ST6.HP3_TABLE  = 'ST6' "
		cQuery += "  AND HP3_ST6.HP3_CODE   = ST6.T6_CODFAMI"
		cQuery += "  AND HP3_ST6.D_E_L_E_T_ = ' '"

	EndIf

	cQuery += " WHERE ST9.T9_FILIAL = " + ValtoSql( FwxFilial('ST9') )

	// trecho que corresponde às condições left join da tabela HP3 logo acima
	If lMigrated
		cQuery += " AND HP3_CTT.HP3_CODE IS NULL "
		cQuery += " AND HP3_ST6.HP3_CODE IS NULL "
	EndIf

	cQuery += fWhereSt9( oWs )

	If cDate != "0"

		cQuery += " AND (" + dateQuery( "T9_USERLGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "T9_USERLGI" ) + " >= " + ValtoSql( cDate )

		//------------------------------------------------
		// verifica se houve alteração na taf do bem
		//------------------------------------------------
		If lFieldTaf
        	cQuery += " OR EXISTS( "
            cQuery += " SELECT 1 "
			cQuery += " FROM " + RetSQLName( 'TAF' ) + " TAF "
			cQuery += " WHERE TAF.TAF_FILIAL = " + ValToSql( FwxFilial( 'TAF') )
			cQuery += "     AND TAF.TAF_CODCON = ST9.T9_CODBEM "
			cQuery += "     AND TAF.TAF_INDCON = '1' "
			cQuery += "     AND TAF.TAF_MODMNT = 'X' "
			cQuery += "     AND (" + dateQuery( "TAF_USERGA" ) + " >= " + ValtoSql( cDate )
			cQuery += "         OR " + dateQuery( "TAF_USERGI" ) + " >= " + ValtoSql( cDate ) + " ) )"
		EndIf

		cQuery += " ) "

	Else
		cQuery += " AND ST9.D_E_L_E_T_ = ' '"
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sEquipment
Gera um JSON contendo as informações de Equipamento para a sincronização
com o aplicativo Mobile

Filtros:
equipamento
família
centro de custo

@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sEquipment( oWS, cDate )

	Local cDelete     := ''
	Local aFileName   := {}
	Local cLocTree    := ""
	Local lFirst      := .T.
	Local lFirstD     := .T.
    Local nCount      := 0
    Local cHrIn       := Time()
	Local nDelete     := 0
	Local nUpdate     := 0	
	Local cSubJSON    := ""
	Local lOcurrences := !lPortalOrigin .And. fHasPerms('occurrences')
	Local lDbMSSQL    := "MSSQL" $ Upper(AllTrim(TcGetDB()))
	Local cQuery      := ChangeQuery( QEquipment( oWS, cDate, "sEquipment" ) )
	Local cAliasQry   := GeraTemp( cQuery, 'Equipment' )
	Local cEntity     := 'equipment'
	Local aInit       := fInitWrite(oWs, cEntity)

	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf
	
	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If fCondDel(cAliasQry)
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"' + NGEscape( (cAliasQry)->T9_CODBEM ) + '",'
			cSubJSON += '"name":"' + NGEscape( (cAliasQry)->T9_NOME ) + '",'
			cSubJSON += '"costCenterCode":"' + NGEscape( (cAliasQry)->T9_CCUSTO ) + '",'
			cSubJSON += '"costCenterName":"' + NGEscape( (cAliasQry)->CCNAME ) + '",'
			cSubJSON += '"barCode":"'        + NGEscape( (cAliasQry)->T9_BARCODE ) + '",'
			cSubJSON += '"workCenterName":"' + NGEscape( (cAliasQry)->CTNAME ) + '",'
			cSubJSON += '"workCenterCode":"' + NGEscape( (cAliasQry)->T9_CENTRAB ) + '",'

			If lOcurrences
				cSubJSON += '"familyCode":"' + NGEscape( (cAliasQry)->T9_CODFAMI ) + '",'
			EndIf

			// Caso o equipamento possua imagem vinculada ao seu cadastro, envia a flag hasImage.
			If Alltrim( (cAliasQry)->HASIMAGE ) == 'TRUE'
				cSubJSON += '"hasImage":true,'
			EndIf

			If (cAliasQry)->BLOCKED == "TRUE"
				cSubJSON += '"blocked":true,'
			EndIf

			cLocTree := ""

			// Ponto de entrada para buscar localização por customização do cliente
			If lPeMntNg
				cLocTree := ExecBlock("MNTNG",.F.,.F.,{"DESCRIPTION_LOCALIZATION",oWS, (cAliasQry)->T9_CODBEM })
			EndIf

			//---------------------------------------------------------
			// Busca localização do bem
			//---------------------------------------------------------
			If Empty( cLocTree )
				If lDbMSSQL
					cLocTree := Localization( (cAliasQry)->T9_CODBEM )
				Else
					cLocTree := NGLocComp( (cAliasQry)->T9_CODBEM, '1' )
				EndIf

				If Empty( cLocTree ) .or. AllTrim( cLocTree )  == Alltrim( (cAliasQry)->T9_CODBEM )
					cLocTree := AllTrim( (cAliasQry)->T9_LOCAL )
				EndIf

			EndIf

			cSubJSON += '"localization":"' + NGEscape( cLocTree ) + '"'

			// Caso tenha contador irá criar mais um vetor para armazenar os dados de contador
			If (cAliasQry)->T9_TEMCONT == "S"
				cSubJSON += ',"counter":[{'
	      		cSubJSON += '"name":"'    + NGEscape((cAliasQry)->T9_TPCONTA)   + '",'
				cSubJSON += '"value":'    + cValtoChar((cAliasQry)->T9_POSCONT) + ','
				cSubJSON += '"limit":'    + Substr(cValtoChar((cAliasQry)->T9_LIMICON), 0,9) + ','
				cSubJSON += '"datetime":"'+ NGEscape((cAliasQry)->DTHRCOUNT) + '"}'

	      		//caso tenha segundo contador
	      		If (cAliasQry)->TPE_POSCON > 0
		      		cSubJSON += ',{"name":"'    + NGEscape((cAliasQry)->TPE_TPCONT)   + '",'
					cSubJSON += '"value":'    + cValtoChar((cAliasQry)->TPE_POSCON) + ','
					cSubJSON += '"limit":'    + Substr(cValtoChar((cAliasQry)->TPE_LIMICO),0,9) + ','
					cSubJSON += '"datetime":"'+ NGEscape((cAliasQry)->DTHRCOUNT2) + '"}'
				EndIf

				cSubJSON += ']'

			// Caso possua controle de contador definido pelo pai imediato ou da estrutura.
			ElseIf (cAliasQry)->T9_TEMCONT $ 'P#I' .And. (cAliasQry)->T9_ESTRUTU == 'S'

				// Envia neste chave o número de contadores que controlam o equipamento.
				cSubJSON += ',"finishOrderCounters":' + cValToChar( IIf( (cAliasQry)->TPE_POSCON > 0, 2, 1 ) )

			EndIf

			cSubJSON += '}'

			fWriteJson(cSubJSON, nUpdate, oWs)

		Else

			// Itens a excluir
			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + NGEscape( (cAliasQry)->T9_CODBEM ) + '"'

		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QLocation
Query para localizações (TAF).
@type function

@autor Wexlei Silveira
@since 17/12/2020

@param oWS    , objeto  , Referência ao webservice
@param cDate  , caracter, Data da última sincronização

@return string, Query de localizações
/*/
//---------------------------------------------------------------------
Static Function QLocation( oWs, cDate )

	Local aLocation  := IIf( ValType( oWS:GetHeader( 'location' ) ) == 'C', StrTokArr( oWS:GetHeader( 'location' ) , '|'), {} )
	Local lBlock     := NGCADICBASE( 'TAF_MSBLQL', 'A', 'TAF', .F. )

	Local cQuery     := "SELECT TAF_CODNIV "


	cQuery += ", TAF_NOMNIV, TAF_NIVSUP, TAF_CCUSTO, TAF_CENTRA, "
	cQuery += cIsNull + "(CTT_DESC01,'') AS CCNAME," // Descrição do Centro de Custo
	cQuery += cIsNull + "(HB_NOME,'') CTNAME,"       // Descrição do Centro de Trabalho

	cQuery += fCaseDel('TAF')

	// Campo padrão de bloqueio (MSBLQL)
	If lBlock
		cQuery += " TAF.TAF_MSBLQL AS BLOCKED "
	Else
		cQuery += " '' AS BLOCKED "
	EndIf

	cQuery += "  FROM " + RetSQLName( 'TAF' ) + " TAF "

	// Join com Centro de Custo
	cQuery += "  LEFT JOIN " + RetSQLName( 'CTT' ) + " CTT "
	cQuery += "		ON CTT.CTT_FILIAL = " + ValToSql( FwxFilial("CTT") )
	cQuery += "   	AND CTT.CTT_CUSTO = TAF.TAF_CCUSTO "
	cQuery += "		AND CTT.D_E_L_E_T_ = ' ' "

	// Join com Centro de Trabalho
	cQuery += "  LEFT JOIN " + RetSQLName( 'SHB' ) + " SHB "
	cQuery += "		ON SHB.HB_FILIAL = " + ValToSql( FwxFilial( "SHB" ) )
	cQuery += "		AND SHB.HB_COD = TAF.TAF_CENTRA "
	cQuery += "		AND SHB.D_E_L_E_T_ = ' ' "


	cQuery += " WHERE TAF.TAF_FILIAL = " + ValToSql( FwxFilial('TAF') )
	cQuery += "   AND TAF.TAF_MODMNT = 'X'" // Somente itens do MNT
	cQuery += "   AND TAF.TAF_INDCON = '2'" // Somente Localização

	cQuery += makeFilter( aLocation, "TAF.TAF_CODNIV" )

	// Filtro por Centro de Custo
	cQuery += " AND ( TAF.TAF_CCUSTO = ' ' OR TAF.TAF_CCUSTO = CTT.CTT_CUSTO )

	If cDate <> "0"
		// Filtro por Data da Última Alteração
		cQuery += " AND ("    + dateQuery( "TAF_USERGA" ) + " >= " + ValtoSql( cDate )
		cQuery += "      OR " + dateQuery( "TAF_USERGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		// Filtro por registros deletados
		// Caso cDate seja '0', deve-se apenas sincronizar registros não deletados
		cQuery += " AND TAF.D_E_L_E_T_ = ' ' "
	EndIf

	// Filtro de registros bloqueados para o Portal Mobile
	// Apenas registro ativos devem ser enviados
	If lPortalOrigin .And. lBlock
		cQuery += " AND TAF.TAF_MSBLQL = '2' "
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sLocation
Gera um JSON contendo as informações de Localizações para a sincronização
com o aplicativo Mobile.

@author	Wexlei Silveira
@since 17/12/2020

@param oWS  , objeto  , Referência ao webservice
@param cDate, caracter, Data da última sincronização

@return array, [1]   Indica se obteve sucesso na operação,
               [2,1] Nome do arquivo de delete,
			   [2,2] Nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sLocation( oWS, cDate )

	Local cDelete   := ''
	Local aFileName := {}	
	Local cAliasQry := GetNextAlias()
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local cHrIn     := Time()
	Local nDelete   := 0
	Local nUpdate   := 0
    Local nCount    := 0
	Local cFullPath := ''
	Local cSubJSON  := ''
	Local lDbMSSQL  := 'MSSQL' $ Upper(AllTrim(TcGetDB())) // Ambientes com SGBD MSSQL
	Local cQuery    := ChangeQuery( QLocation( oWS, cDate ) )
	Local cEntity   := 'location'
	Local aInit     := fInitWrite(oWs, cEntity)

	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf

	dbUseArea( .T., 'TOPCONN', TCGenQry( Nil, Nil, cQuery ), cAliasQry, .T., .T. )

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If fCondDel(cAliasQry)

			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"'   + NGEscape( (cAliasQry)->TAF_CODNIV ) + '",'
			cSubJSON += '"name":"'   + NGEscape( (cAliasQry)->TAF_NOMNIV ) + '",'
			cSubJSON += '"parent":"' + NGEscape( (cAliasQry)->TAF_NIVSUP ) + '",'

			If !Empty( (cAliasQry)->TAF_CCUSTO )
				cSubJSON += '"costCenterCode":"' + NGEscape( (cAliasQry)->TAF_CCUSTO ) + '",'
				cSubJSON += '"costCenterName":"' + NGEscape( (cAliasQry)->CCNAME ) + '",'
			EndIf

			If !Empty( (cAliasQry)->TAF_CENTRA )
				cSubJSON += '"workCenterCode":"' + NGEscape( (cAliasQry)->TAF_CENTRA ) + '",'
				cSubJSON += '"workCenterName":"' + NGEscape( (cAliasQry)->CTNAME ) + '",'
			EndIf

			If (cAliasQry)->BLOCKED == '1'
				cSubJSON += '"blocked":true,'
			EndIf

			//---------------------------------------------------------
			// Busca descrição da hierarquia da localização
			//---------------------------------------------------------
			If lDbMSSQL
				cFullPath := Localization( (cAliasQry)->TAF_CODNIV, '2' )
			Else
				cFullPath := NGLocComp( (cAliasQry)->TAF_CODNIV, '2' )
			EndIf

			cSubJSON += '"path":"' + NGEscape( cFullPath ) + '"'

			cSubJSON += '}'

			fWriteJson(cSubJSON, nUpdate, oWs)

		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + NGEscape( (cAliasQry)->TAF_CODNIV ) + '"'

		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QService
Query para serviços

@autor Maria Elisandra de Paula
@since 04/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de serviços
/*/
//---------------------------------------------------------------------
Static Function QService( oWs, cDate, cOrigin )

	Local aType    := If(ValType(oWS:GetHeader( 'type' )) == "C", StrTokArr( oWS:GetHeader( 'type' ) , "|"), {})
	Local lBlock   := NGCADICBASE("T4_MSBLQL","A","ST4",.F.)
	Local cQuery   := "SELECT ST4.T4_SERVICO "

	If cOrigin == "sService"

		cQuery += ",ST4.T4_NOME, "
		cQuery += "CASE WHEN STE.TE_CARACTE = 'P' THEN 'P' Else 'C' END AS TYPE, "
		cQuery += fCaseDel('ST4')

		If lBlock
			cQuery += " CASE WHEN ST4.T4_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
		Else
			cQuery += "'' AS BLOCKED "
		EndIf

	EndIf

	cQuery += "FROM " + RetSQLName('ST4') + " ST4 "

	cQuery += "INNER JOIN " + RetSQLName('STE') + " STE "
	cQuery += "    ON STE.TE_FILIAL = " + ValToSql( FwxFilial('STE') )
	cQuery += "    AND STE.TE_TIPOMAN = ST4.T4_TIPOMAN"
	cQuery += "    AND STE.D_E_L_E_T_= ' ' "

	//TODO
	/*
		filtro de tipo de manutenção para entidade/json de  serviço
		Neste trecho é tratado os filtros vindos do portal, lá o cliente tem apenas 2 opções: Preventiva ou corretiva

		caso o cliente não tenha migrado: vai funcionar normal
		caso já tenha migrado: tratar por permissões/grupo do usuário (ver as permissões relacionadas a corretiva e preventiva)

		possível solução:

			Olhar na HP2 por grupo

			conversar com o taina

	*/

	cQuery += makeFilter( aType, 'STE.TE_CARACTE' )
		
	cQuery += "INNER JOIN " + RetSQLName('STD') + " STD "
	cQuery += "    ON STD.TD_FILIAL = " + ValToSQL( FwxFilial("STD") )
	cQuery += "    AND STD.TD_CODAREA = ST4.T4_CODAREA"
	cQuery += "    AND STD.D_E_L_E_T_ = ' ' "
	cQuery += fWhereStD( oWs )

	If lMigrated

		// trecho que verifica as areas(STD) que não devem ser enviadas
		cQuery += " LEFT JOIN "+ RetSQLName('HP3') + " HP3_STD "
		cQuery += "  ON  HP3_STD.HP3_FILIAL = " + ValToSQL( FWxFilial( "HP3" ) )
		cQuery += "  AND HP3_STD.HP3_FILORI = STD.TD_FILIAL "
		cQuery += "  AND HP3_STD.HP3_CODGRP = " + ValToSQL( cUserGrp )
		cQuery += "  AND HP3_STD.HP3_TABLE  = 'STD' "
		cQuery += "  AND HP3_STD.HP3_CODE   = STD.TD_CODAREA"
		cQuery += "  AND HP3_STD.D_E_L_E_T_ = ' '"

		// trecho que verifica os serviços(ST4) que não devem ser enviados
		cQuery += " LEFT JOIN "+ RetSQLName('HP3') + " HP3_ST4 "
		cQuery += "  ON  HP3_ST4.HP3_FILIAL = " + ValToSQL( FWxFilial( "HP3" ) )
		cQuery += "  AND HP3_ST4.HP3_FILORI = ST4.T4_FILIAL "
		cQuery += "  AND HP3_ST4.HP3_CODGRP = " + ValToSQL( cUserGrp )
		cQuery += "  AND HP3_ST4.HP3_TABLE  = 'ST4' "
		cQuery += "  AND HP3_ST4.HP3_CODE   = ST4.T4_SERVICO"
		cQuery += "  AND HP3_ST4.D_E_L_E_T_ = ' '"

	EndIf

	cQuery += " WHERE ST4.T4_FILIAL = " + ValToSql( FwxFilial("ST4") )
	cQuery += fWhereSt4( oWs )

	// trecho que corresponde às condições left join da tabela HP3 logo acima
	If lMigrated
		cQuery += " AND HP3_STD.HP3_CODE IS NULL " 
		cQuery += " AND HP3_ST4.HP3_CODE IS NULL "
	EndIf

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "T4_USERLGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "T4_USERLGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND ST4.D_E_L_E_T_ = ' ' "
	EndIf

	If lPortalOrigin .And. lBlock
		cQuery += " AND ST4.T4_MSBLQL <> '1' "
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sService
Gera um JSON contendo as informações de Serviço para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sService( oWS, cDate )

	Local cDelete   := ''
	Local aFileName := {}
	Local lFirst    := .T.
	Local lFirstD   := .T.
    Local nCount    := 0
    Local cHrIn     := Time()
	Local nDelete   := 0
	Local nUpdate   := 0	
	Local cSubJSON  := ""
	Local cQuery    := ChangeQuery( QService( oWS, cDate, "sService" ) )
	Local cAliasQry := GeraTemp( cQuery, 'Service' )
	Local cEntity   := 'service'
	Local aInit     := fInitWrite(oWs, cEntity)

	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If fCondDel(cAliasQry)
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"' + NGEscape((cAliasQry)->T4_SERVICO) + '",'
			cSubJSON += '"name":"' + NGEscape((cAliasQry)->T4_NOME) + '",'

			If (cAliasQry)->BLOCKED == "TRUE"
				cSubJSON += '"blocked":true,'
			EndIf

			cSubJSON += '"type":"' + NGEscape((cAliasQry)->TYPE) + '"'
			cSubJSON += '}'

			fWriteJson(cSubJSON, nUpdate, oWs)

		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + NGEscape( (cAliasQry)->T4_SERVICO ) + '"'
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QMaintenance
Query para manutenção

@autor Maria Elisandra de Paula
@since 17/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de manutenção
/*/
//---------------------------------------------------------------------
Static Function QMaintenance( oWs, cDate, cOrigin )

	Local cQuery     := ""

	If cOrigin == "sMaintenance"
		cQuery := " SELECT STF.TF_CODBEM, STF.TF_SERVICO, STF.TF_SEQRELA, STF.TF_NOMEMAN, "
		cQuery += fCaseDel('STF',.T.)
		cQuery += " FROM " + RetSQLName('STF') + " STF "
	EndIf

	cQuery += " INNER JOIN " + RetSQLName('ST4') + " ST4 "
	cQuery += "    ON ST4.T4_FILIAL = " + ValToSql( FwxFilial("ST4") )
	cQuery += " 	AND ST4.T4_SERVICO = STF.TF_SERVICO "
	cQuery += fWhereSt4( oWs )
	cQuery += " AND ST4.D_E_L_E_T_ = ' ' "

	cQuery += " INNER JOIN " + RetSQLName('ST9') + " ST9 "
	cQuery += " 	ON ST9.T9_FILIAL = " + ValtoSql( FwxFilial('ST9') )
	cQuery += "		AND STF.TF_CODBEM = ST9.T9_CODBEM "
	cQuery += fWhereSt9( oWs )
	cQuery += " AND ST9.D_E_L_E_T_ = ' '"

	cQuery += "INNER JOIN " + RetSQLName('STD') + " STD "
	cQuery += "    ON STD.TD_FILIAL = " + ValToSQL( FwxFilial("STD") )
	cQuery += "    AND STD.TD_CODAREA = ST4.T4_CODAREA"
	cQuery += "    AND STD.D_E_L_E_T_ = ' ' "
	cQuery += fWhereStD( oWs )

	If lMigrated

		// trecho que verifica os Serviços (ST4) que não devem ser enviadas
		cQuery += " LEFT JOIN "+ RetSQLName('HP3') + " HP3_ST4 "
		cQuery += "  ON  HP3_ST4.HP3_FILIAL = " + ValToSQL( FWxFilial( "HP3" ) )
		cQuery += "  AND HP3_ST4.HP3_FILORI = ST4.T4_FILIAL "
		cQuery += "  AND HP3_ST4.HP3_CODGRP = " + ValToSQL( cUserGrp )
		cQuery += "  AND HP3_ST4.HP3_TABLE  = 'ST4' "
		cQuery += "  AND HP3_ST4.HP3_CODE   = ST4.T4_SERVICO"
		cQuery += "  AND HP3_ST4.D_E_L_E_T_ = ' '"

		// trecho que verifica as areas(STD) que não devem ser enviadas
		cQuery += " LEFT JOIN "+ RetSQLName('HP3') + " HP3_STD "
		cQuery += "  ON  HP3_STD.HP3_FILIAL = " + ValToSQL( FWxFilial( "HP3" ) )
		cQuery += "  AND HP3_STD.HP3_FILORI = STD.TD_FILIAL "
		cQuery += "  AND HP3_STD.HP3_CODGRP = " + ValToSQL( cUserGrp )
		cQuery += "  AND HP3_STD.HP3_TABLE  = 'STD' "
		cQuery += "  AND HP3_STD.HP3_CODE   = STD.TD_CODAREA"
		cQuery += "  AND HP3_STD.D_E_L_E_T_ = ' '"

		//JOIN da Família do Bem
		cQuery += " INNER JOIN " + RetSQLName('ST6') + " ST6 "
		cQuery += " 	ON  ST6.T6_FILIAL  = " + ValtoSql( FwxFilial('ST6') )
		cQuery += "		AND ST6.T6_CODFAMI = ST9.T9_CODFAMI "
		cQuery += " 	AND ST6.D_E_L_E_T_ = ' '"

		//JOIN da Migração
		cQuery += " LEFT JOIN "+ RetSQLName('HP3') + " HP3_ST6 "
		cQuery += "  ON  HP3_ST6.HP3_FILIAL = " + ValToSQL( FWxFilial( "HP3" ) )
		cQuery += "  AND HP3_ST6.HP3_FILORI = ST6.T6_FILIAL "
		cQuery += "  AND HP3_ST6.HP3_CODGRP = " + ValToSQL( cUserGrp )
		cQuery += "  AND HP3_ST6.HP3_TABLE  = 'ST6' "
		cQuery += "  AND HP3_ST6.HP3_CODE   = ST6.T6_CODFAMI"
		cQuery += "  AND HP3_ST6.D_E_L_E_T_ = ' '"
		
	EndIf

	cQuery += " WHERE STF.TF_FILIAL = " + ValtoSql( FwxFilial("STF") )
	cQuery += " AND STF.TF_ATIVO <> 'N' "

	// trecho que corresponde às condições left join da tabela HP3 logo acima
	If lMigrated
		cQuery += " AND HP3_ST4.HP3_CODE IS NULL "
		cQuery += " AND HP3_ST6.HP3_CODE IS NULL "
		cQuery += " AND HP3_STD.HP3_CODE IS NULL "
	EndIf

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "TF_USERLGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "TF_USERLGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND STF.D_E_L_E_T_ = ' '"
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sMaintenance
Gera um JSON contendo as informações de Manutenção para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 02/2016
@param oWs - Objeto com referência ao webservice
@param cDate - Data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sMaintenance( oWs, cDate )

	Local cDelete   := ''
	Local aFileName := {}
	Local cEquip
	Local cServ
	Local cSeq
	Local lFirst    := .T.
	Local lFirstD   := .T.
    Local nCount    := 0
    Local cHrIn     := Time()
	Local nDelete   := 0
	Local nUpdate   := 0	
	Local cSubJSON  := ""
	Local cQuery    := ChangeQuery( QMaintenance( oWs, cDate, "sMaintenance" ) )
	Local cAliasQry := GeraTemp( cQuery, 'Maintenance' )
	Local cEntity   := 'maintenance'
	Local aInit     := fInitWrite(oWs, cEntity)

	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If fCondDel(cAliasQry)
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cEquip := AllTrim( (cAliasQry)->TF_CODBEM )
			cServ  := AllTrim( (cAliasQry)->TF_SERVICO )
			cSeq   := AllTrim( (cAliasQry)->TF_SEQRELA )

			cSubJSON += '{'
			cSubJSON += '"equipment":"' + NGEscape( (cAliasQry)->TF_CODBEM ) + '",'
			cSubJSON += '"service":"' + NGEscape( (cAliasQry)->TF_SERVICO ) + '",'
			cSubJSON += '"sequence":"' + NGEscape( (cAliasQry)->TF_SEQRELA ) + '",'
			cSubJSON += '"name":"' + NGEscape( (cAliasQry)->TF_NOMEMAN ) + '"'
			cSubJSON += '}'

			fWriteJson(cSubJSON, nUpdate, oWs)

		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + NGEscape((cAliasQry)->TF_CODBEM ) + ;
						'+' + NGEscape((cAliasQry)->TF_SERVICO) +;
						'+' + TF_SEQRELA + '"'

		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )
	
	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QProduct
Query para produtos

@autor Maria Elisandra de Paula
@since 03/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de produto
/*/
//---------------------------------------------------------------------
Static Function QProduct( oWs, cDate, cOrigin )

	Local cQuery := "SELECT DISTINCT SB1.B1_COD "
	Local lBlock := NGCADICBASE("B1_MSBLQL","A","SB1",.F.)

	If cOrigin == "sProduct"

		cQuery += ", SB1.B1_DESC, SB1.B1_UM, SB1.B1_LOCPAD, SB1.B1_RASTRO, SB1.B1_LOCALIZ, "
		cQuery += "CASE "

		cQuery += "WHEN SB1.D_E_L_E_T_ = ' ' THEN ' ' "
		cQuery += "Else 'true' "
		cQuery += "END AS IS_DELETED,"

		If lBlock
			cQuery += " CASE WHEN SB1.B1_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
		Else
			cQuery += " '' AS BLOCKED "
		EndIf
	EndIf

	cQuery += " FROM " + RetSQLName('SB1') + " SB1 "

	If lMigrated

		// trecho que verifica os produtos(SB1/SBM) que não devem ser enviadas
		cQuery += " LEFT JOIN "+ RetSQLName('HP3') + " HP3_SB1 "
		cQuery += "  ON  HP3_SB1.HP3_FILIAL = " + ValToSQL( FWxFilial( "HP3" ) )
		cQuery += "  AND HP3_SB1.HP3_FILORI = SB1.B1_FILIAL "
		cQuery += "  AND HP3_SB1.HP3_CODGRP = " + ValToSQL( cUserGrp )
		cQuery += "  AND HP3_SB1.HP3_TABLE  = 'SBM' "
		cQuery += "  AND HP3_SB1.HP3_CODE   = SB1.B1_GRUPO"
		cQuery += "  AND HP3_SB1.D_E_L_E_T_ = ' '"
		
	EndIf

	cQuery += " WHERE SB1.B1_FILIAL = " + ValtoSql( FwxFilial("SB1") )

	// trecho que corresponde às condições left join da tabela HP3 logo acima
	If lMigrated
		cQuery += " AND HP3_SB1.HP3_CODE IS NULL "
	EndIf

	cQuery += fWhereSb1( oWs )

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "B1_USERLGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "B1_USERLGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND SB1.D_E_L_E_T_ = ' ' "
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sProduct
Gera um JSON contendo as informações de Produto para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sProduct( oWS, cDate )

	Local cDelete   := ''
	Local aFileName := {}
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local nDelete   := 0
	Local nUpdate   := 0	
	Local cSubJSON  := ""
	Local lUsaLote  := SuperGetMV("MV_RASTRO",.F.,'N') == "S"
	Local lUsaLocal := SuperGetMV("MV_LOCALIZ") == "S"
	Local cQuery    := ChangeQuery( QProduct( oWS, cDate, "sProduct" ) )
	Local cAliasQry := GeraTemp( cQuery, 'Product' )
	Local cEntity   := 'product'
	Local aInit     := fInitWrite(oWs, cEntity)

	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())
		If fCondDel(cAliasQry)
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"' + NGEscape( (cAliasQry)->B1_COD ) + '",'
			cSubJSON += '"name":"' + NGEscape( (cAliasQry)->B1_DESC ) + '",'
			cSubJSON += '"unity":"' + NGEscape( (cAliasQry)->B1_UM ) + '",'

			//Controle de rastro: 'L':controla somente Lote,'S':controla lote e sub-lote
			If lUsaLote .And. (cAliasQry)->B1_RASTRO $ "SL"
				cSubJSON += '"tracking":"' + (cAliasQry)->B1_RASTRO + '",'
			EndIf

			//Controle de localização: sim ou não
			If lUsaLocal .And. (cAliasQry)->B1_LOCALIZ == "S"
				cSubJSON += '"addressing":true,'
			EndIf

			If (cAliasQry)->BLOCKED == "TRUE"
				cSubJSON += '"blocked":true,'
			EndIf

			cSubJSON += '"warehouse":"' + NGEscape( (cAliasQry)->B1_LOCPAD ) + '"'
			cSubJSON += '}'

			fWriteJson(cSubJSON, nUpdate, oWs)

		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + NGEscape( (cAliasQry)->B1_COD ) + '"'

		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QWarehouse
Query para local de produto

@autor Maria Elisandra de Paula
@since 10/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de locais
/*/
//---------------------------------------------------------------------
Static Function QWarehouse( oWs, cDate, cOrigin )

	Local cFilter := ''
	Local cQuery  := " SELECT SB2.B2_LOCAL, SB2.B2_COD, "

	cQuery += fCaseDel('SB2',.T.)
	cQuery += "	FROM " + RetSQLName('SB2') + " SB2 "
	cQuery += "	INNER JOIN " + RetSQLName('SB1') + " SB1 " 
	cQuery += "		ON SB1.B1_FILIAL = " + ValtoSql( FwxFilial("SB1") ) 
	cQuery += "		AND SB2.B2_COD = SB1.B1_COD "

	If lMigrated

		// trecho que verifica os produtos(SB1/SBM) que não devem ser enviadas
		cQuery += " LEFT JOIN "+ RetSQLName('HP3') + " HP3_SB1 "
		cQuery += "  ON  HP3_SB1.HP3_FILIAL = " + ValToSQL( FWxFilial( "HP3" ) )
		cQuery += "  AND HP3_SB1.HP3_FILORI = SB1.B1_FILIAL "
		cQuery += "  AND HP3_SB1.HP3_CODGRP = " + ValToSQL( cUserGrp )
		cQuery += "  AND HP3_SB1.HP3_TABLE  = 'SBM' "
		cQuery += "  AND HP3_SB1.HP3_CODE   = SB1.B1_GRUPO"
		cQuery += "  AND HP3_SB1.D_E_L_E_T_ = ' '"

	EndIf

	cQuery += fWhereSb1( oWs )
	cQuery += " 	AND SB1.D_E_L_E_T_ = ' ' "

	cQuery += "	WHERE SB2.B2_FILIAL = " + ValtoSql( FwxFilial("SB2") )

	// trecho que corresponde às condições left join da tabela HP3 logo acima
	If lMigrated
		cQuery += " AND HP3_SB1.HP3_CODE IS NULL "
	EndIf

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "B2_USERLGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "B2_USERLGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND SB2.D_E_L_E_T_ = ' '"
	EndIf

	If lPeMntNg
		cFilter := ExecBlock("MNTNG",.F.,.F.,{"FILTER_WAREHOUSE",oWS})
		If !Empty(cFilter)
			cQuery += cFilter
		EndIf
	EndIf

	cQuery := ChangeQuery(cQuery)

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sWarehouse
Gera um JSON contendo as informações de Almoxarifado para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sWarehouse( oWs, cDate )

	Local cDelete   := ''
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local cSubJSON  := ""
	Local cQuery    := QWarehouse( oWs, cDate, "sWarehouse" )
	Local cAliasQry := GeraTemp( cQuery, 'Warehouse' )
	Local nDelete   := 0
	Local nUpdate   := 0
	Local aFileName := {}	
	Local cEntity   := 'warehouse'
	Local aInit     := fInitWrite(oWs, cEntity)

	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())
		If fCondDel(cAliasQry)
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"' + NGEscape( (cAliasQry)->B2_LOCAL ) + '",'
			cSubJSON += '"product":"' + NGEscape( (cAliasQry)->B2_COD ) + '"'
			cSubJSON += '}'
			
			fWriteJson(cSubJSON, nUpdate, oWs)

		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + NGEscape( (cAliasQry)->B2_LOCAL ) + "+" + NGEscape( (cAliasQry)->B2_COD ) + '"'

		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QCostCenter
Query para centro de custo

@autor Maria Elisandra de Paula
@since 10/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de centro de custo
/*/
//---------------------------------------------------------------------
Static Function QCostCenter( oWs, cDate, cOrigin )

	Local lBlock := NGCADICBASE("CTT_MSBLQL","A","CTT",.F.)
	Local cQuery := ''

	cQuery := "SELECT CTT.CTT_CUSTO "

	If cOrigin == "sCostCenter"

		cQuery += " , CTT.CTT_DESC01, CTT.CTT_LOCAL, "
		cQuery += fCaseDel('CTT')

		If lBlock
			cQuery += " CASE WHEN CTT.CTT_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
		Else
			cQuery += "'' AS BLOCKED "
		EndIf

	EndIf

	cQuery += "FROM " + RetSQLName('CTT') + " CTT "

	If lMigrated

		// trecho que verifica as areas(STD) que não devem ser enviadas
		cQuery += " LEFT JOIN "+ RetSQLName('HP3') + " HP3_CTT "
		cQuery += "  ON  HP3_CTT.HP3_FILIAL = " + ValToSQL( FWxFilial( "HP3" ) )
		cQuery += "  AND HP3_CTT.HP3_FILORI = CTT.CTT_FILIAL "
		cQuery += "  AND HP3_CTT.HP3_CODGRP = " + ValToSQL( cUserGrp )
		cQuery += "  AND HP3_CTT.HP3_TABLE  = 'CTT' "
		cQuery += "  AND HP3_CTT.HP3_CODE   = CTT.CTT_CUSTO"
		cQuery += "  AND HP3_CTT.D_E_L_E_T_ = ' '"
		
	EndIf

	cQuery += " WHERE CTT.CTT_FILIAL = " + ValtoSql( FwxFilial("CTT") )

	// trecho que corresponde às condições left join da tabela HP3 logo acima
	If lMigrated
		cQuery += " AND HP3_CTT.HP3_CODE IS NULL "
	EndIf

	cQuery += fWhereCtt( oWs )

	If cDate != "0"
		cQuery += " AND (" + dateQuery( "CTT_USERGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "CTT_USERGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND CTT.D_E_L_E_T_ = ' '"
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sCostCenter
Gera um JSON contendo as informações de Centro de Custo para a sincronização
com o aplicativo Mobile

Filtro:
Centro de custo

@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sCostCenter( oWs, cDate )

	Local cDelete   := ''
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local cSubJSON  := ""
	Local cQuery    := ChangeQuery( QCostCenter( oWs, cDate, "sCostCenter" ) )
	Local cAliasQry := GeraTemp( cQuery, 'CostCenter' )
	Local nDelete   := 0
	Local nUpdate   := 0
	Local aFileName := {}	
	Local cEntity   := 'costcenter'
	Local aInit     := fInitWrite(oWs, cEntity)

	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())
		If fCondDel(cAliasQry)
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"' + NGEscape( (cAliasQry)->CTT_CUSTO ) + '",'

			If (cAliasQry)->BLOCKED == "TRUE"
				cSubJSON += '"blocked":true,'
			EndIf

			cSubJSON += '"name":"' + NGEscape( (cAliasQry)->CTT_DESC01 ) + '",'
			cSubJSON += '"warehouse":"' + NGEscape( (cAliasQry)->CTT_LOCAL ) + '"'
			cSubJSON += '}'

			fWriteJson(cSubJSON, nUpdate, oWs)

		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + NGEscape( (cAliasQry)->CTT_CUSTO ) + '"'

		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )
	
	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QFamily
Query para família de bens

@autor Maria Elisandra de Paula
@since 10/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de família
/*/
//---------------------------------------------------------------------
Static Function QFamily( oWs, cDate, cOrigin )

	Local lBlock  := NGCADICBASE("T6_MSBLQL","A","ST6",.F.)
	Local cQuery  := "SELECT ST6.T6_CODFAMI "

	If cOrigin == "sFamily"
		cQuery += " , ST6.T6_NOME, "
		cQuery += fCaseDel('ST6')

		If lBlock
			cQuery += " CASE WHEN ST6.T6_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
		Else
			cQuery += "'' AS BLOCKED "
		EndIf

	EndIf

	cQuery += "FROM " + RetSQLName('ST6') + " ST6 "
	cQuery += " WHERE ST6.T6_FILIAL = " + ValtoSql( FwxFilial("ST6") )

	cQuery += fWhereSt6( oWs )

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "T6_USERLGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "T6_USERLGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND ST6.D_E_L_E_T_ = ' '"
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sFamily
Gera um JSON contendo as informações de Família para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 12/05/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sFamily( oWs, cDate )

	Local cDelete   := ''
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local cSubJSON  := ""
	Local cQuery    := ChangeQuery( QFamily( oWs, cDate, "sFamily" ) )
	Local cAliasQry := GeraTemp( cQuery, 'Family' )
	Local nDelete   := 0
	Local nUpdate   := 0
	Local aFileName := {}	
	Local cEntity   := 'family'
	Local aInit     := fInitWrite(oWs, cEntity)

	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If fCondDel(cAliasQry)
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"' + NGEscape( (cAliasQry)->T6_CODFAMI ) + '",'
			cSubJSON += '"name":"' + NGEscape( (cAliasQry)->T6_NOME ) + '"'
			cSubJSON += '}'

			fWriteJson(cSubJSON, nUpdate, oWs)

		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + NGEscape( (cAliasQry)->T6_CODFAMI ) + '"'

		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QWorker
Query para funcionários da manutenção

@autor Maria Elisandra de Paula
@since 06/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de funcionário da manutenção
/*/
//---------------------------------------------------------------------
Static Function QWorker( oWs, cDate, cOrigin )

	Local lBlock := NGCADICBASE("T1_MSBLQL","A","ST1",.F.)
	Local cQuery := "SELECT ST1.T1_CODFUNC "

	If cOrigin == "sWorker"

		cQuery += " , ST1.T1_NOME, "

		cQuery += " CASE "
		cQuery += "    WHEN ST1.T1_DISPONI = 'N' THEN 'true' "
		cQuery += "    WHEN ST1.D_E_L_E_T_ = '*' THEN 'true' "
		cQuery += " ELSE ' ' "
		cQuery += " END AS IS_DELETED, "

		If lBlock
			cQuery += " CASE WHEN ST1.T1_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
		Else
			cQuery += "'' AS BLOCKED "
		EndIf
	EndIf

	cQuery += " FROM " + RetSQLName('ST1') + " ST1 "
	cQuery += " WHERE T1_FILIAL = " + ValtoSql( FwxFilial("ST1") )

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "T1_USERLGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "T1_USERLGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND ST1.T1_DISPONI = 'S' "
		cQuery += " AND ST1.D_E_L_E_T_ = ' '"
	EndIf

	cQuery := ChangeQuery(cQuery)

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sWorker
Gera um JSON contendo as informações de Funcionários para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sWorker( oWs, cDate )

	Local cDelete   := ''
	Local cSpeciality := ""
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local cSubJSON  := ""
	Local cQuery    := QWorker( oWs, cDate, "sWorker" )
	Local cAliasQry := GeraTemp( cQuery, 'Worker' )
	Local nDelete   := 0
	Local nUpdate   := 0
	Local aFileName := {}	
	Local cEntity   := 'worker'
	Local aInit     := fInitWrite(oWs, cEntity)

	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If fCondDel(cAliasQry)
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			dbSelectArea("ST2")
			dbSetOrder(1)
			If dbSeek(FwxFilial("ST2")+(cAliasQry)->T1_CODFUNC)
				cSpeciality := NGEscape( ST2->T2_ESPECIA )
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"' +  NGEscape( (cAliasQry)->T1_CODFUNC ) + '",'
			cSubJSON += '"name":"' + NGEscape( (cAliasQry)->T1_NOME ) + '",'

			If (cAliasQry)->BLOCKED == "TRUE"
				cSubJSON += '"blocked":true,'
			EndIf

			cSubJSON += '"speciality":"' + cSpeciality + '"'
			cSubJSON += '}'

			fWriteJson(cSubJSON, nUpdate, oWs)

			cSpeciality := ""
			dbSelectArea(cAliasQry)
		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + NGEscape( (cAliasQry)->T1_CODFUNC ) + '"'
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QThirdPart
Query para terceiros

@autor Maria Elisandra de Paula
@since 06/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de terceiros
/*/
//---------------------------------------------------------------------
Static Function QThirdPart( oWs, cDate, cOrigin )

	Local lBlock  := NGCADICBASE("A2_MSBLQL","A","SA2",.F.)
	Local cQuery  := "SELECT SA2.A2_COD"

	If cOrigin == "sThirdPart"

		cQuery += ", SA2.A2_NOME, SA2.A2_LOJA, "
		cQuery += fCaseDel('SA2')

		If lBlock
			cQuery += " CASE WHEN SA2.A2_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
		Else
			cQuery += " '' AS BLOCKED "
		EndIf
	EndIf

	cQuery += "FROM " + RetSQLName('SA2') + " SA2 "

	If lMigrated

		// trecho que verifica os clientes/terceiros (SA2) que não devem ser enviadas
		cQuery += " LEFT JOIN "+ RetSQLName('HP3') + " HP3_SA2 "
		cQuery += "  ON  HP3_SA2.HP3_FILIAL = " + ValToSQL( FWxFilial( "HP3" ) )
		cQuery += "  AND HP3_SA2.HP3_FILORI = SA2.A2_FILIAL "
		cQuery += "  AND HP3_SA2.HP3_CODGRP = " + ValToSQL( cUserGrp )
		cQuery += "  AND HP3_SA2.HP3_TABLE  = 'SA2' "
		cQuery += "  AND HP3_SA2.HP3_CODE   = SA2.A2_COD"
		cQuery += "  AND HP3_SA2.D_E_L_E_T_ = ' '"
		
	EndIf
	cQuery += "WHERE SA2.A2_FILIAL = " + ValtoSql( FwxFilial('SA2') )

	// trecho que corresponde às condições left join da tabela HP3 logo acima
	If lMigrated
		cQuery += " AND HP3_SA2.HP3_CODE IS NULL "
	EndIf
	cQuery += fWhereSa2( oWs )

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "A2_USERLGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "A2_USERLGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND SA2.D_E_L_E_T_ = ' ' "
	EndIf

	If lPortalOrigin .And. lBlock
		cQuery += " AND SA2.A2_MSBLQL <> '1' "
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sThirdPart
Gera um JSON contendo as informações de Terceiros para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sThirdPart( oWs, cDate )

	Local cDelete   := ''
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local cSubJSON  := ""
	Local cQuery    := QThirdPart( oWs, cDate, "sThirdPart" )
	Local cAliasQry := GeraTemp( cQuery, 'ThirdPart' )
	Local nDelete   := 0
	Local nUpdate   := 0
	Local aFileName := {}	
	Local cEntity   := 'thirdpart'
	Local aInit     := fInitWrite(oWs, cEntity)

	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If fCondDel(cAliasQry)
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"' +  NGEscape( (cAliasQry)->A2_COD ) + '",'
			cSubJSON += '"store":"' + NGEscape( (cAliasQry)->A2_LOJA ) + '",'

			If (cAliasQry)->BLOCKED == "TRUE"
				cSubJSON += '"blocked":true,'
			EndIf

			cSubJSON += '"name":"' + NGEscape( (cAliasQry)->A2_NOME ) + '"'
			cSubJSON += '}'

			fWriteJson(cSubJSON, nUpdate, oWs)

		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + NGEscape( (cAliasQry)->A2_COD ) + '+' + NGEscape( (cAliasQry)->A2_LOJA ) + '"'

		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QSpeciality
Query para especialidades

@autor Maria Elisandra de Paula
@since 06/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de especialidade
/*/
//---------------------------------------------------------------------
Static Function QSpeciality( oWs, cDate, cOrigin )

	Local lBlock := NGCADICBASE("T0_MSBLQL","A","ST0",.F.)
	Local cQuery := "SELECT ST0.T0_ESPECIA"

	If cOrigin == "sSpeciality"

		cQuery += " , ST0.T0_NOME, "
		cQuery += fCaseDel('ST0')

		If lBlock
			cQuery += " CASE WHEN ST0.T0_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
		Else
			cQuery += " '' AS BLOCKED "
		EndIf
	EndIf

	cQuery += "FROM " + RetSQLName('ST0') + " ST0 "
	cQuery += "WHERE ST0.T0_FILIAL = " + ValtoSql( FwxFilial("ST0") )

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "T0_USERLGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "T0_USERLGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND ST0.D_E_L_E_T_ = ' ' "
	EndIf

	cQuery := ChangeQuery(cQuery)

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sSpeciality
Gera um JSON contendo as informações de Especialidade para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sSpeciality( oWs, cDate )

	Local cDelete   := ''
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local cSubJSON  := ""
	Local cQuery    := QSpeciality( oWs, cDate, "sSpeciality" )
	Local cAliasQry := GeraTemp( cQuery, 'Speciality' )
	Local nDelete   := 0
	Local nUpdate   := 0
	Local aFileName := {}	
	Local cEntity   := 'speciality'
	Local aInit     := fInitWrite(oWs, cEntity)

	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If fCondDel(cAliasQry)
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"' + NGEscape( (cAliasQry)->T0_ESPECIA ) + '",'

			If (cAliasQry)->BLOCKED == "TRUE"
				cSubJSON += '"blocked":true,'
			EndIf

			cSubJSON += '"name":"' + NGEscape( (cAliasQry)->T0_NOME ) + '"'
			cSubJSON += '}'

			fWriteJson(cSubJSON, nUpdate, oWs)

		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + NGEscape( (cAliasQry)->T0_ESPECIA ) + '"'

		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QTool
Query para ferramentas

@autor Maria Elisandra de Paula
@since 06/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de ferramentas
/*/
//---------------------------------------------------------------------
Static Function QTool( oWs, cDate, cOrigin )

	Local lBlock  := NGCADICBASE("H4_MSBLQL","A","SH4",.F.)
	Local cQuery  := "SELECT SH4.H4_CODIGO "

	If cOrigin == "sTool"

		cQuery += ", SH4.H4_DESCRI, "
		cQuery += fCaseDel('SH4')

		If lBlock
			cQuery += "CASE WHEN SH4.H4_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
		Else
			cQuery += " '' AS BLOCKED "
		EndIf
	EndIf

	cQuery += "FROM " + RetSQLName('SH4') + " SH4 "

	If lMigrated

		// trecho que verifica os ferramentas (SH4) que não devem ser enviadas
		cQuery += " LEFT JOIN "+ RetSQLName('HP3') + " HP3_SH4 "
		cQuery += "  ON  HP3_SH4.HP3_FILIAL = " + ValToSQL( FWxFilial( "HP3" ) )
		cQuery += "  AND HP3_SH4.HP3_FILORI = SH4.H4_FILIAL "
		cQuery += "  AND HP3_SH4.HP3_CODGRP = " + ValToSQL( cUserGrp )
		cQuery += "  AND HP3_SH4.HP3_TABLE  = 'SH4' "
		cQuery += "  AND HP3_SH4.HP3_CODE   = SH4.H4_CODIGO"
		cQuery += "  AND HP3_SH4.D_E_L_E_T_ = ' '"
		
	EndIf

	cQuery += "WHERE SH4.H4_FILIAL = " + ValtoSql( FwxFilial("SH4") )

	// trecho que corresponde às condições left join da tabela HP3 logo acima
	If lMigrated
		cQuery += " AND HP3_SH4.HP3_CODE IS NULL "
	EndIf

	cQuery += fWhereSh4( oWs )

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "H4_USERLGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "H4_USERLGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND SH4.D_E_L_E_T_ = ' ' "
	EndIf

	If lPortalOrigin .And. lBlock
		cQuery += " AND SH4.H4_MSBLQL <> '1' "
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sTool
Gera um JSON contendo as informações de Ferramentas para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sTool( oWs, cDate )

	Local cDelete   := ''
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local cSubJSON  := ""
	Local cQuery    := QTool( oWs, cDate, "sTool" )
	Local cAliasQry := GeraTemp( cQuery, 'Tool' )
	Local nDelete   := 0
	Local nUpdate   := 0
	Local aFileName := {}	
	Local cEntity   := 'tool'
	Local aInit     := fInitWrite(oWs, cEntity)

	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If fCondDel(cAliasQry)
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"' + NGEscape( (cAliasQry)->H4_CODIGO ) + '",'

		If (cAliasQry)->BLOCKED == "TRUE"
			cSubJSON += '"blocked":true,'
		EndIf

			cSubJSON += '"name":"' + NGEscape( (cAliasQry)->H4_DESCRI ) + '"'
			cSubJSON += '}'

			fWriteJson(cSubJSON, nUpdate, oWs)

		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + NGEscape( (cAliasQry)->H4_CODIGO ) + '"'

		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QTask
Query para etapas Tarefas

@autor Maria Elisandra de Paula
@since 17/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de tarefas
/*/
//---------------------------------------------------------------------
Static Function QTask( oWs, cDate, cOrigin )

	Local lBlock := NGCADICBASE("TT9_MSBLQL","A","TT9",.F.)
	Local cQuery := "SELECT TT9.TT9_TAREFA "

	If cOrigin == "sTask"

		cQuery += " , TT9.TT9_DESCRI, "
		cQuery += fCaseDel('TT9')

		If lBlock
			cQuery += " CASE WHEN TT9.TT9_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
		Else
			cQuery += " '' AS BLOCKED "
		EndIf
	EndIf

	cQuery += "FROM " + RetSQLName('TT9') + " TT9 "
	cQuery += "WHERE TT9.TT9_FILIAL = " + ValtoSql( FwxFilial("TT9") )

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "TT9_USERGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "TT9_USERGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND TT9.D_E_L_E_T_ = ' '"
	EndIf

	cQuery := ChangeQuery( cQuery )

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sTask
Gera um JSON contendo as informações de Tarefas Genéricas para a sincronização
com o aplicativo Mobile

@obs Para tarefa genérica, habilitar parâmetro MV_NGTARGE
@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sTask( oWs, cDate )

	Local cDelete   := ''
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local cSubJSON  := ""
	Local cQuery    := QTask( oWs, cDate, "sTask" )
	Local cAliasQry := GeraTemp( cQuery, 'Task' )
	Local nDelete   := 0
	Local nUpdate   := 0
	Local aFileName := {}	
	Local cEntity   := 'task'
	Local aInit     := fInitWrite(oWs, cEntity)

	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If fCondDel(cAliasQry)
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"' + NGEscape( (cAliasQry)->TT9_TAREFA ) + '",'

			If (cAliasQry)->BLOCKED == "TRUE"
				cSubJSON += '"blocked":true,'
			EndIf

			cSubJSON += '"name":"' + NGEscape( (cAliasQry)->TT9_DESCRI ) + '"'
			cSubJSON += '}'

			fWriteJson(cSubJSON, nUpdate, oWs)

		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + NGEscape( (cAliasQry)->TT9_TAREFA ) + '"'
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	//------------------------------------------------------
	// Quando não utiliza tarefas genéricas envia tarefa '0'
	//------------------------------------------------------
	If cDate == '0' .And. SuperGetMv( 'MV_NGTARGE', .F., '2' ) != '1'
		cSubJSON := IIF( !lFirst, ',', '' ) + '{"code":"0","name":"' + EncodeUtf8( 'SEM ESPECIFICAÇÃO DE TAREFA' ) + '"}'

		fWriteJson(cSubJSON, nUpdate, oWs)

	EndIf

	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QPrevtask
Query para tarefas da manutenção

@autor Maria Elisandra de Paula
@since 17/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de tarefas da manutenção
/*/
//---------------------------------------------------------------------
Static Function QPrevtask( oWs, cDate, cOrigin )

	Local cQuery := "SELECT ST5.T5_TAREFA, ST5.T5_DESCRIC, ST5.T5_CODBEM, "

	cQuery += " ST5.T5_SERVICO, ST5.T5_SEQRELA, ST5.T5_SEQUENC,"
	cQuery += fCaseDel('ST5', .T.)
	cQuery += " FROM " + RetSQLName('ST5') + " ST5 "

	cQuery += " INNER JOIN " + RetSQLName('STF') + " STF " 
	cQuery += " 	ON TF_FILIAL = ST5.T5_FILIAL "
	cQuery += "		AND STF.TF_CODBEM = ST5.T5_CODBEM "
	cQuery += "		AND STF.TF_SERVICO = ST5.T5_SERVICO "
	cQuery += "		AND STF.TF_SEQRELA = ST5.T5_SEQRELA "
	cQuery += "		AND STF.TF_ATIVO = 'S' "

	cQuery += QMaintenance( oWS, cDate, '' )
	cQuery += " AND ST5.T5_FILIAL = " + ValtoSql( FwxFilial("ST5") )

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "T5_USERLGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "T5_USERLGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND ST5.D_E_L_E_T_ = ' '"
	EndIf

	cQuery += "ORDER BY ST5.T5_CODBEM, ST5.T5_SERVICO, ST5.T5_SEQRELA, ST5.T5_SEQUENC "
	cQuery := ChangeQuery( cQuery )

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sPrevTask
Gera um JSON contendo as informações de Tarefas Preventivas para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sPrevTask( oWs, cDate )

	Local cDelete   := ''
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local cSubJSON  := ""
	Local cQuery    := QPrevTask( oWs, cDate, "sPrevTask" )
	Local cAliasQry := GeraTemp( cQuery, 'PrevTask' )
	Local nDelete   := 0
	Local nUpdate   := 0
	Local aFileName := {}
	Local cEntity   := 'prevtask'
	Local aInit     := fInitWrite(oWs, cEntity)

	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If fCondDel(cAliasQry)
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"equipment":"' + NGEscape( (cAliasQry)->T5_CODBEM ) + '",'
			cSubJSON += '"service":"' + NGEscape( (cAliasQry)->T5_SERVICO ) + '",'
			cSubJSON += '"sequence":"' + NGEscape( (cAliasQry)->T5_SEQRELA ) + '",'
			cSubJSON += '"task":"' + NGEscape( (cAliasQry)->T5_TAREFA ) + '",'
			cSubJSON += '"description":"' + NGEscape( (cAliasQry)->T5_DESCRIC ) + '"'
			cSubJSON += '}'

			fWriteJson(cSubJSON, nUpdate, oWs)

		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + NGEscape( (cAliasQry)->T5_CODBEM ) + '+' + NGEscape( (cAliasQry)->T5_SERVICO ) + ;
						'+' +  NGEscape( (cAliasQry)->T5_SEQRELA ) + '+' + NGEscape( (cAliasQry)->T5_TAREFA ) + '"'

		EndIf

		nCount++
		( cAliasQry )->( dbSkip() )

	EndDo

	( cAliasQry )->( dbCloseArea() )

	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QArea
Query para area

@autor Maria Elisandra de Paula
@since 17/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de area da manutenção
/*/
//---------------------------------------------------------------------
Static Function QArea( oWs, cDate, cOrigin )

	Local lBlock  := NGCADICBASE("TD_MSBLQL","A","STD",.F.)
	Local cQuery  := "SELECT STD.TD_CODAREA "

	If cOrigin == "sArea"
		cQuery += " , STD.TD_NOME, "
		cQuery += fCaseDel('STD')

		If lBlock
			cQuery += " CASE WHEN STD.TD_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
		Else
			cQuery += " '' AS BLOCKED "
		EndIf

	EndIf

	cQuery += "FROM " + RetSQLName('STD') + " STD "
	cQuery += "WHERE STD.TD_FILIAL = " + ValtoSql( FwxFilial("STD") )

	cQuery += fWhereStD( oWs )

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "TD_USERLGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "TD_USERLGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND STD.D_E_L_E_T_ = ' '"
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sArea
Gera um JSON contendo as informações de Área para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 12/05/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sArea( oWs, cDate )

	Local cDelete   := ''
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local cSubJSON  := ""
	Local nCount    := 0
	Local cHrIn     := Time()
	Local cQuery    := ChangeQuery( QArea( oWs, cDate, "sArea" ) )
	Local cAliasQry := GeraTemp( cQuery, 'Area' )
	Local nDelete   := 0
	Local nUpdate   := 0
	Local aFileName := {}	
	Local cEntity   := 'area'
	Local aInit     := fInitWrite(oWs, cEntity)

	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If fCondDel(cAliasQry)
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"' + NGEscape((cAliasQry)->TD_CODAREA ) + '",'
			cSubJSON += '"name":"' + NGEscape((cAliasQry)->TD_NOME ) + '"'
			cSubJSON += '}'

			fWriteJson(cSubJSON, nUpdate, oWs)

		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + NGEscape( (cAliasQry)->TD_CODAREA ) + '"'

		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QChecklist
Query para etapas

@autor Maria Elisandra de Paula
@since 12/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de etapas
/*/
//---------------------------------------------------------------------
Static Function QChecklist( oWs, cDate, cOrigin )

	Local lBlock := NGCADICBASE("TPA_MSBLQL","A","TPA",.F.)
	Local cQuery := "SELECT TPA.TPA_ETAPA "

	If cOrigin == "sChecklist"

		cQuery += " , TPA.TPA_DESCRI, TPA_OPCOES, "
		cQuery += fCaseDel('TPA')

		If lBlock
			cQuery += " CASE WHEN TPA.TPA_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
		Else
			cQuery += " '' AS BLOCKED "
		EndIf
	EndIf

	cQuery += "FROM " + RetSQLName('TPA') + " TPA "
	cQuery += "WHERE TPA.TPA_FILIAL = " + ValtoSql( FwxFilial("TPA") )

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "TPA_USERGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "TPA_USERGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND TPA.D_E_L_E_T_ = ' '"
	EndIf

	cQuery := ChangeQuery( cQuery )

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sChecklist
Gera um JSON contendo as informações de Checklist para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sChecklist( oWs, cDate )

	Local cDelete   := ''
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local cSubJSON  := ""
	Local cQuery    := QChecklist( oWs, cDate, "sChecklist" )
	Local cAliasQry := GeraTemp( cQuery, 'Checklist' )
	Local nDelete   := 0
	Local nUpdate   := 0
	Local aFileName := {}	
	Local cEntity   := 'checklist'
	Local aInit     := fInitWrite(oWs, cEntity)

	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If fCondDel(cAliasQry)
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"' + NGEscape( (cAliasQry)->TPA_ETAPA ) + '",'

			If (cAliasQry)->BLOCKED == "TRUE"
				cSubJSON += '"blocked":true,'
			EndIf

			cSubJSON += '"name":"' + NGEscape( (cAliasQry)->TPA_DESCRI ) + '"'

			If (cAliasQry)->TPA_OPCOES <> "0"
				cSubJSON += ',"option":"' + (cAliasQry)->TPA_OPCOES + '"'
			EndIf

			cSubJSON += '}'

			fWriteJson(cSubJSON, nUpdate, oWs)

		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + NGEscape( (cAliasQry)->TPA_ETAPA ) + '"'

		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QQuestion
Query para opções da etapa

@autor Maria Elisandra de Paula
@since 17/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de opções da etapa
/*/
//---------------------------------------------------------------------
Static Function QQuestion( oWs, cDate, cOrigin )

	Local cQuery := " SELECT TPC_ETAPA, TPC_OPCAO, TPC_DESOPC, TPC_TIPCAM, TPC_TIPRES, "

	cQuery += fCaseDel('TPC',.T.)
	cQuery += " FROM " + RetSQLName('TPC') + " TPC "
	cQuery += " WHERE TPC.TPC_FILIAL = " + ValtoSql(FwxFilial("TPC"))

	If cDate <> "0"
		cQuery += "	AND (" + dateQuery( "TPC_USERGA" ) + " >= " + ValtoSql( cDate )
		cQuery += "	OR " + dateQuery( "TPC_USERGI" ) + " >= " + ValtoSql(cDate) + ")"
	Else
		cQuery += " AND TPC.D_E_L_E_T_ = ' '"
	EndIf

	cQuery := ChangeQuery( cQuery )

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sQuestion
Gera um JSON contendo as informações de perguntas (opções das etapas)
para a sincronização com o aplicativo Mobile

@author	Larissa Thaís de Farias
@author	Maria Elisandra de Paula
@since 17/04/2018
@param cDate - Data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sQuestion ( oWs, cDate )

	Local cDelete   := ''
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local cSubJSON  := ""
	Local cQuery    := QQuestion( oWs, cDate, "sQuestion" )
	Local cAliasQry := GeraTemp( cQuery, 'Question' )
	Local nDelete   := 0
	Local nUpdate   := 0
	Local aFileName := {}
	Local cEntity   := 'question'
	Local aInit     := fInitWrite(oWs, cEntity)
	
	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If fCondDel(cAliasQry)
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"checklist":"'		+ NGEscape( (cAliasQry)->TPC_ETAPA ) + '",'
			cSubJSON += '"code":"'			+ NGEscape( (cAliasQry)->TPC_OPCAO ) + '",'
			cSubJSON += '"description":"'	+ NGEscape( (cAliasQry)->TPC_DESOPC ) + '",'
			cSubJSON += '"answerType":"'	+ NGEscape( (cAliasQry)->TPC_TIPRES ) + '"'

			If (cAliasQry)->TPC_TIPRES == "2"
				cSubJSON += ',"fieldType":"' + NGEscape( (cAliasQry)->TPC_TIPCAM ) + '"'
			EndIf

			cSubJSON += '}'

			fWriteJson(cSubJSON, nUpdate, oWs)

		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + NGEscape( (cAliasQry)->TPC_ETAPA ) + '+' + NGEscape( (cAliasQry)->TPC_OPCAO ) + '"'

		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QAnswer
Query para respostas da etapa da ordem

@autor Maria Elisandra de Paula
@since 17/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de respostas da etapa
/*/
//---------------------------------------------------------------------
Static Function QAnswer( oWs, cDate, cOrigin )

	Local cQuery := " SELECT TPQ_ORDEM, TPQ_PLANO, TPQ_ETAPA,TPQ_OPCAO,TPC_TIPCAM,"

	cQuery += "  TPQ_TAREFA, TPQ_ORDEMG, TPC_TPMANU,TPC_TIPRES,"
	cQuery += "  CASE "
	cQuery += "   WHEN TPC_TIPRES = '1' THEN '.T.'"
	cQuery += "   ELSE TPQ_RESPOS "
	cQuery += "   END AS TPQ_RESPOS,"
	cQuery += fCaseDel('TPQ',.T.)
	cQuery += " FROM " + RetSQLName('TPQ') + " TPQ "
	cQuery += " JOIN " + RetSQLName('TPC') + " TPC "
	cQuery += "  ON TPC_FILIAL = " + ValtoSql(FwxFilial("TPC"))
	cQuery += "	 AND TPC_ETAPA = TPQ_ETAPA "
	cQuery += "	 AND TPC_OPCAO = TPQ_OPCAO "
	cQuery += "	 AND TPC.D_E_L_E_T_ = ' ' "
	cQuery += " INNER JOIN " + RetSQLName('STJ') + " STJ "
	cQuery += " 	ON STJ.TJ_FILIAL = " + ValtoSql( FwxFilial("STJ") )
	cQuery += "		AND STJ.TJ_ORDEM = TPQ.TPQ_ORDEM "
	cQuery += "		AND STJ.TJ_PLANO = TPQ.TPQ_PLANO "
	cQuery += QOrder( oWs, cDate, '' )
	cQuery += "	AND TPQ.TPQ_FILIAL = " + ValtoSql(FwxFilial("TPQ"))

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "TJ_USERLGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "TJ_USERLGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND TPQ.D_E_L_E_T_ = ' '"
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sAnswer
Gera um JSON contendo as informações de respostas das etapas para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@author	Maria Elisandra de Paula
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sAnswer ( oWs, cDate )

	Local cDelete   := ''
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local cSubJSON  := ""
	Local xValue
	Local cQuery    := ChangeQuery( QAnswer( oWs, cDate, "sAnswer" ) )
	Local cAliasQry := GeraTemp( cQuery, 'Answer' )
	Local nDelete   := 0
	Local nUpdate   := 0
	Local aFileName := {}
	Local cEntity   := 'answer'
	Local aInit     := fInitWrite(oWs, cEntity)
	
	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If fCondDel(cAliasQry)
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += fToJson("order",    (cAliasQry)->TPQ_ORDEM) + ","
			cSubJSON += fToJson("plan",     (cAliasQry)->TPQ_PLANO) + ","
			cSubJSON += fToJson("task",     (cAliasQry)->TPQ_TAREFA)+ ","
			cSubJSON += fToJson("checklist",(cAliasQry)->TPQ_ETAPA)	+ ","
			cSubJSON += fToJson("code",     (cAliasQry)->TPQ_OPCAO)	+ ","

			//Há uma O.S ou S.S gerada quando o campo (cAliasQry)->TPQ_ORDEMG estiver preenchido
			If !Empty((cAliasQry)->TPQ_ORDEMG)
				cSubJSON += fToJson(If((cAliasQry)->TPC_TPMANU == "1","serviceOrder", "serviceRequest"),(cAliasQry)->TPQ_ORDEMG) + ","
			EndIf

			xValue := Nil
			If (cAliasQry)->TPC_TIPRES == "1" .Or. ((cAliasQry)->TPC_TIPCAM == "L" )
				If Alltrim((cAliasQry)->TPQ_RESPOS) == ".T."
					xValue := .T.
				Else
					xValue := .F.
				EndIf
			ElseIf (cAliasQry)->TPC_TIPCAM == "N"
				xValue := Val((cAliasQry)->TPQ_RESPOS)
			Else
				xValue := (cAliasQry)->TPQ_RESPOS
			EndIf

			cSubJSON += fToJson("value",xValue)
			cSubJSON += '}'

			fWriteJson(cSubJSON, nUpdate, oWs)

		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + NGEscape( (cAliasQry)->TPQ_ORDEM )  + '+' +  NGEscape( (cAliasQry)->TPQ_PLANO )  + '+' + ;
						NGEscape( (cAliasQry)->TPQ_TAREFA )  + '+' +  NGEscape( (cAliasQry)->TPQ_ETAPA )  + '+' + ;
						NGEscape( (cAliasQry)->TPQ_OPCAO ) + '"'

		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QOrder
Query para ordens de serviço

@autor Maria Elisandra de Paula
@since 04/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de ordens de serviço
/*/
//---------------------------------------------------------------------
Static Function QOrder( oWs, cDate, cOrigin )

	Local lFilterByUser := fHasPerms('onlyThisUser') .And. !Empty( cUserST1 )
	Local lSpecialties  := fHasPerms('onlyUserSpecialties') .And. !Empty( cUserST1 )
	Local lFilterUserSS := fHasPerms('onlyUserRelatedRequests')
	Local cQuery        := ""
	Local lLocOS    	:= fHasPerms('location-order')

	//Retira os campos que não serão usados na subquery dos métodos de insumo e etapa
	If cOrigin == "sOrder"

		cQuery += " SELECT DISTINCT STJ.TJ_ORDEM,   STJ.TJ_TIPOOS, "
		cQuery += " STJ.TJ_PLANO,   STJ.TJ_CODBEM,  STJ.TJ_SERVICO, STJ.TJ_SEQRELA, "
		cQuery += " STJ.TJ_DTORIGI, STJ.TJ_SITUACA, STJ.TJ_DTMPINI, STJ.TJ_HOMPINI, "
		cQuery += " STJ.TJ_DTMPFIM, STJ.TJ_HOMPFIM, STJ.R_E_C_N_O_, STJ.TJ_CCUSTO,  "
		cQuery += " STJ.TJ_POSCONT, STJ.TJ_POSCON2, STJ.TJ_HORACO1, STJ.TJ_HORACO2, "
		cQuery += " STJ.TJ_DTPPINI, STJ.TJ_HOPPINI, STJ.TJ_DTPPFIM, STJ.TJ_HOPPFIM, "
		cQuery += " STJ.TJ_DTPRINI, STJ.TJ_HOPRINI, STJ.TJ_DTPRFIM, STJ.TJ_HOPRFIM, "

		//-----------------------------------
		//código do usuário de inclusão
		//-----------------------------------
		cQuery += "CASE WHEN " + ValtoSql( cUserLog ) + " = " + fUserQuery()
		cQuery += "THEN 'true' ELSE '' END OWNER, "

		cQuery += " CASE WHEN STE.TE_CARACTE = 'P' "
		cQuery += " THEN 'P' Else 'C' END AS TYPE, "

		cQuery += " CASE "
		cQuery += "     WHEN STJ.TJ_SITUACA = 'C' THEN 'true' "
		cQuery += "     WHEN STJ.TJ_TERMINO = 'S' THEN 'true' "
		cQuery += "     WHEN STJ.D_E_L_E_T_ = '*' THEN 'true' "


		//-------------------------------------------------------------------------------------------------------------
		// O trecho abaixo realiza as condições de filtros do portal relacionados a usuário, deve ocorre apenas a
		// partir do segundo sync (quando a data vir preenchida) para identificar as ordens que devem ser deletadas do
		// app (quando um insumo foi deletado e não deve ser apresentado mais para determinado usuário)
		//-------------------------------------------------------------------------------------------------
		If cDate != '0' .And. ( lFilterByUser .Or. lSpecialties )

			//------------------------------------------
			//Retorna apenas OS's abertas pelo usuário
			//------------------------------------------
			cQuery += " WHEN ( (" + ValtoSql( cUserLog ) + " <> " + fUserQuery() + ") "
			cQuery += "  AND ( (SELECT COUNT(STL.TL_CODIGO) FROM "+ RetSQLName('STL') +" STL"
			cQuery += "       WHERE STL.TL_FILIAL = " + ValToSQL(FwxFilial("STL"))
			cQuery += "         AND STL.TL_ORDEM = STJ.TJ_ORDEM "
			cQuery += "         AND STL.D_E_L_E_T_ = ' ' AND ( "

			//-----------------------------------------
			// O.S's  do usuário logado
			//-----------------------------------------
			If lFilterByUser
				cQuery += " ( STL.TL_CODIGO = " + ValToSQL(AllTrim(cUserST1))
				cQuery += "		AND STL.TL_TIPOREG = 'M' )"

				If lSpecialties
					cQuery += "	OR "
				EndIf

			EndIf

			//-----------------------------------------------------------------------------------
			// Retorna apenas as O.S's que tenha pelo menos uma especialidade do usuário logado
			//-----------------------------------------------------------------------------------
			If lSpecialties
				cQuery += "( STL.TL_TIPOREG = 'E' AND STL.TL_CODIGO IN"
				cQuery +=  " ( SELECT ST2.T2_ESPECIA FROM " + RetSQLName('ST2') + " ST2"
				cQuery +=  " WHERE ST2.T2_FILIAL = " + ValToSQL(FwxFilial("ST2"))
				cQuery +=  "	AND ST2.T2_CODFUNC = " + ValToSQL(AllTrim(cUserST1))
				cQuery +=  "	AND ST2.D_E_L_E_T_ = ' '"
				cQuery +=  " GROUP BY ST2.T2_ESPECIA ) ) "

			EndIf

			cQuery += " ) ) = 0 "

			If lFilterUserSS .And. !Empty(cUserTQ4)

				//----------------------------------------------------
				// Vê se a OS não está atrelada a alguma SS
				//-----------------------------------------------------
				cQuery +=  " AND ( STJ.TJ_ORDEM NOT IN (" + QRequestOrders( oWs, '0', 'SORDER', .T. ) + "))"

			Endif

			cQuery += ") ) THEN 'true'

		EndIf

		cQuery += " Else ' ' "
		cQuery += " END AS IS_DELETED "
		cQuery += " FROM " + RetSQLName('STJ') + " STJ "

	EndIf

	cQuery += fJoinSTJ( oWs )

	//---------------------------------------------------------------------------------
	// O trecho abaixo realiza as condições de filtros do portal relacionados a usuário, deve ocorre apenas a
	// no primeiro sync (quando a data não está preenchida) para identificar as ordens que devem aparecer
	// no app (quando o usuário gerou a ordem ou algum insumo pertence a ele)
	//-------------------------------------------------------------------------------------------------
	If cDate == '0' .And. ( lFilterByUser .Or. lSpecialties )

		//------------------------------------------
		//Retorna apenas OS's abertas pelo usuário
		//------------------------------------------
		cQuery += " AND ( (" + ValtoSql( cUserLog ) + " = " + fUserQuery()

		cQuery += ") OR ("
		cQuery += " EXISTS( SELECT 1 FROM "+ RetSQLName('STL') +" STL"
		cQuery += " WHERE STL.TL_FILIAL = " + ValToSQL(FwxFilial("STL"))
		cQuery += " 	AND STL.TL_ORDEM = STJ.TJ_ORDEM "
		cQuery += "     AND STL.D_E_L_E_T_ = ' ' AND ( "

		//-----------------------------------------
		// Retorna apenas O.S's  do usuário logado,
		// conforme insumos previstos e realizados
		//-----------------------------------------
		If lFilterByUser

			cQuery += " ( STL.TL_CODIGO = " + ValToSQL(AllTrim(cUserST1))
			cQuery += " 	AND STL.TL_TIPOREG = 'M' ) "

			If lSpecialties
				cQuery += " OR "
			EndIf

		EndIf

		//-----------------------------------------------------------------------------------
		// Retorna apenas as O.S's que tenha pelo menos uma especialidade do usuário logado
		// conforme insumos previstos e realizados
		//------------------------------------------------------
		If lSpecialties
			cQuery +=  " ( STL.TL_TIPOREG = 'E' AND STL.TL_CODIGO IN "
			cQuery +=  "	(SELECT ST2.T2_ESPECIA FROM " + RetSQLName('ST2') + " ST2"
			cQuery +=  "		WHERE ST2.T2_FILIAL = " + ValToSQL(FwxFilial("ST2"))
			cQuery +=  "	    	AND ST2.T2_CODFUNC = " + ValToSQL(AllTrim(cUserST1))
			cQuery +=  "			AND ST2.D_E_L_E_T_ = ' '"
			cQuery +=  "		GROUP BY ST2.T2_ESPECIA ) ) "

		EndIf

		cQuery += " ) ) "

		If lFilterUserSS .And. !Empty(cUserTQ4)

			//----------------------------------------------------
			// Vê se a OS não está atrelada a alguma SS
			//-----------------------------------------------------
			cQuery +=  " OR ( STJ.TJ_ORDEM IN (" + QRequestOrders( oWs, '0', 'SORDER', .T. ) + "))"

		Endif

		cQuery += " ) )"

	EndIf

	If !fAppCalend( oWs )
		//Retorna apenas se não houver nenhum insumo com usa calendário habilitado
		cQuery += " AND (SELECT COUNT(STL.TL_CODIGO) "
		cQuery += " FROM "+ RetSQLName('STL') +" STL "
		cQuery += " WHERE STL.TL_FILIAL = "+ ValToSQL(FwxFilial("STL"))
		cQuery += "      AND STL.TL_ORDEM = STJ.TJ_ORDEM "
		cQuery += " 	 AND STL.TL_USACALE = 'S' "
		cQuery += "      AND STL.D_E_L_E_T_ = ' ' "
		cQuery += ") = 0 "
	EndIf

	cQuery += fFilterPe( oWs, 'FILTER_ORDER' )

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "TJ_USERLGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "TJ_USERLGI" ) + " >= " + ValtoSql( cDate ) + ") "
		cQuery += " AND TJ_SITUACA <> 'P' "
	Else
		cQuery += "AND TJ_SITUACA = 'L' AND TJ_TERMINO <> 'S' "
		cQuery += "AND STJ.D_E_L_E_T_ = ' ' "
	EndIf

	// tratamento para evitar inconsistências e considerar filtros entre STJ e ST9/TAF/ST6
	If lLocOS
		cQuery += " AND (( STJ.TJ_TIPOOS = 'B' AND ST9.T9_CODBEM IS NOT NULL AND ST6.T6_CODFAMI IS NOT NULL AND CTT.CTT_CUSTO IS NOT NULL)  " 
		cQuery += " 	OR ( STJ.TJ_TIPOOS = 'L' AND TAF.TAF_CODNIV IS NOT NULL AND ( CTT.CTT_CUSTO IS NOT NULL OR TAF.TAF_CCUSTO = ' ' ) ) )"
	Else
		cQuery += " AND ( ST9.T9_CODBEM IS NOT NULL AND ST6.T6_CODFAMI IS NOT NULL AND CTT.CTT_CUSTO IS NOT NULL) "
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sOrder
Gera um JSON contendo as informações de Ordens de Serviço para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sOrder( oWs, cDate )

	Local cDelete   := ''
	Local lSYP      := NGCADICBASE("TJ_MMSYP","A","STJ",.F.)
	Local cDescri   := ""
	Local cDtInicial
	Local cDtFinal
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local cSubJSON  := ""
	Local cQuery    := ChangeQuery( QOrder( oWs, cDate, "sOrder" ) )
	Local cAliasQry := GeraTemp( cQuery, 'Order' )
	Local nDelete   := 0
	Local nUpdate   := 0
	Local aFileName := {}
	Local cEntity   := 'serviceorder'
	Local aInit     := fInitWrite(oWs, cEntity)

	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If fCondDel(cAliasQry)
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			If !Empty((cAliasQry)->TJ_DTMPINI)
				cDtInicial := (cAliasQry)->TJ_DTMPINI
			Else
				cDtInicial := (cAliasQry)->TJ_DTORIGI
				printf('Ordem ' + (cAliasQry)->TJ_ORDEM + ' nao possui data inicial. Favor verificar.')
			EndIf

			If !Empty((cAliasQry)->TJ_DTMPFIM)
				cDtFinal := (cAliasQry)->TJ_DTMPFIM
			Else
				cDtFinal := (cAliasQry)->TJ_DTORIGI
				printf('Ordem ' + (cAliasQry)->TJ_ORDEM + ' nao possui data final. Favor verificar.')
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"' + NGEscape( (cAliasQry)->TJ_ORDEM ) + '",'
			cSubJSON += '"plan":"' + NGEscape( (cAliasQry)->TJ_PLANO ) + '",'
			cSubJSON += '"equipment":"' + NGEscape( (cAliasQry)->TJ_CODBEM ) + '",'
			cSubJSON += '"service":"' + NGEscape( (cAliasQry)->TJ_SERVICO ) + '",'
			cSubJSON += '"sequence":"' + NGEscape( (cAliasQry)->TJ_SEQRELA ) + '",'
			cSubJSON += '"startDateTime":"' + cDtInicial + ' ' + NGEscape( (cAliasQry)->TJ_HOMPINI ) + '",'
			cSubJSON += '"endDateTime":"' + cDtFinal + ' ' + NGEscape( (cAliasQry)->TJ_HOMPFIM ) + '",'
			cSubJSON += '"type":"' + NGEscape( (cAliasQry)->TYPE ) + '",'
			cSubJSON += '"costCenterCode":"' + NGEscape((cAliasQry)->TJ_CCUSTO ) + '",'
			cSubJSON += '"originDate":"' + (cAliasQry)->TJ_DTORIGI + '",'

			//-----------------------------------------
			// Informações de parada do equipamento
			//-----------------------------------------

			If !Empty( (cAliasQry)->TJ_DTPPINI ) .And. !Empty( (cAliasQry)->TJ_HOPPINI ) // parada prevista inic
				cSubJSON += '"plannedDownTime":"' + (cAliasQry)->TJ_DTPPINI + ' ' + NGEscape( (cAliasQry)->TJ_HOPPINI ) + '",'
			EndIf

			If !Empty( (cAliasQry)->TJ_DTPPFIM ) .And. !Empty( (cAliasQry)->TJ_HOPPFIM ) // parada prevista fim
				cSubJSON += '"plannedUpTime":"' + (cAliasQry)->TJ_DTPPFIM + ' ' + NGEscape( (cAliasQry)->TJ_HOPPFIM ) + '",'
			EndIf

			If !Empty( (cAliasQry)->TJ_DTPRINI ) .And. !Empty( (cAliasQry)->TJ_HOPRINI ) // parada real inic
				cSubJSON += '"downTime":"' + (cAliasQry)->TJ_DTPRINI + ' ' + NGEscape( (cAliasQry)->TJ_HOPRINI ) + '",'
			EndIf

			If !Empty( (cAliasQry)->TJ_DTPRFIM ) .And. !Empty( (cAliasQry)->TJ_HOPRFIM ) // parada real fim
				cSubJSON += '"upTime":"' + (cAliasQry)->TJ_DTPRFIM + ' ' + NGEscape( (cAliasQry)->TJ_HOPRFIM ) + '",'
			EndIf

			//------------------------------------
			// Informações de contadores da OS
			//------------------------------------
			If ( (cAliasQry)->TJ_POSCONT > 0 .And. !Empty( (cAliasQry)->TJ_HORACO1 ) ) .OR. ;
				( (cAliasQry)->TJ_POSCON2 > 0 .And. !Empty( (cAliasQry)->TJ_HORACO2 ) )

				cSubJSON += '"counter":['

				If (cAliasQry)->TJ_POSCONT > 0 .And. !Empty( (cAliasQry)->TJ_HORACO1 )
					cSubJSON += '{"value":' + cValtoChar( (cAliasQry)->TJ_POSCONT ) + ','
					cSubJSON += '"time":"' + NGEscape( (cAliasQry)->TJ_HORACO1 ) + '"}'
				Else
					cSubJSON += '{}'//A primeira posição do array deve existir sempre
				EndIf

				If (cAliasQry)->TJ_POSCON2 > 0 .And. !Empty( (cAliasQry)->TJ_HORACO2 )
					cSubJSON += ',{"value":' + cValtoChar( (cAliasQry)->TJ_POSCON2 ) + ','
					cSubJSON += '"time":"' + NGEscape( (cAliasQry)->TJ_HORACO2 ) + '"}'
				EndIf

				cSubJSON += '],'

			EndIf

			If (cAliasQry)->OWNER == "true"
				cSubJSON += '"owner":true,'
			EndIf

			// Caso a O.S. seja do tipo localização adiciona o item LOCATION como true
			If (cAliasQry)->TJ_TIPOOS == 'L'
				cSubJSON += '"location":true,'
			EndIf

			dbSelectArea('STJ')
			dbGoTo( (cAliasQry)->R_E_C_N_O_ )

			If lSYP //Caso o MEMO esteja na SYP
				cDescri := NGMEMOSYP(STJ->TJ_MMSYP)
			Else
				cDescri := STJ->TJ_OBSERVA
			EndIf

			cSubJSON += '"description":"' + NGEscape( cDescri ) + '"'

			cSubJSON += '}'

			fWriteJson(cSubJSON, nUpdate, oWs)

		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + NGEscape( (cAliasQry)->TJ_ORDEM )  + "+" + NGEscape( (cAliasQry)->TJ_PLANO ) + '"'

		EndIf

		dbSelectArea(cAliasQry)
		nCount++
		( cAliasQry )->( dbSkip() )

	EndDo

	( cAliasQry )->( dbCloseArea() )

	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QInputSO
Query para insumos da ordem de serviço

@author	Maria Elisandra de Paula
@since 03/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de insumos da ordem de serviço
/*/
//---------------------------------------------------------------------
Static Function QInputSO( oWs, cDate, cOrigin )

	Local cQuery   := ''
	Local lUsaEsto := SuperGetMv( 'MV_NGMNTES', .F., 'N' ) == 'S'
	Local lGeraSa  := lUsaEsto .And. SuperGetMv( 'MV_NGGERSA', .F., 'N' ) $ 'S/P'
	Local lUsaComp := lUsaEsto .And. !lGeraSa .And. SuperGetMv( 'MV_NGMNTCM', .F., 'N' ) == 'S'

	cQuery += " SELECT STL.TL_ORDEM, STL.TL_PLANO, STL.TL_SEQRELA, STL.TL_TAREFA, STL.TL_TIPOREG, STL.TL_PERMDOE, "
	cQuery += "  STL.TL_CODIGO, STL.TL_QUANTID, STL.TL_QUANREC, STL.TL_UNIDADE, STL.TL_DESTINO, TL_OBSERVA,  "
	cQuery += "  STL.TL_DTINICI, STL.TL_HOINICI, STL.TL_DTFIM, STL.TL_HOFIM, STL.TL_LOCAL, STL.TL_SEQTARE, "
	cQuery += "  STL.TL_TIPOHOR, STL.TL_LOCALIZ, STL.TL_NUMSERI, STL.TL_LOTECTL, STL.TL_NUMLOTE, STL.TL_NUMSA, STL.TL_ITEMSA, "
	cQuery += "    STL.R_E_C_N_O_, STL.TL_NUMSC, STL.TL_ITEMSC, STL.TL_USACALE, STL.TL_LOJA, "

	If fHasPerms('occurrences')

		cQuery += cIsNull + "( STN.TN_CODOCOR, '' ) AS TN_CODOCOR, "
		cQuery += cIsNull + "( STN.TN_CAUSA  , '' ) AS TN_CAUSA  , "
		cQuery += cIsNull + "( STN.TN_SOLUCAO, '' ) AS TN_SOLUCAO, "
		cQuery += "STN.TN_DESCRIC, "
		cQuery += "STN.R_E_C_N_O_ AS RECNO_STN, "

	EndIf

	If lGeraSa
		//colunas CP_PREREQU e CP_OK abaixo indicam quando há pre-requisicão de SA
		cQuery += cIsNull + "( CP_PREREQU,' ' ) CP_PREREQU,"
		cQuery += cIsNull + "( CP_OK, ' ') CP_OK, "
	EndIf

	If !lUsaComp

		cQuery += " 0 AS QUOTATION ,"

	Else

		//coluna QUOTATION abaixo indica quantidade de insumo com pedido ou cotação ( substitui a função NGBUSC1COM )
		cQuery += " CASE WHEN STL.TL_TIPOREG IN( 'T', 'P' ) AND TL_NUMSC <> ' ' "
		cQuery += "     THEN " + cIsNull + "(( "
		cQuery += "         SELECT SUM( "
		cQuery += "             CASE WHEN C1_PEDIDO <> ' ' THEN C1_QUJE "
		cQuery += "                 WHEN C1_COTACAO <> ' ' THEN C1_QUANT "
		cQuery += "	            ELSE 0 "
		cQuery += "             END ) QUANT "
		cQuery += "         FROM " + RetSQLName("SC1") + " SC1 "
		cQuery += "         WHERE SC1.C1_FILIAL = " + ValtoSql( FwxFilial("SC1") )
		cQuery += "         	AND SC1.C1_NUM = STL.TL_NUMSC "
		cQuery += "         	AND SC1.C1_ITEM = STL.TL_ITEMSC "
		cQuery += "             AND SC1.D_E_L_E_T_= ' ' "
		cQuery += "             AND STL.TL_ORDEM || 'OS001' = SC1.C1_OP "
		cQuery += "             AND STL.TL_CODIGO = C1_PRODUTO "
		cQuery += "             AND STL.TL_LOCAL = C1_LOCAL "
		cQuery += "         GROUP BY SC1.C1_OP, C1_PRODUTO, C1_LOCAL ), 0) "
		cQuery += " ELSE 0 "
		cQuery += " END AS QUOTATION, "

	EndIf

	cQuery += " CASE "
	cQuery += "    WHEN STJ.TJ_SITUACA = 'C' THEN 'true' "
	cQuery += "    WHEN STJ.TJ_TERMINO = 'S' THEN 'true' "
	cQuery += "    WHEN STJ.D_E_L_E_T_ = '*' THEN 'true' "
	cQuery += "    WHEN STL.D_E_L_E_T_ = '*' THEN 'true' "
	cQuery += " ELSE ' ' "
	cQuery += " END AS IS_DELETED "

	cQuery += " FROM " + RetSQLName('STL') + " STL "
	cQuery += " INNER JOIN " + RetSQLName('STJ') + " STJ "
	cQuery += "  ON STJ.TJ_FILIAL = " + ValtoSql( FwxFilial("STJ") ) 
	cQuery += "      AND STJ.TJ_ORDEM = STL.TL_ORDEM "
	cQuery += "      AND STJ.TJ_PLANO = STL.TL_PLANO "

	If lGeraSa

		cQuery += " LEFT JOIN " + RetSQLName("SCP") + " SCP "
		cQuery += "     ON SCP.CP_FILIAL = " + ValtoSql( FwxFilial("SCP") )
		cQuery += "     AND STL.TL_NUMSA = SCP.CP_NUM "
		cQuery += "     AND STL.TL_ITEMSA = SCP.CP_ITEM "
		cQuery += "     AND SCP.CP_PREREQU <> ' ' AND SCP.CP_OK <> ' ' "
		cQuery += "     AND SCP.D_E_L_E_T_ = ' ' "

	EndIf

	If fHasPerms('occurrences')

		cQuery += " LEFT JOIN " + RetSQLName( 'STN' ) + " STN ON "
		cQuery += 	" STN.TN_FILIAL  = " + ValToSQL( FwxFilial( 'STN' ) ) + " AND "
		cQuery += 	" STN.TN_ORDEM   = STL.TL_ORDEM   AND "
		cQuery += 	" STN.TN_PLANO   = STL.TL_PLANO   AND "
		cQuery += 	" STN.TN_TAREFA  = STL.TL_TAREFA  AND "
		cQuery += 	" STN.TN_SEQRELA = STL.TL_SEQRELA AND "
		cQuery += 	" STN.D_E_L_E_T_ = ' ' "

	EndIf

	cQuery += QOrder( oWs, cDate, '' )
	cQuery += " AND STL.TL_FILIAL = " + ValtoSql( FwxFilial("STL") )

	If cDate == "0"
		cQuery += " AND STL.D_E_L_E_T_ = ' ' "
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sInputSO
Gera um JSON contendo as informações de Insumos da OS para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sInputSO( oWs, cDate )

	Local cOrder
	Local cPlan
	Local cTipo
	Local cCod
	Local cSeqTa
	Local cDelete    := ''
	Local cTask      := ''
	Local cSeqRe     := ''
	Local cTNObserva := ''
	Local cAuxJSON   := ''
	Local lFirstSTN  := .T.
	Local lEmptySTN  := .F.
	Local lFirst     := .T.
	Local lFirstD    := .T.
	Local nCount     := 0
	Local cHrIn      := Time()
	Local cSubJSON   := ""
	Local lUsaLote   := SuperGetMV("MV_RASTRO",.F.,'N') == "S" //Indica se utiliza controle de rastro nos produtos
	Local lUsaLocal  := SuperGetMV("MV_LOCALIZ") == "S" //Indica se utiliza controle de localização nos produtos
	Local cTlObserva := ""
	Local lUsaEsto   := SuperGetMv( "MV_NGMNTES", .F.,'N' ) == 'S'
	Local lGeraSa    := lUsaEsto .And. SuperGetMv( 'MV_NGGERSA', .F., 'N' ) $ 'S/P'
	Local cQuery     := ChangeQuery( QInputSO( oWs, cDate, "sInputSO" ) + " ORDER BY TL_ORDEM " )
	Local cAliasQry  := GeraTemp( cQuery, 'InputSO' )
	Local nDelete    := 0
	Local nUpdate    := 0
	Local aFileName  := {}
	Local cEntity    := 'inputso'
	Local aInit      := fInitWrite(oWs, cEntity)
	
	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		cOrder  := NGEscape( (cAliasQry)->TL_ORDEM )
		cPlan   := NGEscape( (cAliasQry)->TL_PLANO )
		cTask   := NGEscape( (cAliasQry)->TL_TAREFA )
		cTipo   := NGEscape( (cAliasQry)->TL_TIPOREG )
		cCod    := NGEscape( (cAliasQry)->TL_CODIGO )
		cSeqRe  := NGEscape( (cAliasQry)->TL_SEQRELA )
		cSeqTa  := NGEscape( (cAliasQry)->TL_SEQTARE )
		cPerc   := If( (cAliasQry)->TL_PERMDOE != Nil, (cAliasQry)->TL_PERMDOE, Nil)

		If fCondDel(cAliasQry)
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"order":"' + cOrder + '",'
			cSubJSON += '"plan":"' + cPlan + '",'
			cSubJSON += '"sequence":"' + cSeqRe + '",'
			cSubJSON += '"task":"' + cTask + '",'
			cSubJSON += '"taskSequence":"' + cSeqTa + '",'
			cSubJSON += '"percent":' + cValtoChar(cPerc) + ','
			cSubJSON += '"type":"' + cTipo + '",'
			cSubJSON += '"code":"' + cCod + '",'

			If (cAliasQry)->TL_TIPOREG != 'P' .And. Alltrim((cAliasQry)->TL_UNIDADE) == 'H' .And. (cAliasQry)->TL_TIPOHOR == 'S'
				cSubJSON += '"amount":' + cValtoChar(NGRETHORDDH((cAliasQry)->TL_QUANTID)[2]) + ','
			Else
				cSubJSON += '"amount":' + cValtoChar((cAliasQry)->TL_QUANTID) + ','
			EndIf
			cSubJSON += '"resourceAmount":' + cValtoChar((cAliasQry)->TL_QUANREC) + ','
			cSubJSON += '"unity":"' + NGEscape( (cAliasQry)->TL_UNIDADE ) + '",'
			cSubJSON += '"destiny":"' + NGEscape( (cAliasQry)->TL_DESTINO ) + '",'
			cSubJSON += '"startDateTime":"' + NGEscape( (cAliasQry)->TL_DTINICI ) + ' ' + NGEscape( (cAliasQry)->TL_HOINICI ) + '",'
			cSubJSON += '"endDateTime":"' + NGEscape( (cAliasQry)->TL_DTFIM ) + ' ' + NGEscape( (cAliasQry)->TL_HOFIM) + '",'
			cSubJSON += '"warehouse":"' + NGEscape( (cAliasQry)->TL_LOCAL ) + '",'

			If (cAliasQry)->TL_TIPOREG == "P"
				//Controle de rastro: 'L':controla somente Lote,'S':controla lote e sub-lote
				If lUsaLote .And. ! Empty((cAliasQry)->TL_LOTECTL)
					cSubJSON += '"lot":"' + NGEscape((cAliasQry)->TL_LOTECTL) + '",'
					cSubJSON += '"sublot":"' + NGEscape((cAliasQry)->TL_NUMLOTE)+ '",'
				EndIf

				//Controle de localização: sim ou não
				If lUsaLocal .And. ( !Empty((cAliasQry)->TL_LOCALIZ) .Or. ! Empty((cAliasQry)->TL_NUMSERI) )
					cSubJSON += '"location":"' + NGEscape((cAliasQry)->TL_LOCALIZ)+ '",'
					cSubJSON += '"serialnumber":"' + NGEscape((cAliasQry)->TL_NUMSERI) + '",'
				EndIf
			EndIf

			//Os campos abaixo só serão enviados caso os insumos possuam pre requisição
			If lGeraSa .And. !Empty( (cAliasQry)->CP_PREREQU ) .And. !Empty( (cAliasQry)->CP_OK  )
				cSubJSON += '"warehouseRequest":"' + (cAliasQry)->TL_NUMSA + '",'
				cSubJSON += '"warehouseItem":"' + (cAliasQry)->TL_ITEMSA + '",'
			EndIf

			If !Empty( (cAliasQry)->TL_NUMSA ) .And. !Empty( (cAliasQry)->TL_ITEMSA )
				cSubJSON += '"saNum":"' + (cAliasQry)->TL_NUMSA + '",'
				cSubJSON += '"saItem":"' + (cAliasQry)->TL_ITEMSA + '",'
			EndIf

			If !Empty( (cAliasQry)->TL_NUMSC ) .And. !Empty( (cAliasQry)->TL_ITEMSC )
				cSubJSON += '"scNum":"' + (cAliasQry)->TL_NUMSC + '",'
				cSubJSON += '"scItem":"' + (cAliasQry)->TL_ITEMSC + '",'
			EndIf

			//Caso tenha cotação de compras envia quantidade ---
			If (cAliasQry)->QUOTATION > 0
				cSubJSON += '"quotation":' + cValtoChar( (cAliasQry)->QUOTATION ) + ','
			EndIf

			If (cAliasQry)->TL_USACALE == 'S'
				cSubJSON += '"useCalendar": true,'
			EndIf

			If !Empty((cAliasQry)->TL_LOJA)
				cSubJSON += '"store":"' + (cAliasQry)->TL_LOJA + '",'
			EndIf

			cTlObserva := ""

			dbSelectArea("STL")
			dbGoTo( (cAliasQry)->R_E_C_N_O_ )
			If !Empty( STL->TL_OBSERVA )
				cTlObserva := Alltrim( STL->TL_OBSERVA )
				cTlObserva := StrTran( cTlObserva, '"', '\"' )
			EndIf

			cSubJSON += '"note":"' + NGEscape( cTlObserva ) + '"'

			If fHasPerms('occurrences') .And. ( lEmptySTN := !Empty( (cAliasQry)->TN_CODOCOR ) )

				cSubJSON  += ',"occurrences":['
				lFirstSTN := .T.
				cOrder    := (cAliasQry)->TL_ORDEM
				cPlan     := (cAliasQry)->TL_PLANO
				cTask     := (cAliasQry)->TL_TAREFA
				cSeqRe    := (cAliasQry)->TL_SEQRELA

				Do While (cAliasQry)->( !EoF() ) .And. (cAliasQry)->TL_ORDEM == cOrder .And. (cAliasQry)->TL_PLANO == cPlan .And.;
					(cAliasQry)->TL_TAREFA == cTask .And. (cAliasQry)->TL_SEQRELA == cSeqRe

					cAuxJSON := ','

					If lFirstSTN
						lFirstSTN := .F.
						cAuxJSON  := ''
					EndIf

					cSubJSON += cAuxJSON + '{'

					cSubJSON += '"problem":"'   + NGEscape( (cAliasQry)->TN_CODOCOR ) + '"'

					cSubJSON += IIf( !Empty( (cAliasQry)->TN_CAUSA )  , ',"cause":"'    + NGEscape( (cAliasQry)->TN_CAUSA )   + '"', '' )
					cSubJSON += IIf( !Empty( (cAliasQry)->TN_SOLUCAO ), ',"solution":"' + NGEscape( (cAliasQry)->TN_SOLUCAO ) + '"', '' )

					cTNObserva := ''

					dbSelectArea( 'STN' )
					dbGoTo( (cAliasQry)->RECNO_STN )
					If !Empty( STN->TN_DESCRIC )
						cSubJSON += ',"note":"' + NGEscape( StrTran( AllTrim( STN->TN_DESCRIC ), '"', '\"' ) ) + '"'
					EndIf

					cSubJSON += '}'

					(cAliasQry)->( dbSkip() )

				EndDo

				cSubJSON += ']'

			EndIf

			cSubJSON += '}'

			fWriteJson(cSubJSON, nUpdate, oWs)

		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + cOrder + "+" + cPlan + "+" + cTask + "+" + cTipo + "+" + cCod + "+" + cSeqRe + "+" + cSeqTa + '"'

			lEmptySTN := .F.

		EndIf

		nCount++

		// Caso não exista ocorrência relacionada a este registro, pula para o proximo.
		If !lEmptySTN

			(cAliasQry)->( dbSkip() )

		EndIf

	EndDo

	( cAliasQry )->( dbCloseArea() )

	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QCheckSO
Query para etapas da ordem de serviço

@autor Maria Elisandra de Paula
@since 12/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de etapas da ordem de serviço
/*/
//---------------------------------------------------------------------
Static Function QCheckSO( oWs, cDate, cOrigin )

	Local cQuery := " SELECT STQ.TQ_ORDEM "

	If cOrigin == "sCheckSO"
		cQuery += ", STQ.TQ_PLANO, STQ.TQ_SEQTARE,STQ.TQ_SEQETA, STQ.TQ_TAREFA, STQ.TQ_ETAPA, "
		cQuery += "    STQ.TQ_CODFUNC, "
		cQuery += "    CASE  WHEN STJ.TJ_SITUACA = 'C' THEN 'true' "
		cQuery += "     WHEN STJ.TJ_TERMINO = 'S' THEN 'true' "
		cQuery += "     WHEN STQ.D_E_L_E_T_ = '*' THEN 'true' "
		cQuery += "    Else ' ' END AS IS_DELETED "
	EndIf

	cQuery += " FROM " + RetSQLName('STQ') + " STQ "
	cQuery += " INNER JOIN " + RetSQLName('STJ') + " STJ "
	cQuery += " 	ON STJ.TJ_FILIAL = " + ValtoSql( FwxFilial("STJ") )
	cQuery += "		AND STJ.TJ_ORDEM = STQ.TQ_ORDEM "
	cQuery += "		AND STJ.TJ_PLANO = STQ.TQ_PLANO "
	cQuery += " INNER JOIN " + RetSQLName('TPA') + " TPA2"
	cQuery += "   ON TPA2.TPA_FILIAL = " + ValtoSql(FwxFilial("TPA"))
	cQuery += "     AND TPA2.TPA_ETAPA = TQ_ETAPA "
	cQuery += "     AND TPA2.D_E_L_E_T_ = ' ' "

	//Inicio da subquery que devolve de quais OS os insumos devem ser trazidos
	cQuery += QOrder( oWs, cDate, '' )
	cQuery += " AND STQ.TQ_FILIAL = " + ValtoSql( FwxFilial("STQ") )

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "TJ_USERLGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "TJ_USERLGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND STJ.TJ_SITUACA = 'L' "
		cQuery += " AND STJ.TJ_TERMINO = 'N' "
		cQuery += " AND STQ.D_E_L_E_T_ = ' ' "
	EndIf

	If cOrigin == "sCheckSO"

		cQuery += ' ORDER BY STQ.TQ_ORDEM, STQ.TQ_PLANO, '
		cQuery += 	' STQ.TQ_SEQTARE,'
		cQuery += 	' STQ.TQ_SEQETA,'
		cQuery += 	' STQ.TQ_TAREFA,'
		cQuery += 	' STQ.TQ_ETAPA'

	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sCheckSO
Gera um JSON contendo as informações de Etapas da OS para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sCheckSO( oWs, cDate )
	
	Local cDelete   := ''
	Local cOrder
	Local cPlan
	Local cSeque
	Local cTare
	Local cCod
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local cSubJSON  := ""
	Local cQuery    := ChangeQuery( QCheckSO( oWs, cDate, "sCheckSO") )
	Local cAliasQry := GeraTemp( cQuery, 'CheckSO' )
	Local nDelete   := 0
	Local nUpdate   := 0
	Local aFileName := {}
	Local cEntity   := 'checkso'
	Local aInit     := fInitWrite(oWs, cEntity)
	
	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		cOrder := NGEscape( (cAliasQry)->TQ_ORDEM )
		cPlan  := NGEscape( (cAliasQry)->TQ_PLANO )
		cSeque := NGEscape( (cAliasQry)->TQ_SEQTARE )
		cTare  := NGEscape( (cAliasQry)->TQ_TAREFA )
		cCod   := NGEscape( (cAliasQry)->TQ_ETAPA )

		// Tratamento para inconsistência do app quando o campo tarefa é vazio
		If Empty( cTare )
			cTare := '0'
		EndIf

		If fCondDel(cAliasQry)
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"order":"' + cOrder + '",'
			cSubJSON += '"plan":"' + cPlan + '",'
			cSubJSON += '"sequence":"' + cSeque + '",'
			cSubJSON += '"task":"' + cTare + '",'
			cSubJSON += '"code":"' + cCod + '",'
			cSubJSON += '"user":"' + NGEscape( (cAliasQry)->TQ_CODFUNC ) + '"'
			cSubJSON += '}'

			fWriteJson(cSubJSON, nUpdate, oWs)

		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + cOrder + "+" + cPlan + "+" + cTare + "+" + cCod + "+" + cSeque + '"'

		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QInputMain
Query para insumos da manutenção

@autor Maria Elisandra de Paula
@since 17/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return string, query de insumos da manutenção
/*/
//---------------------------------------------------------------------
Static Function QInputMain( oWs, cDate )

	Local cQuery := ""

	cQuery += " SELECT STG.TG_CODBEM, STG.TG_SERVICO, STG.TG_SEQRELA, STG.TG_TAREFA, STG.TG_TIPOREG, "
	cQuery += "       STG.TG_CODIGO, STG.TG_QUANTID, STG.TG_QUANREC, STG.TG_UNIDADE, STG.TG_DESTINO, "
	cQuery += "       STG.TG_LOCAL, "
	cQuery += " CASE "
	cQuery += " WHEN STF.D_E_L_E_T_ = '*' THEN 'true' "
	cQuery += " WHEN STG.D_E_L_E_T_ = '*' THEN 'true' "
	cQuery += " Else ' ' "
	cQuery += " END AS IS_DELETED "

	cQuery += " FROM " + RetSQLName('STG') + " STG "
	cQuery += " INNER JOIN " + RetSQLName('STF') + " STF " 
	cQuery += " 	ON STF.TF_FILIAL = " + ValtoSql( FwxFilial("STF") ) 
	cQuery += "		AND STF.TF_CODBEM = STG.TG_CODBEM "
	cQuery += "		AND STF.TF_SERVICO = STG.TG_SERVICO "
	cQuery += "		AND STF.TF_SEQRELA = STG.TG_SEQRELA "
	cQuery += "		AND STF.TF_ATIVO = 'S' "
	cQuery += QMaintenance( oWS, cDate, '' )

	cQuery += " AND STG.TG_FILIAL = " + ValtoSql( FwxFilial("STG") )

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "TG_USERLGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "TG_USERLGI" ) + " >= " + ValtoSql( cDate ) + " )"
	Else
		cQuery += "AND STG.D_E_L_E_T_ = ' '"
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sInputMain
Gera um JSON contendo as informações de Insumos da Manutenção para a
sincronização com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 05/04/2016
@param oWs, objeto, self do Webservice que contém os headers
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sInputMain( oWs, cDate )

	Local cDelete   := ''
	Local cCodBem
	Local cService
	Local cTarefa
	Local cTipo
	Local cCode
	Local cSeqRe
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local cHrIn     := Time()
	Local cSubJSON  := ""
	Local nCount    := 0
	Local cQuery    := ChangeQuery( QInputMain( oWs, cDate ) )
	Local cAliasQry := GeraTemp( cQuery, 'InputMain' )
	Local nDelete   := 0
	Local nUpdate   := 0
	Local aFileName := {}
	Local cEntity   := 'inputmain'
	Local aInit     := fInitWrite(oWs, cEntity)
	
	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		cCodBem  := NGEscape( (cAliasQry)->TG_CODBEM )
		cService := NGEscape( (cAliasQry)->TG_SERVICO )
		cSeqRe   := NGEscape( (cAliasQry)->TG_SEQRELA )
		cTarefa  := NGEscape( (cAliasQry)->TG_TAREFA )
		cTipo    := NGEscape( (cAliasQry)->TG_TIPOREG )
		cCode    := NGEscape( (cAliasQry)->TG_CODIGO )

		If fCondDel(cAliasQry)
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"equipment":"' + cCodBem + '",'
			cSubJSON += '"service":"' + cService + '",'
			cSubJSON += '"sequence":"' + cSeqRe + '",'
			cSubJSON += '"task":"' + cTarefa + '",'
			cSubJSON += '"type":"' + cTipo + '",'
			cSubJSON += '"code":"' + cCode + '",'
			cSubJSON += '"amount":"' + cValToChar((cAliasQry)->TG_QUANTID) + '",'
			cSubJSON += '"resourceAmount":"' + cValToChar((cAliasQry)->TG_QUANREC ) + '",'
			cSubJSON += '"unity":"' + NGEscape( (cAliasQry)->TG_UNIDADE ) + '",'
			cSubJSON += '"destiny":"' + NGEscape( (cAliasQry)->TG_DESTINO ) + '",'
			cSubJSON += '"warehouse":"' + NGEscape( (cAliasQry)->TG_LOCAL ) + '"'
			cSubJSON += '}'

			fWriteJson(cSubJSON, nUpdate, oWs)

		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + cCodBem + "+" + cService + "+" + cSeqRe + "+" + cTarefa + "+" + cTipo + "+" + cCode + '"'

		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QCheckMain
Query para etapas da manutenção

@autor Maria Elisandra de Paula
@since 17/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de etapas da manutenção
/*/
//---------------------------------------------------------------------
Static Function QCheckMain( oWs, cDate, cOrigin )

	Local cQuery := " SELECT STH.TH_CODBEM , STH.TH_SERVICO, STH.TH_SEQRELA,

	cQuery +=  "STH.TH_TAREFA, STH.TH_ETAPA, ST5_0.T5_SEQUENC, "
	cQuery += " STH.TH_SEQETA, "
	cQuery += " CASE "
	cQuery += " WHEN STF.D_E_L_E_T_ = '*' THEN 'true' "
	cQuery += " WHEN STH.D_E_L_E_T_ = '*' THEN 'true' "
	cQuery += " Else ' ' "
	cQuery += " END AS IS_DELETED "

	cQuery += " FROM " + RetSQLName('STH') + " STH "
	cQuery += " INNER JOIN " + RetSQLName('ST5') + " ST5_0 "
	cQuery += " 	ON ST5_0.T5_FILIAL = STH.TH_FILIAL "
	cQuery += " 		AND ST5_0.T5_CODBEM = STH.TH_CODBEM "
	cQuery += "      	AND ST5_0.T5_SERVICO = STH.TH_SERVICO "
	cQuery += "     	AND ST5_0.T5_SEQRELA = STH.TH_SEQRELA "
	cQuery += "			AND ST5_0.T5_TAREFA = STH.TH_TAREFA "
	cQuery += "      	AND ST5_0.D_E_L_E_T_ = ' ' "

	cQuery += " INNER JOIN " + RetSQLName('STF') + " STF "
	cQuery += "		ON STF.TF_FILIAL = " + ValtoSql( FwxFilial("STF") )
	cQuery += "  	AND STF.TF_CODBEM = STH.TH_CODBEM "
	cQuery += "		AND STF.TF_SERVICO = STH.TH_SERVICO "
	cQuery += "		AND STF.TF_SEQRELA = STH.TH_SEQRELA "
	cQuery += "      AND STF.TF_ATIVO = 'S'"
	cQuery += QMaintenance( oWS, cDate, '' )

	cQuery += " AND STH.TH_FILIAL = " + ValtoSql( FwxFilial("STH") )

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "TH_USERLGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "TH_USERLGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND STF.D_E_L_E_T_ = ' ' AND STH.D_E_L_E_T_ = ' ' "
	EndIf

	cQuery += "  ORDER BY STH.TH_CODBEM, STH.TH_SERVICO, STH.TH_SEQRELA, ST5_0.T5_SEQUENC, STH.TH_SEQETA "

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sCheckMain
Gera um JSON contendo as informações de Etapas da Manutenção para a
sincronização com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 05/04/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sCheckMain( oWs, cDate )

	Local cDelete   := ''
	Local cCodBem   := ""
	Local cServic   := ""
	Local cSeque    := ""
	Local cTare     := ""
	Local cCode     := ""
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local cSubJSON  := ""
	Local cQuery    := ChangeQuery( QCheckMain( oWs, cDate, "sCheckMain" ) )
	Local cAliasQry := GeraTemp( cQuery, 'CheckMain' )
	Local nDelete   := 0
	Local nUpdate   := 0
	Local aFileName := {}
	Local cEntity   := 'checkmain'
	Local aInit     := fInitWrite(oWs, cEntity)
	
	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		cCodBem := NGEscape( (cAliasQry)->TH_CODBEM )
		cServic := NGEscape( (cAliasQry)->TH_SERVICO )
		cSeque  := NGEscape( (cAliasQry)->TH_SEQRELA )
		cTare   := NGEscape( (cAliasQry)->TH_TAREFA )
		cCode   := NGEscape( (cAliasQry)->TH_ETAPA )

		If fCondDel(cAliasQry)
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"equipment":"' + cCodBem + '",'
			cSubJSON += '"service":"' + cServic + '",'
			cSubJSON += '"sequence":"' + cSeque + '",'
			cSubJSON += '"task":"' + cTare + '",'
			cSubJSON += '"code":"' + cCode + '"'
			cSubJSON += '}'

			fWriteJson(cSubJSON, nUpdate, oWs)

		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + cCodBem + "+" + cServic + "+" + cSeque + "+" + cTare + "+" + cCode + '"'

		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} NextIdentifier
Gera um nome de arquivo baseado nos caracteres ASCII em um tamanho
específico com o objetivo de obter um código único em um contexto
limitado.

@author Marcelo Camargo
@since  29/01/18
@param  nSize - Tamanho do identificador
@return Character, nome para arquivo
/*/
//---------------------------------------------------------------------
Static Function NextIdentifier( nSize )
	Local cIdentifier := FWTimeStamp(1) //data e hora
	Local nIndex
	For nIndex := 1 To nSize
		cIdentifier += Chr( Randomize( /* A */ 65, /* Z */ 90 ) )
	Next
Return Lower(cIdentifier)

//---------------------------------------------------------------------
/*/{Protheus.doc} fSaveImg
Faz upload da imagem vinda do webservice e grava no banco de
conhecimento fazendo referência à ordem de serviço.

@author Marcelo Camargo
@autor Maria Elisandra de Paula
@since 10/01/18
@param oSelf, objeto, objeto, instância do webservice
@param cItemCode, string, código da ordem de serviço or SS
@param cType, string, tipo da imagem: PROBLEM/SOLUTION/SIGNATURE
@param cTable, string, 'TQB' ou 'STJ'
@return array, [1] se obteve sucesso,
               [2] informações da imagem gravada ou descrição do erro
/*/
//---------------------------------------------------------------------
Static Function fSaveImg( oSelf, cItemCode, cType, cTable )

	Local cDtTime := DToC( Date() ) + ' ' + Time()
	Local cName   := ''
	Local cKeyAcb := ''
	Local aSave   := {}
	Local oResponse

	aSave := fSaveFile( oSelf, cTable, cItemCode, cType + ' ' + cDtTime, 'image', 'jpg' )
	If !aSave[1]
		Return aSave	
	EndIf

	cName   := aSave[2]
	cKeyAcb := aSave[3]

	oResponse := MntOrderAttachment():New( cKeyAcb )
	oResponse:Path     := '/picture/' + AllTrim( cName )
	oResponse:Date     := cDtTime
	oResponse:Type     := cType
	oResponse:FileName := cName

Return { .T., FWJsonSerialize( oResponse, .F. ) }

//---------------------------------------------------------------------
/*/{Protheus.doc} fCheckItem
Verifica se ordem/solicitação existe

@author Maria Elisandra de Paula
@since 12/07/2023
@param cItemCode, string, chave para pesquisa
@param cTable, string, tabela para busca

@return array [1]se está ok
			  [2]descrição do erro caso existir

/*/
//---------------------------------------------------------------------
Static Function fCheckItem( cItemCode, cTable )

	Local aRet       := {.T.}
	Local cError     := ''
	Local nCodeRest  := 0

	If cTable == 'STJ'
		// Garante existência da ordem de serviço
		dbSelectArea( 'STJ' )
		dbSetOrder( 1 )
		If dbSeek( FwxFilial( 'STJ' ) + cItemCode )
			If STJ->TJ_SITUACA == 'C'
				// Retorna mensagem de erro somente para o server com o código referente as alterações de uma O.S. já cancelada.
				cError    := 'Ordem de servico ja cancelada ' + cItemCode + '. ' + DtoC( dDataBase ) + ' ' + Time()
				nCodeRest := CANCELCODE
			ElseIf STJ->TJ_TERMINO == 'S'
				// Retorna mensagem de erro somente para o server com o código referente as alterações de uma O.S. já finalizada.
				cError    := 'Ordem de servico ja finalizada ' + cItemCode + '. ' + DtoC( dDataBase ) + ' ' + Time()
				nCodeRest := FINISHCODE
			EndIf
		Else
			cError := STR0024 // "Ordem de serviço não encontrada"
		EndIf

		If !Empty( cError )
			Return { .F., cError, , nCodeRest }
		EndIf		

	ElseIf !NGIFDBSEEK("TQB", cItemCode, 1)
		aRet := {.F., STR0145 } //"Solicitação não localizada."
		If !aRet[1]
			Return aRet
		EndIf
	EndIf

Return { .T., ''  }


//---------------------------------------------------------------------
/*/{Protheus.doc} fRecordBC
Gravação da tabela ACB e AC9

@author Maria Elisandra de Paula
@since 12/07/2023
@param cObject, string, nome do arqruivo-campo ACB_OBJETO
@param cDescri, string, conteúdo para campo ACB_DESCRI
@param cItemCode, string, código para campo AC9_CODENT
@param cTable, string, tabela para busca

@return string, chave ACB_CODOBJ
/*/
//---------------------------------------------------------------------
Static Function fRecordBC( cObject, cDescri, cItemCode, cTable )

	Local cFilEnt := FwxFilial( cTable )
	Local cKeyAcb := ''
	Local cCodEnt := ''

	dbSelectArea( 'ACB' )
	dbSetOrder( 2 ) // ACB_FILIAL + ACB_OBJETO
	If dbSeek( FwxFilial( 'ACB' ) + cObject )

		cKeyAcb := ACB->ACB_CODOBJ

	Else

		RecLock( 'ACB', .T. )
		cKeyAcb := GetSXEnum( 'ACB', 'ACB_CODOBJ' )
		ACB->ACB_FILIAL := FwxFilial( 'ACB' )
		ACB->ACB_CODOBJ := cKeyAcb
		ACB->ACB_OBJETO := cObject
		ACB->ACB_DESCRI := cDescri
		MsUnlock()
		ConfirmSX8()

	EndIf

	If cTable == 'STJ'
		cCodEnt := cItemCode
	Else
		cCodEnt := cFilEnt + cItemCode
	EndIf

	dbSelectArea( 'AC9' )
	dbSetOrder( 1 ) // AC9_FILIAL + AC9_CODOBJ + AC9_ENTIDA + AC9_FILENT + AC9_CODENT
	If !dbSeek( FwxFilial( 'AC9' ) + cKeyAcb + cTable + cFilEnt + cCodEnt )
		RecLock( 'AC9', .T. )
		AC9->AC9_FILIAL := FwxFilial( 'AC9' )
		AC9->AC9_FILENT := cFilEnt
		AC9->AC9_ENTIDA := cTable
		AC9->AC9_CODENT := cCodEnt
		AC9->AC9_CODOBJ := cKeyAcb
		MsUnlock()
	EndIf

Return cKeyAcb

//---------------------------------------------------------------------
/*/{Protheus.doc} DelOrderFile
Remove um arquivo do banco de conhecimento baseado no vínculo da AC9.
Remove o arquivo do repositório e deleta logicamente a entrada da ACB e
o vínculo da AC9.

@author Marcelo Camargo
@since  12/01/18
@param  cId, string, ID (código do objeto) da AC9
@param  oSelf, objeto, objeto, instância do webservice
@return array, [1] se obteve sucesso,
               [2] json ou descrição do erro
/*/
//---------------------------------------------------------------------
Static Function DelOrderFile( cId, oSelf )

	Local cAliasQry  := GetNextAlias()
	Local cMsDocPath := If(isSRVunix(), Lower(StrTran( MsDocPath(),'\', '/')),MsDocPath())
	Local cDocPath   := cMsDocPath + cBarra

	BeginSql Alias cAliasQry
		SELECT AC9_CODENT, ACB_OBJETO
		FROM %table:AC9% AC9
		INNER JOIN %table:ACB% ACB
			ON ACB_CODOBJ = AC9_CODOBJ
		WHERE
			AC9_FILIAL = %xFilial:AC9% AND
			AC9_FILENT = %xFilial:STJ% AND
			AC9_ENTIDA = 'STJ' AND
			AC9_CODOBJ = %Exp:cId% AND
			AC9.%NotDel% AND
			ACB.%NotDel%
	EndSql

	If Empty( ( cAliasQry )->AC9_CODENT )
		Return { .F., STR0069 } // "Não há ordem de serviço vinculada à imagem"
	EndIf

	// Remover vínculo de entidades (deleção lógica)
	dbSelectArea( 'AC9' )
	dbSetOrder( 2 ) // AC9_FILIAL + AC9_ENTIDA + AC9_FILENT + AC9_CODENT + AC9_CODOBJ
	If dbSeek( FwxFilial( 'AC9' ) + 'STJ' + FwxFilial( 'STJ' ) + ( cAliasQry )->AC9_CODENT + cId )
		RecLock( 'AC9', .F. )
		dbDelete()
		MsUnlock()
	EndIf

	// Remover registro textual do banco de objetos (deleção lógica)
	dbSelectArea( 'ACB' )
	dbSetOrder( 1 ) // ACB_FILIAL + ACB_CODOBJ
	If dbSeek( FwxFilial( 'ACB' ) + cId )
		RecLock( 'ACB', .F. )
		dbDelete()
		MsUnlock()
	EndIf

	// Remover arquivo físico do banco de conhecimento
	If File( cDocPath + ( cAliasQry )->ACB_OBJETO )
		FErase( cDocPath + ( cAliasQry )->ACB_OBJETO )
	EndIf

	( cAliasQry )->( dbCloseArea() )
Return { .T., '{}' }

//---------------------------------------------------------------------
/*/{Protheus.doc} fCreateImg
Grava imagem no Rpo de imagens

@author	Marcelo Camargo
@since 22/04/16
@obs refeito em 22/09/23

@param cKey, string, chave para busca
@param oSelf, objeto, classe de webservice
@param cTable, string, tabela para gravação de imagem
@return boolean, se obteve sucesso
/*/
//---------------------------------------------------------------------
Static Function fCreateImg( cKey, oSelf, cTable )

	Local cBitmap   := ''
	Local cFilePath := ''
	Local nRecno    := 0
	Local cObject   := ''
	Local lRet      := .F.
	Local aBinImg   := {}

	dbSelectArea( cTable )
	dbSetOrder( 1 )
	If ( lRet := dbSeek( FwxFilial( cTable ) + cKey ) )

		/*-----------------------------------------------------
		| Recupera o valor em base64 da imagem e decodifica-o |
		-----------------------------------------------------*/
		aBinImg := fGetFile( oSelf )

		If Empty( aBinImg[1] )

			nRecno  := Recno()

			/*---------------------------------------------
			| Busca conteúdo para o campo bitmap da tabela |
			----------------------------------------------*/
			cBitmap := fBitmap( cTable )

			/*--------------------------------------
			| Busca caminho para gravação de imagem |
			---------------------------------------*/
			cFilePath := fPathBC( 'tmp' + cBitmap )
			
			/*-----------------------------------------
			| Gera imagem temporária na pasta do banco |
			------------------------------------------*/
			lRet := fCTempImg( cFilePath, aBinImg[2] )

			If lRet

				/*---------------------------------
				| Grava imagem no PROTHEUS_REPOSIT|
				---------------------------------*/
				cObject := StartJob( 'InsertBitmap', GetEnvServer(), .T., cFilePath, cBitmap, cEmpAnt, cFilAnt )

				If !Empty( cObject )

					/*------------------------------------------------
					| Grava numero da imagem na tabela correspondente |
					-------------------------------------------------*/
					dbSelectArea(cTable)
					dbGoTo( nRecno )
					RecLock( cTable, .F. )

					If cTable == 'ST1'	
						
						ST1->T1_BITMAP := cObject

					Else

						ST9->T9_BITMAP := cObject

					EndIf

					MsUnlock()

				EndIf

				/*-------------------------
				| Deleta imagem temporária |
				--------------------------*/
				If File( cFilePath )
					fErase( cFilePath )
				EndIf

			EndIf

		EndIf

	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fEquiPic
Realiza o download da foto do Equipamento

@author	Larissa Thaís de Farias
@author Marcelo Camargo
@since	31/03/16
@param cEquipment, string, código do Equipamento
@param oSelf, objeto, classe de webservice
@return logic, se obteve sucesso
/*/
//---------------------------------------------------------------------
Static Function fEquiPic( cEquipment, oSelf )

	Local lRet      := .T.
	Local cBitmap   := ''
	Local cFilePath := ''

	dbSelectArea( 'ST9' )
	dbSetOrder( 1 )
	If dbSeek( FwxFilial( 'ST9' ) + Upper( cEquipment ) ) .And. !Empty( ST9->T9_BITMAP )
	
		cBitmap := AllTrim( ST9->T9_BITMAP )
		cFilePath := fPathBC( 'e' + cBitmap )

		/*------------------------------------------------------------------
		| Extrai a imagem para arquivo temporário e devolve envia resposta |
		------------------------------------------------------------------*/
		lRet := ExtractBitmap( cBitmap, cFilePath ) .And. fImage( oSelf, cFilePath )

		If File( cFilePath )
			fErase( cFilePath )
		EndIf

	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} createSO
Realiza a criação da OS

@author	Larissa Thaís de Farias
@author	Vitor Emanuel Batista
@author	Maria Elisandra de paula
@since 28/03/16
@param oWs, objeto, objeto que contém os dados da OS para a inclusão
@return array, [1]se obteve sucesso, [2]json para retorno
/*/
//---------------------------------------------------------------------
Static Function createSO( oWs )

	Local aArray     := {}
	Local aChecklist := {}
	Local oInputs    := {}
	Local aStartDate := {}
	Local aEndDate   := {}
	Local aRetSR     := {}
	Local oParser
	Local cError     := ""
	Local cType      := ""
	Local cObservation := ""
	Local aCounter   := {}	//armazena os dados referente a contadores
	Local cService   := ""
	Local cEquipment := ""
	Local cSequence  := ""
	Local cBemLoc  := "B"
	Local lSYP    := NGCADICBASE("TJ_MMSYP","A","STJ",.F.)
	Local cOrdem     := ""
	Local lRet := .T.
	Local nCounter1 := 0
	Local nCounter2 := 0
	Local cHour1    := ''
	Local cHour2    := ''
	Local cJson    := oWs:GetContent()
	Local dDtOrigin:= ctod("  /  /  ")
	Local cCode    := ""
	Local cPlan    := ""
	Local aOSGeradas:= {}
	Local aSSGeradas:= {}
	Local aRetEtapas:= {}
	Local aNoSTQ 	:= {}
	Local cUsaIntEs := SuperGetMv("MV_NGMNTES",.F.,"N")
	Local dMvUlmes  := SuperGetMv("MV_ULMES",.F.,Stod(""))
	Local dDtStopIni := Ctod(' / / ')
	Local cHrStopIni := ""
	Local dDtStopFin := Ctod(' / / ')
	Local cHrStopFin := ""
	Local xValue

	If FWJsonDeserialize(cJson,@oParser)

		//---------------------------------------------------------------------------
		// Trecho abaixo abre as tabelas para tratar msg "AJUSTAR PARAMETRO MV_DOCSEQ"
		//---------------------------------------------------------------------------

		If Select('SD1') <= 0
			dbSelectArea('SD1')
		EndIf
		If Select('SD2') <= 0
			dbSelectArea('SD2')
		EndIf
		If Select('SD3') <= 0
			dbSelectArea('SD3')
		EndIf

		If !AttIsMemberOf( oParser, "serviceRequest" )

			//------------------------------
			//Preenche os campos
			//------------------------------
			aStartDate   := StrTokArr(oParser:startDate, " ")
			cObservation := oParser:observation
			cService     := Upper(PADR(oParser:service,6))
			aEndDate     := StrTokArr(oParser:endDate, " ")
			cEquipment   := Upper(PADR(oParser:equipment,16))
			aChecklist   := oParser:checklist
			oInputs      := oParser:inputs
			dDtOrigin    := StoD(aStartDate[1])
			cSequence    := IIf( AttIsMemberOf( oParser, 'sequence' ), PadR( oParser:sequence, 3 ), '000' )

			If AttIsMemberOf( oParser, 'type' )
				cType := oParser:type
			ElseIf Trim( cSequence ) == '000' .Or. Trim( cSequence ) == '0' 
				cType := 'C'
			Else
				cType := 'P'
			EndIf

			If !Empty(cError)
				Return {.f.,cError}
			EndIf

			If !AttIsMemberOf( oParser, "location" )

				// Valida se o equipamento não encontra-se inativo desde a ultima sincronização.
				If !fcheckEquip( cEquipment, @cError )
					Return { .F., cError }
				EndIf

				// Valida se a manutenção encontra-se inativa desde a ultima sincronização.
				If cType == 'P' .And. !fcheckMain( cEquipment, cService, cSequence, @cError )
					Return { .F., cError }
				EndIf

			Else

				//----------------------------------------------------------
				// Validação do Tipo de OS quando Localização
				//----------------------------------------------------------
				If cType == "P"
					Return { .F., STR0172 } // "Não é possível abrir ordens de serviço preventivas para localizações."
				EndIf

				cBemLoc := "L"

			EndIf

			If cUsaIntEs == "S" .And. dDtOrigin <= dMvUlmes
				Return { .f., STR0085 + " " + Dtoc( dMvUlmes ) } //"A data da ordem de serviço não pode ser menor ou igual a data do último fechamento do estoque "
			EndIf

			//------------------------------------------
			//Atualiza informações de contador da ordem
			//------------------------------------------
			If AttIsMemberOf( oParser, "counter" ) .And. Len( aCounter := oParser:counter ) > 0

				If AttIsMemberOf( aCounter[1], "value" ) .And. ( nCounter1 := aCounter[1]:value ) > 0

					If AttIsMemberOf( aCounter[1], "time" )
						cHour1 := aCounter[1]:time
					ElseIf AttIsMemberOf( aCounter[1], "datetime" ) //Para atender versões antigas do app
						cHour1 := StrTokArr(aCounter[1]:datetime," ")[2]
					EndIf

				EndIf

				//segundo contador da ordem
				If Len( aCounter ) > 1 .And. AttIsMemberOf( aCounter[2], "value" ) ;
					.And. ( nCounter2 := aCounter[2]:value ) > 0

					If AttIsMemberOf( aCounter[2], "time" )
						cHour2 := aCounter[2]:time
					ElseIf AttIsMemberOf( aCounter[2], "datetime" )//Para atender versões antigas do app
						cHour2 := StrTokArr(aCounter[2]:datetime," ")[2]
					EndIf

				EndIf

			EndIf

			If Empty(cObservation)
				cObservation := ""
			EndIf

			//------------------------------------------
			// Informações de parada de equipamento
			//------------------------------------------
			If AttIsMemberOf( oParser, "downTime" )
				xValue := StrTokArr( oParser:downTime, " " )
				If !Empty( xValue[1] ) .And. !Empty( xValue[2] )
					dDtStopIni := Stod( xValue[1] )
					cHrStopIni := xValue[2]
				EndIf
			EndIf

			If AttIsMemberOf( oParser, "upTime" )
				xValue := StrTokArr( oParser:upTime, " " )
				If !Empty( xValue[1] ) .And. !Empty( xValue[2] )
					dDtStopFin := Stod( xValue[1] )
					cHrStopFin := xValue[2]
				EndIf
			EndIf

			//----------------------------------------------------------
			// Validação das datas de parada
			//----------------------------------------------------------
			If !Empty( dDtStopIni ) .And. !Empty( cHrStopIni ) .And. ;
				!Empty( dDtStopFin ) .And. !Empty( cHrStopFin ) .And. ;
				Dtos( dDtStopIni ) + cHrStopIni > Dtos( dDtStopFin ) + cHrStopFin

				cError := STR0160 // "A data e hora fim de parada não pode ser menor que a data e hora inicial."

			EndIf

			If !Empty(cError)
				Return { .f. ,cError}
			EndIf

			// Inicializa array aInputs contendo os insumos previstos e realizados.
			cError := getInputs( oInputs, , , cEquipment )

			If !Empty(cError)
				Return { .f. ,cError}
			EndIf

			cError := getCheckList( aChecklist, , , cType, cEquipment, cService, cSequence )
			If !Empty(cError)
				Return { .f. , cError}
			EndIf

			//Verifica se a OS já foi criada e não houve a atualização com o Mobile por queda de conexão
			printf("Verificando se ordem de servico ja existe. ")
			cOrdem :=  fEqualOrder( aStartDate, cObservation, nCounter1, nCounter2, cService,;
									aEndDate, cEquipment, cSequence, cType, dDtStopIni, cHrStopIni )

			If Empty(cOrdem)
				printf("Validando a ordem de servico. ")
				cError := fValidIns("","", 3)
				If !Empty(cError)
					Return { .f. , cError}
				EndIf

				//Ponto de entrada para validações antes da inclusão da ordem de serviço
				If Empty( cError ) .And. lPeMntNg
					cError := ExecBlock( 'MNTNG', .F., .F., { 'CREATE_VALID_ORDER', oWs } )
				EndIf

				If !Empty(cError)
					Return { .f. , cError }
				EndIf

				//----------------------------------
				//Valida contadores da ordem
				//----------------------------------
				If nCounter1 > 0 .And. !Empty( cHour1 )
					cError := ValidCounter( cEquipment, nCounter1, dDtOrigin, cHour1, 1 )
				EndIf

				If Empty( cError ) .And. nCounter2 > 0 .And. !Empty( cHour2 )
					cError := ValidCounter( cEquipment, nCounter2, dDtOrigin, cHour2, 2 )
				EndIf

				//----------------------------------
				// Aplica contadores da ordem
				//----------------------------------
				If Empty( cError )

					If nCounter1 > 0 .And. !Empty( cHour1 )
						NGTRETCON( cEquipment, dDtOrigin, nCounter1, cHour1, 1 )
					EndIf

					If nCounter2 > 0 .And. !Empty( cHour2 )
						NGTRETCON( cEquipment, dDtOrigin, nCounter2, cHour2, 2 )
					EndIf

				EndIf

				If !Empty(cError)
					Return { .f. , cError }
				EndIf

				printf("Incluindo ordem de servico. ")

				//------------------------------
				// Gera a O.S
				//------------------------------
				aArray := NGGERAOS(cType,dDtOrigin,cEquipment,cService,cSequence,"S","S","S",,"L",.F.,.F.,,cBemLoc)

				//------------------------------
				//Verifica se a O.S foi aberta com sucesso
				//------------------------------
				If aArray[1][1] == "S"

					dbSelectArea("STJ")
					dbSetOrder(1)
					If dbSeek(FwxFilial("STJ")+aArray[1][3])

						cCode := STJ->TJ_ORDEM
						cPlan := STJ->TJ_PLANO

						//------------------------------
						//Preenche as informações enviadas que não foram inseridas na abertura da O.S
						//------------------------------
						RecLock("STJ",.F.)
						If !Empty(cObservation)
							If lSYP
								MsMM(STJ->TJ_MMSYP,80,,cObservation,1,,,"STJ","TJ_MMSYP")
							Else
								STJ->TJ_OBSERVA := cObservation
							EndIf
						EndIf

						//----------------------------------------------------------
						//Grava campos de contadores de acordo com o envio do app
						//----------------------------------------------------------

						STJ->TJ_CONTINI := nCounter1
						STJ->TJ_POSCONT := nCounter1
						STJ->TJ_HORACO1 := cHour1
						STJ->TJ_POSCON2 := nCounter2
						STJ->TJ_HORACO2 := cHour2
						STJ->TJ_USUAINI := cUserName

						//----------------------------------------------------------
						// Grava campos de parada de acordo com o envio do app
						//----------------------------------------------------------
						If !Empty( dDtStopIni ) .And. !Empty( cHrStopIni )
							STJ->TJ_DTPRINI := dDtStopIni
							STJ->TJ_HOPRINI := cHrStopIni
						EndIf

						If !Empty( dDtStopFin ) .And. !Empty( cHrStopFin )
							STJ->TJ_DTPRFIM := dDtStopFin
							STJ->TJ_HOPRFIM := cHrStopFin
						EndIf

						STJ->(MsUnlock())

						If Empty(cError)
							printf(" Verificando a existencia de insumos previstos ")
							cError := InputSTLPrev(aArray[1][3], cType, .f. , oWS)
							printf(" Termino da verificacao de insumos previstos ")
						EndIf

						//------------------------------
						//Insere os insumos e etapas
						//------------------------------
						If Empty(cError)
							printf(" Verificando a existencia de insumos realizados ")
							cError := MNTNGInput( 1, aArray[1][3], cType )
							printf(" Termino da verificacao de insumos realizados ")
						EndIf

						If Empty(cError)
							printf(" Verificando etapas ")
							aRetEtapas := InputSTQ(cCode, cPlan )
							cError     := aRetEtapas[1]
							aOSGeradas := aRetEtapas[2]
							aSSGeradas := aRetEtapas[3]
							aNoSTQ     := aRetEtapas[4]
							printf(" Termino da verificacao etapas ")
						EndIf

						If Empty( cError )
							//atualiza data e hora prevista da ordem de serviço
							UpdDatesStj( cCode,;
									cPlan,;
									Stod( aStartDate[1] ),;
									aStartDate[2],;
									Stod(aEndDate[1]),;
									aEndDate[2] )
						EndIf

						If !Empty(cError)
							return { .F., cError }
						EndIf
					EndIf

				Else
					cError := aArray[1][2]
				EndIf

				If Empty(cError)
					cOrdem := cCode
					printf("Ordem de servico incluida com sucesso (" + cOrdem + ")" )
				EndIf
			Else
				printf("Ordem de serviço ja existe (" + cOrdem + ").")
			EndIf
		Else
			//--------------------------------------------------------------------
			// Realiza a abertura de ordem de serviço vinculada a uma solicitação
			//--------------------------------------------------------------------
			aRetSR := NGUpsertSR( oWS, "order" , oParser:serviceRequest )
			If !aRetSR[1]
				cError := aRetSR[2]
			ElseIf NGIFDBSEEK( "STJ", aRetSR[2], 1 )
				cOrdem := STJ->TJ_ORDEM
				cPlan := STJ->TJ_PLANO
			EndIf
		EndIf
	Else
		If !FWJsonDeserialize(cJson,@oParser)
			cError := STR0022 // "Json inválido."
		Else
			cError := STR0023 // "Ocorreu um problema ao gerar a ordem de serviço."
		EndIf
	EndIf

	If Empty(cError)

		If lPeMntNg
			ExecBlock("MNTNG",.F.,.F.,{ "CREATED_ORDER", oWs })
		EndIf

		cJson := JSONResult( '{"code":"' + cOrdem + '", "plan":"' + cPlan + '",' + ;
					'"message":[' + fMessage( aOSGeradas, aSSGeradas, aNoSTQ ) + ']}' )
	Else
		cJson := cError
		lRet := .F.
		printf("Erro na criação da OS :"  + cJson)

	EndIf
Return { lRet, cJson }

//---------------------------------------------------------------------
/*/{Protheus.doc} updateSO
Realiza a atualização da OS

@author	Larissa Thaís de Farias
@author	Vitor Emanuel Batista
@author	Maria Elisandra de Paula
@since	29/03/2016
@param cJson, objeto, body da requisição (getcontent)
@param oWs, objeto, objeto com o JSON que contém os dados da OS para a alteração
@return array,  [1] se obteve sucesso, [2] json para retorno, [3] respostas não geradas
				[4] Código de erro MNTNG.
/*/
//---------------------------------------------------------------------
Static Function updateSO( cJson , oWs )

	Local oParser
	Local cError := ""
	Local cCode, cPlan, cType, cObservation
	Local nCodeRest := 0

	Local aStartDate, aEndDate, aChecklist
	Local oInputs
	Local lSYP    := NGCADICBASE("TJ_MMSYP","A","STJ",.F.)
	Local lRet := .T.
	Local lSTJ := .F.
	Local lSTLPrev:= .F.
	Local lSTLRea := .F.
	Local lSTQ    := .F.
	Local aOSGeradas := {}
	Local aSSGeradas := {}
	Local aRetEtapas := {}
	Local aNoSTQ     := {}
	Local dDtStopIni := Ctod(' / / ')
	Local cHrStopIni := ""
	Local dDtStopFin := Ctod(' / / ')
	Local cHrStopFin := ""
	Local xValue

	Private aGETINS  := {}
	Private lAltera := .t.

	If !Empty(cJson) .and. FWJsonDeserialize(cJson,@oParser)

		//---------------------------------------------------------------------------
		// FAVOR NÃO RETIRAR DO FONTE
		// Este trecho realiza a abertura das tabelas para que a função ProxNum()
		// possa funcionar corretamente no mntutil durante a criação de bloqueios
		// de produto e mão de obra.
		// Caso seja retirado, será desencadeado o erro:
		// "AJUSTAR PARAMETRO MV_DOCSEQ"
		// na segunda execução do fonte
		//---------------------------------------------------------------------------

		If Select('SD1') <= 0
			dbSelectArea('SD1')
		EndIf
		If Select('SD2') <= 0
			dbSelectArea('SD2')
		EndIf
		If Select('SD3') <= 0
			dbSelectArea('SD3')
		EndIf

		//----------------------------------------------
		//Preenche os campos
		//----------------------------------------------
		aStartDate   := StrTokArr(oParser:startDate, " ")
		cObservation := oParser:observation
		aEndDate     := StrTokArr(oParser:endDate, " ")
		aChecklist   := oParser:checklist
		oInputs      := oParser:inputs
		cType        := oParser:type
		cCode        := oParser:code
		cPlan        := oParser:plan

		dbSelectArea("STJ")
		dbSetOrder(1)
		If dbSeek( FwxFilial("STJ") + cCode + cPlan )
			If STJ->TJ_SITUACA == 'C'
				// Retorna mensagem de erro somente para o server com o código referente as alterações de uma O.S. já cancelada.
				cError    := 'Ordem de servico ja cancelada ' + cCode + '. ' + DtoC( dDataBase ) + ' ' + Time()
				nCodeRest := CANCELCODE
			ElseIf STJ->TJ_TERMINO == 'S'
				// Retorna mensagem de erro somente para o server com o código referente as alterações de uma O.S. já finalizada.
				cError    := 'Ordem de servico ja finalizada ' + cCode + '. ' + DtoC( dDataBase ) + ' ' + Time()
				nCodeRest := FINISHCODE
			EndIf
		Else
			// Ordem de serviço não encontrada
			cError := STR0024
		EndIf

		If !Empty( cError )
			Return { .F., cError, aNoSTQ, nCodeRest }
		EndIf

		cEquipment := STJ->TJ_CODBEM
		cService   := STJ->TJ_SERVICO
		cSequence  := STJ->TJ_SEQRELA

		//------------------------------------------
		// Informações de parada de equipamento
		//------------------------------------------
		If AttIsMemberOf( oParser, "downTime" )
			xValue := StrTokArr( oParser:downTime, " " )
			If !Empty( xValue[1] ) .And. !Empty( xValue[2] )
				dDtStopIni := Stod( xValue[1] )
				cHrStopIni := xValue[2]
			EndIf
			xValue := Nil
		EndIf

		If AttIsMemberOf( oParser, "upTime" )
			xValue := StrTokArr( oParser:upTime, " " )
			If !Empty( xValue[1] ) .And. !Empty( xValue[2] )
				dDtStopFin := Stod( xValue[1] )
				cHrStopFin := xValue[2]
			EndIf
			xValue := Nil
		EndIf

		printf( 'Inicio do processo de atualizacao da O.S. ' + cCode)

		// Inicializa array aInputs contendo os insumos previstos e realizados.
		cError := getInputs( oInputs, cCode, cPlan, cEquipment, .T. )

		If !Empty(cError)
			Return { .F., cError, aNoSTQ }
		EndIf

		printf( ' Realizando validacao dos insumos' )
		cError := fValidIns( cCode, cPlan, 4 )

		If !Empty(cError)
			Return { .f. , cError, aNoSTQ }
		EndIf

		cError := getCheckList( aChecklist, cCode, cPlan, cType, cEquipment, cService, cSequence )
		If !Empty(cError)
			Return { .f. , cError, aNoSTQ }
		EndIf

		//Ponto de entrada para validações antes da alteração da ordem de serviço
		If Empty( cError ) .And. lPeMntNg
			cError := ExecBlock( 'MNTNG', .F., .F., { 'UPDATE_VALID_ORDER', oWs } )
		EndIf

		If !Empty(cError)
			Return { .f. , cError }
		EndIf

		printf(" Avaliando necessidade de modificacao na O.S. ")
		aUpdated := SoUpdated( aChecklist, cCode, cPlan, aStartDate, aEndDate, cObservation,;
								 dDtStopIni, cHrStopIni, dDtStopFin, cHrStopFin )

		lSTJ     := aUpdated[1] // Indica se STJ já está atualizada
		lSTLPrev := aUpdated[2] // Indica se insumos preventivos já estão atualizados
		lSTLRea  := aUpdated[3] // Indica se insumos realizados já estão atualizaodos
		lSTQ     := aUpdated[4] // Indica se etapas já estão atualizadas

		If !lSTJ

			dbSelectArea("STJ")
			dbSetOrder(1)
			If dbSeek(FwxFilial("STJ")+cCode+cPlan)

				//----------------------------------------------------------
				// Validação caso alteração na data e hora inicio de parada
				//----------------------------------------------------------
				If !Empty( dDtStopIni ) .And. !Empty( cHrStopIni ) .And. ;
					!Empty( dDtStopFin ) .And. !Empty( cHrStopFin ) .And. ;
					Dtos( dDtStopIni ) + cHrStopIni > Dtos( dDtStopFin ) + cHrStopFin

					cError := STR0160 // "A data e hora fim de parada não pode ser maior que a data e hora inicial."

				EndIf

				If !Empty( cError )
					Return { .f. , cError }
				EndIf

				printf(" Inicio da alteracao da ordem de servico ")
				//------------------------------
				//Preenche as informações enviadas que não foram inseridas na abertura da O.S
				//------------------------------
				RecLock("STJ",.F.)
				If !Empty(cObservation)
					If lSYP
						MsMM(STJ->TJ_MMSYP,80,,cObservation,1,,,"STJ","TJ_MMSYP")
					Else
						STJ->TJ_OBSERVA := cObservation
					EndIf
				EndIf

				//----------------------------------------------------------
				// Grava campos de parada de acordo com o envio do app
				//----------------------------------------------------------
				STJ->TJ_DTPRINI := dDtStopIni
				STJ->TJ_HOPRINI := cHrStopIni
				STJ->TJ_DTPRFIM := dDtStopFin
				STJ->TJ_HOPRFIM := cHrStopFin

				STJ->(MsUnlock())
			Else
				cError := STR0024 // "Ordem de serviço não encontrada."
			EndIf
		EndIf

		If !lSTLPrev .And. Empty(cError)
			printf(" Inicio das alteracoes dos insumos previstos ")
			cError := InputSTLPrev(cCode, cType, .t. ,oWs )
			printf(" Termino das alteracoes dos insumos previstos ")
		EndIf

		If !lSTLRea .And. Empty(cError)
			printf( ' Inicio das alteracoes dos insumos realizados ' )
			cError := MNTNGInput( 1, cCode, cType )
			printf( ' Termino das alteracoes dos insumos realizados ' )
		EndIf

		If !lSTQ .And. Empty(cError)

			//------------------------------
			//Deleta e/ou insere as etapas
			//------------------------------
			printf(" Inicio das alteracoes de etapas ")
			aRetEtapas := InputSTQ(Padr(cCode,TamSx3("TJ_ORDEM")[1]), Padr(cPlan,TamSx3("TJ_PLANO")[1]))
			cError     := aRetEtapas[1]
			aOSGeradas := aRetEtapas[2]
			aSSGeradas := aRetEtapas[3]
			aNoSTQ     := aRetEtapas[4]
			printf(" Termino da verificacao etapas ")
		EndIf

		If Empty(cError)
			UpdDatesStj( cCode,;
					cPlan,;
					STOD(aStartDate[1]),;
					aStartDate[2],;
					STOD(aEndDate[1]),;
					aEndDate[2] )
		Else
			printf("Ocorreu um problema ao atualizar a ordem de servico.")
		EndIf
	Else
		cError := STR0022 // "Json inválido."
	EndIf

	If Empty(cError)

		cJson := JSONResult( '{"code":"' + cCode + '", "plan":"' + cPlan + '",' + ;
					'"message":[' + fMessage( aOSGeradas, aSSGeradas, aNoSTQ ) + ']}' )

		If lSTJ .And. lSTLPrev .And. lSTLRea .And. lSTQ
			printf( "Nao houve modificacoes na OS " + cCode )
		Else
			printf("Fim da atualizacao de OS. "  )
		EndIf
	Else
		cJson := cError
		lRet := .F.
		printf("Erro na atualizacao de OS. " + cError )
	EndIf

Return {lRet, cJson, aNoSTQ}

//---------------------------------------------------------------------
/*/{Protheus.doc} SoUpdated
Indica se houve algum tipo de alteração na ordem de serviço

@author	Larissa Thaís de Farias
@since 02/2016

@param aChecklist, array, etapas da ordem de serviço
@param cCode, string, código da OS para finalização
@param cPlan, string, plano da OS
@param aStartDate, array, data e hora da ordem de serviço
@param cObservation, string, observação da ordem de serviço
@param aEndDate, array, data e hora fim da ordem de serviço
@param dDtStopIni, date, data real parada inicio
@param cHrStopIni, string, hora real parada inicio
@param dDtStopFin, date, data real parada fim
@param cHrStopFin, string, hora real parada fim

@return array, [1] indica se a STJ está atualizada(não precisa de alteração)
               [2] indica se insumos previstos estão atualizados (não precisam de alteração)
			   [3] indica se insumos realizados estão atualizados (não precisam de alteração)
			   [4] indica se etapas estão atualizadas (não precisam de alteração)
/*/
//---------------------------------------------------------------------
Static Function SoUpdated( aChecklist, cCode, cPlan, aStartDate, aEndDate, cObservation,;
							dDtStopIni, cHrStopIni, dDtStopFin, cHrStopFin )

	Local lSTJ     := .F.
	Local lSTLPrev := .F.
	Local lSTLRea  := .F.
	Local lSTQ     := .F.

	dbSelectArea("STJ")
	dbSetOrder(1)
	If dbSeek(FwxFilial("STJ")+cCode+cPlan)

		lSTJ := STOD(aStartDate[1]) == STJ->TJ_DTMPINI .And. aStartDate[2] == STJ->TJ_HOMPINI .And. ;
				Alltrim( cObservation ) == Alltrim( STJ->TJ_OBSERVA ) .And. STOD(aEndDate[1]) == STJ->TJ_DTMPFIM .And. ;
				aEndDate[2] == STJ->TJ_HOMPFIM .And. dDtStopIni == STJ->TJ_DTPRINI .And. cHrStopIni == STJ->TJ_HOPRINI;
				.And. dDtStopFin == STJ->TJ_DTPRFIM .And. cHrStopFin == STJ->TJ_HOPRFIM

		// Insumos Realizados
		lSTLRea  := Empty( aInputs[_REALIZED_,_INSERT_] ) .And. Empty( aInputs[_REALIZED_,_UPDATE_] ) .And.;
			Empty( aInputs[_REALIZED_,_DELETE_] )

		// Insumos Previstos
		lSTLPrev := Empty( aInputs[_FORESEEN_,_INSERT_] ) .And. Empty( aInputs[_FORESEEN_,_UPDATE_] ) .And.;
			Empty( aInputs[_FORESEEN_,_DELETE_] )

		lSTQ := Empty( aEtapas[_UPDATE_] ) .And.;
				Empty( aEtapas[_INSERT_] ) .And.;
				Empty( aEtapas[_DELETE_] )

	EndIf

Return { lSTJ, lSTLPrev, lSTLRea, lSTQ }

//---------------------------------------------------------------------
/*/{Protheus.doc} finishSO
Realiza a finalização da OS

@author	Larissa Thaís de Farias
@author	Vitor Emanuel Batista
@since 02/2016
@param oWs, objeto, objeto com o JSON que contém os dados para a finalização
@return array,  [1]se obteve sucesso, [2]json para retorno [3] Etapas não geradas
				[4] Código de erro MNTNG.
/*/
//---------------------------------------------------------------------
Static Function finishSO( oWs )

	Local lRet      := .F.
	Local cError    := ""
	Local nI        := 0
	Local nCodeRest := 0
	Local aNoSTQ    := {}
	Local aJson     := {}
	Local lSemIns   := .F.
	Local oParser
	Local cCode
	Local cPlan
	Local cJson

	If FWJsonDeserialize( oWs:GetContent(), @oParser )

		cCode := oParser:order
		cPlan := oParser:plan
		cJson := oParser:json

		//quando a ordem já está finalizada e ainda há uma tentativa de finalizar: não faz nenhuma operação e retorna .t.
		dbSelectArea("STJ")
		dbSetOrder(1)
		If dbSeek(FwxFilial("STJ") + cCode + cPlan )
			If STJ->TJ_SITUACA == 'C'
				// Retorna mensagem de erro somente para o server com o código referente as alterações de uma O.S. já cancelada.
				cError    := 'Ordem de servico ja cancelada ' + cCode + '. ' + DtoC( dDataBase ) + ' ' + Time()
				nCodeRest := CANCELCODE
			ElseIf STJ->TJ_TERMINO == 'S'
				// Retorna mensagem de erro somente para o server com o código referente as alterações de uma O.S. já finalizada.
				cError    := 'Ordem de servico ja finalizada ' + cCode + '. ' + DtoC( dDataBase ) + ' ' + Time()
				nCodeRest := FINISHCODE
			EndIf
			If !Empty( cError )
				Return { .F., cError, aNoSTQ, nCodeRest }
			EndIf
		EndIf

		aJson	:= updateSO( cJson , oWs )
		lRet 	:= aJson[1]
		cJson	:= aJson[2]
		aNoSTQ	:= aJson[3]
		MsUnlockAll()
	Else
		lRet := .F.
		cJson := STR0022 // "Json inválido."
	EndIf

	//-------------------------------------------------------------
	// O array aNoSTQ recupera as etapas que não foram geradas
	// por haver uma resposta com ação que geraria uma os preventiva
	// com mais de uma sequência cadastrada
	//-------------------------------------------------------------

	If lRet .And. Len( aNoSTQ ) > 0

		cError := STR0063 + Space(1) + cCode + Space(1) //"A ordem de serviço" #
		cError += STR0077 + Space(1) //"foi atualizada, mas não pode ser finalizada."
		cError += STR0078 + "," + Space(1) //"Houve a necessidade de gerar Ordem(s) Preventiva(s) a partir da Resposta da Etapa"
		cError += STR0079 + CRLF  //"porém a manutenção cadastrada possui mais de uma sequência."

		For nI := 1 to Len( aNoSTQ )
			cError += STR0074  + Space(1) + Alltrim(aNoSTQ[nI][1]) + "," //"Tarefa"
			cError += STR0075  + Space(1) + Alltrim(aNoSTQ[nI][2]) + "," //"Etapa"
			cError += STR0076  + Space(1) + Alltrim(aNoSTQ[nI][3]) + CRLF //"Opção"
		Next nI

		cJson := cError

		lRet := .F.
	EndIf

	If lRet

		dbSelectArea("STJ")
		dbSetOrder(1)
		If dbSeek(FwxFilial("STJ") + cCode + cPlan )

			//+-------------------------------------------------------------------+
			//| Ponto de entrada que indica se a O.S 							  |
			//| podera ser finalizada sem insumos    							  |
			//+-------------------------------------------------------------------+
			If ExistBlock( 'NGSEMINS' )

				lSemIns := ExecBlock( 'NGSEMINS', .F., .F. )

			EndIf

			cError := ""

			//Verifica se tem pelo menos um insumo realizado
			If lSemIns .Or. verifyInput(cCode, cPlan)

				//----------------------------------------------
				//Realiza outras validações e finaliza a ordem
				//----------------------------------------------
				cError := finish( oWs, cCode, cPlan )

			Else
				cError := STR0063 + " " + cCode + " " + STR0064//"A ordem de serviço" # "não pode ser finalizada pois não existe insumo realizado."
			EndIf
		EndIf
	Else
		cError := cJson
	EndIf

	If !Empty( cError )
		cJson := cError
		lRet  := .f.
	Else
		printf("Finalizacao completa. " + DTOC(dDataBase) + " " + Time())
	EndIf

Return {lRet, cJson}

//---------------------------------------------------------------------
/*/{Protheus.doc} finish
Realiza a finalização da OS

@author	Larissa Thaís de Farias
@since 02/2016
@param oWs, objeto, web service
@param cCode, caracter, código da ordem
@param cPlan, caracter, plano
@return string, vazio ou descrição do erro caso exista
/*/
//---------------------------------------------------------------------
Static Function finish( oWs, cCode, cPlan )

	Local cError     := ""
	Local cTENDFLAHA := SuperGetMV("MV_NGTNDFL",.F.,"S")
	Local cObsFim    := ""
	Local cFault     := ""
	Local aAuxiliar  := {}
	Local dDtMRFim   := Ctod( ' / / ')
	Local cHoMRFim   := ''
	Local dDtMRIni   := Ctod( ' / / ')
	Local cHoMRIni   := ''
	Local nCounter1  := 0
	Local nCounter2  := 0
	Local cHour1     := ""
	Local cHour2     := ""
	Local cDadCode   := ''
	Local oCounter
	Local oParser
	Local dDtStopIni := Ctod( ' / / ' )
	Local dDtStopFin := Ctod( ' / / ' )
	Local cHrStopIni := ""
	Local cHrStopFin := ""
	Local lShowField := .T.
	Local xValue

	Private cNGERROR := ""

	FWJsonDeserialize( oWs:GetContent(), @oParser )

	If lPeMntNg

		// P.E. que permite manipulação das informações enviadas para finalização da O.S.
		xValue := ExecBlock( 'MNTNG', .F., .F., { 'UPDATE_FINISH_ORDER', oParser } )

		If ValType( xValue ) == 'O'
			oParser := xValue
		EndIf

	EndIf

	If AttIsMemberOf( oParser, "observation" )
		cObsFim := oParser:observation
	EndIf

	If AttIsMemberOf( oParser, "fault" )
		cFault := oParser:fault
	EndIf

	//Data real Inicio
	If AttIsMemberOf( oParser, "startDate" )
		aAuxiliar := StrTokArr( oParser:startDate, " " )
		dDtMRIni  := Stod( aAuxiliar[1] )
		cHoMRIni  := aAuxiliar[2]
	EndIf

	//Data real fim
	If AttIsMemberOf( oParser, "endDate" )
		aAuxiliar := StrTokArr( oParser:endDate, " " )
		dDtMRFim  := Stod( aAuxiliar[1] )
		cHoMRFim  := aAuxiliar[2]
	EndIf

	//Informações de contador
	If AttIsMemberOf( oParser, 'counter' ) .And. Len( oCounter := oParser:counter ) > 0

		nCounter1 := oCounter[1]:value //Valor do primeiro contador

		If nCounter1 > 0

			If AttIsMemberOf( oCounter[1], "time" )
				cHour1 := oCounter[1]:time //hora do primeiro contador
			ElseIf AttIsMemberOf( oCounter[1], "datetime" )
				cHour1 := StrTokArr(oCounter[1]:datetime," ")[2] //hora do primeiro contador - app com versão antiga
			EndIf

		EndIf

		If Len( oCounter ) == 2

			nCounter2 := oCounter[2]:value //Valor do segundo contador

			If nCounter2 > 0

				If AttIsMemberOf( oCounter[2], "time" )
					cHour2 := oCounter[2]:time //hora do segundo contador
				ElseIf AttIsMemberOf( oCounter[2], "datetime" )
					cHour2 := StrTokArr(oCounter[2]:datetime," ")[2] //hora do segundo contador - app com versão antiga
				EndIf

			EndIf

		EndIf

	Else

		// Campo contador não foi apresentado no app MNTNG.
		lShowField := .F.

		dbSelectArea( 'ST9' )
		dbSetOrder( 1 )
		If dbSeek( FwxFilial( 'ST9' ) + STJ->TJ_CODBEM ) .And. ST9->T9_TEMCONT $ 'P#I'

			nCounter1 := NGACUMEHIS( STJ->TJ_CODBEM, dDtMRFim, cHoMRFim, 1, 'E' )[1]
			cHour1    := cHoMRFim

			// Inicializa váriaveis para contador 2, caso o equipamento possua.
			If MNTCont2( FwxFilial( 'TPE' ), STJ->TJ_CODBEM, .T. )

				nCounter2 := NGACUMEHIS( STJ->TJ_CODBEM, dDtMRFim, cHoMRFim, 2, 'E' )[1]
				cHour2    := cHoMRFim

			EndIf

		EndIf

	EndIf

	// Define o código do pai para o equipamento relacionado a O.S. para reporte de contador em estrutura.
	cDadCode := NGTBEMPAI( STJ->TJ_CODBEM, STJ->TJ_CODBEM )

	//------------------------------------------
	// Informações de parada de equipamento
	//------------------------------------------
	If AttIsMemberOf( oParser, "downTime" ) .And. AttIsMemberOf( oParser, "upTime" )

		xValue := StrTokArr( oParser:downTime, " " )
		If !Empty( xValue[1] ) .And. !Empty( xValue[2] )
			dDtStopIni := Stod( xValue[1] )
			cHrStopIni := xValue[2]
		EndIf

		xValue := StrTokArr( oParser:upTime, " " )
		If !Empty( xValue[1] ) .And. !Empty( xValue[2] )
			dDtStopFin := Stod( xValue[1] )
			cHrStopFin := xValue[2]
		EndIf

	EndIf

	printf(" Validacoes para finalizar OS " + cCode + ". " + DTOC(dDataBase) + " " + Time())

	//campo irregularidade somente será obrigatório quando parâmetro estiver definido
	If cTENDFLAHA <> "N" .and. cPlan == "000000"
		If cTENDFLAHA == "S" .And. Empty(cFault)
			cError := STR0065 //"É obrigatório definir uma irregularidade."
		EndIf

		dbSelectArea( "TP7" )
		dbSetOrder( 1 )
		If Empty ( cError ) .and. !Empty( cFault ) .and. !dbSeek( FwxFilial( "TP7" ) + cFault )
			cError := STR0026 //"Irregularidade não cadastrada no Protheus, favor sincronizar os dados novamente."
		EndIf
	EndIf

	//-------------------------------------------------------
	//Verifica obrigatoriedade de resposta das etapas e executante
	//-------------------------------------------------------
	If Empty(cError) .And. !NGRESPETAEX(cCode,.f.)[1]
		cError := STR0066 + " " + cCode //"Existe(m) etapa(s) sem resposta(s) e/ou sem o executante para a ordem de serviço:"
	EndIf

	//-----------------------------------
	// Validações de contador
	//-----------------------------------
	If Empty( cError )
		cError := CounterFinish( cDadCode, nCounter1, cHour1, nCounter2, cHour2, dDtMRFim, oWS, lShowField )
	EndIf

	//----------------------------------------------
	// Validações de data e hora manutenção
	//----------------------------------------------
	If Empty( cError )
		cError := fDateValid( dDtMRIni, cHoMRIni, dDtMRFim, cHoMRFim )
	EndIf

	//----------------------------------------------
	// Validações de data e hora parada equipamento
	//----------------------------------------------
	If Empty( cError )

		If Dtos( dDtStopIni ) + cHrStopIni > Dtos( dDtStopFin ) + cHrStopFin
			cError := STR0160 // "A data e hora fim de parada não pode ser maior que a data e hora inicial."
		EndIf

		If Empty( cError ) .And. dDtStopIni > dDataBase
			cError := STR0161 // "A data real início de parada não pode ser maior que a data atual."
		EndIf

	EndIf


	//Ponto de entrada que executa pré validação para a finalização de O.S.
	If Empty( cError ) .And. lPeMntNg
		cError := ExecBlock( 'MNTNG', .F., .F., { 'FINISH_VALID_ORDER', oWs } )
	EndIf

	If Empty(cError) .And. NGIFDBSEEK("STJ", cCode + cPlan, 1)

		printf("Finalizando OS " + cCode + ". " + DTOC(dDataBase) + " " + Time())

		//-------------------------------------------------------------
		// Campos abaixo devem ser carregados antes de acionar NGFINAL
		//-------------------------------------------------------------
		RecLock( "STJ", .F. )

		If !Empty( cObsFim )
			STJ->TJ_OBSERVA = cObsFim
		EndIf

		STJ->TJ_DTMRINI := dDtMRIni
		STJ->TJ_HOMRINI := cHoMRIni
		STJ->TJ_DTMRFIM := dDtMRFim
		STJ->TJ_HOMRFIM := cHoMRFim
		STJ->TJ_IRREGU  := cFault
		STJ->TJ_USUAFIM := cUserName

		If nCounter1 > 0
			STJ->TJ_POSCONT := nCounter1
			STJ->TJ_HORACO1 := cHour1
		EndIf

		If nCounter2 > 0
			STJ->TJ_POSCON2 := nCounter2
			STJ->TJ_HORACO2 := cHour2
		EndIf

		MsUnlock()

		If NGFINAL( STJ->TJ_ORDEM, STJ->TJ_PLANO, dDtStopIni, cHrStopIni, dDtStopFin, cHrStopFin, STJ->TJ_POSCONT,;
			STJ->TJ_POSCON2, cDadCode, STJ->TJ_HORACO1, STJ->TJ_HORACO2 )

			cError := ''
			MsUnlock()

			//-------------------------------------------------------------
			//Envia wf de encerramento de OS quando está vinculada a uma SS
			//-------------------------------------------------------------
			WfFinish( cCode )

			If lPeMntNg
				ExecBlock("MNTNG",.F.,.F.,{ "FINISHED_ORDER", oWs })
			EndIf
		Else
			cError := STR0027 + " " + cNGERROR // "Ocorreu um problema ao finalizar a ordem de serviço."
		EndIf

	ElseIf Empty(cError)
		cError := STR0024 // "Ordem de serviço não encontrada."
	EndIf


Return cError

//---------------------------------------------------------------------
/*/{Protheus.doc} cancelSO
Realiza o cancelamento da OS

@author	Larissa Thaís de Farias
@author	Vitor Emanuel Batista
@since 02/2016
@param oWS, objeto, objeto com o JSON que contém os dados de cancelamento
@return array,  [1]se obteve sucesso,
				[2]json para retorno,
				[3] Etapas não geradas,
				[4] Código de erro MNTNG.
/*/
//---------------------------------------------------------------------
Static Function cancelSO( oWS )

	Local oParser
	Local cError := ''
	Local cCode  := ''
	Local cPlan  := ''
	Local cMsg   := ''
	Local cBody  := oWS:GetContent()
	Local xRetAux
	Local nCodeRest := 0

	//caso tenha de fazer estorno no empenho, lAltera é utilizada dentro do MNTGERAD3("DE1") no NGDELETOS
	Private lAltera := .F.

	If FWJsonDeserialize(cBody,@oParser)

		cCode := oParser:order
		cPlan := oParser:plan
		cMsg  := oParser:message

		printf("Inicio do processo de cancelamento da OS " + cCode + ". " + DTOC(dDataBase) + " " + Time())

		dbSelectArea( 'STJ' )
		dbSetOrder( 1 )
		If dbSeek( FwxFilial( 'STJ' ) + cCode + cPlan )
			If STJ->TJ_SITUACA == 'C'
				// Retorna mensagem de erro somente para o server com o código referente as alterações de uma O.S. já cancelada.
				cError    := 'Ordem de servico ja cancelada ' + cCode + '. ' + DtoC( dDataBase ) + ' ' + Time()
				nCodeRest := CANCELCODE
			ElseIf STJ->TJ_TERMINO == 'S'
				// Retorna mensagem de erro somente para o server com o código referente as alterações de uma O.S. já finalizada.
				cError    := 'Ordem de servico ja finalizada ' + cCode + '. ' + DtoC( dDataBase ) + ' ' + Time()
				nCodeRest := FINISHCODE
			EndIf
			If !Empty( cError )
				Return { .F., cError, , nCodeRest }
			EndIf
		EndIf

		//Verifica se existe insumo com cotação	ou insumo reportado
		cError := fValidIns(cCode, cPlan , 5)
		If !Empty(cError)
			Return { .f. , cError}
		EndIf

		//Checa se existe SA com Pre-Requisicao
		If !NGCHKSAPR( cCode , cPlan, , .F., .F. )
			Return { .f. , STR0039 }
		EndIf

		If lPeMntNg
			cError:= ExecBlock("MNTNG",.F.,.F.,{ "CANCEL_VALID" , oWS })
			If !Empty(cError)
				Return { .f. , cError }
			EndIf
		EndIf

		xRetAux := NGDELETOS(cCode, cPlan, cMsg,.T.)
		//Condição para tratar chamada NGDELETOS desatualizada (retorno lógico)
		If Valtype( xRetAux ) == 'L' .And. !xRetAux
			cError := STR0028 +  " " + cCode + "." // "Ocorreu um problema ao cancelar a ordem de serviço"
		ElseIf Valtype( xRetAux ) == 'A' .And. !xRetAux[1]
			cError := xRetAux[2]
		EndIf

		//----------------------------------------------------------
		//Confirma o cancelamento da OS para exclusão de contadores
		//----------------------------------------------------------
		If Empty( cError )

			dbSelectArea("STJ")
			dbSetOrder(1)
			If dbSeek(FwxFilial("STJ") + cCode + cPlan)
				If STJ->TJ_SITUACA == 'C'
					//Exclui contador 1
					If !Empty( STJ->TJ_HORACO1 ) .And. STJ->TJ_POSCONT > 0 ;
						.And. NGIFDBSEEK( "STP", STJ->TJ_CODBEM + Dtos( STJ->TJ_DTORIGI ) + STJ->TJ_HORACO1, 5 ) ;
						.And. STP->TP_TIPOLAN != "I"
						MNT470EXCO(STJ->TJ_CODBEM,STJ->TJ_DTORIGI,STJ->TJ_HORACO1,1)
					EndIf

					//Exclui contador 2
					If !Empty( STJ->TJ_HORACO2 ) .And. STJ->TJ_POSCON2 > 0 ;
						.And. NGIFDBSEEK( "TPP", STJ->TJ_CODBEM + Dtos( STJ->TJ_DTORIGI ) + STJ->TJ_HORACO2, 5 ) ;
						.And. TPP->TPP_TIPOLA != "I"
						MNT470EXCO(STJ->TJ_CODBEM,STJ->TJ_DTORIGI,STJ->TJ_HORACO2,2)
					EndIf
				Else
					cError := STR0028 +  " " + cCode + "." // "Ocorreu um problema ao cancelar a ordem de serviço"
				EndIf
			EndIf
		EndIf

	Else
		cError := STR0022 // "Json inválido."
	EndIf

	If Empty(cError)
		printf("Processo de cancelamento completo. " + DTOC(dDataBase) + " " + Time())
	Else
		Return { .F. , cError}
	EndIf

Return { .T., JSONResult(  ) }

//---------------------------------------------------------------------
/*/{Protheus.doc} getVersion
Retorna a Versão e a Data do WebService

@author	Larissa Thaís de Farias
@since	29/09/16
@return string, json com informações de versão do ws
/*/
//---------------------------------------------------------------------
Static Function getVersion()

	printf("Coletando versoes em " + DTOC(Date()) + " " + Time() + ' --> ws:' + VERSIONWS + ' date:' + DATEVERSION )

Return JSONResult('{"ws":"' + VERSIONWS + '","minVersion":"' + MINVERSIONAPP + '","date":"' + DATEVERSION + '"}')

//---------------------------------------------------------------------
/*/{Protheus.doc} dateQuery
Retorna o trecho que decodifica a data de alteração e inclusão de um registro
para ser utilizado em querys

@author	Larissa Thaís de Farias
@since	 02/2016
@param cField, string, campo (XX_USERLGI, XX_USERLGA)
@return string, trecho para comparação de datas
/*/
//---------------------------------------------------------------------
Static Function dateQuery( cField )

	Local cDBase := Trim( TcGetDB() )
	Local cQuery := ""

	If cDBase $ 'ORACLE/POSTGRES'

    	cQuery += " TO_CHAR( "
      	cQuery += "(CASE WHEN SUBSTR(" + cField + ", 8,1) = ' ' THEN "
       	cQuery += " 	(ASCII(SUBSTR(" + cField + ", 12,1)) - 50) * 100 + "
       	cQuery += " 	(ASCII(SUBSTR(" + cField + ", 16,1)) - 50) "
      	cQuery += " ELSE "
        cQuery += " 	(ASCII(SUBSTR(" + cField + ", 8,1)) - 50) * 1000 + "
       	cQuery += " 	(ASCII(SUBSTR(" + cField + ", 12,1)) - 50) * 10 + "
       	cQuery += " 	(ASCII(SUBSTR(" + cField + ", 16,1)) - 50) "
      	cQuery += " END "
      	cQuery += " ) "
   		cQuery += " + TO_DATE('19960101', 'YYYYMMDD') , 'YYYYMMDD') "
	ElseIf cDBase $ 'DB2' // Syntax exclusiva DB2
		cQuery := " VARCHAR_FORMAT( ( TO_DATE( '19960101', 'YYYYMMDD' ) + "
		cQuery += " ( CASE WHEN SUBSTR( " + cField + ", 8, 1 ) = ' ' THEN "
		cQuery += "		( ( ASCII( SUBSTR( " + cField + ", 12, 1 ) ) - 50) * 100 + "
		cQuery += "  	( ASCII( SUBSTR( " + cField + ", 16, 1 ) ) - 50 ) ) "
		cQuery += " ELSE "
		cQuery += "		( ( ASCII( SUBSTR( " + cField + ", 8, 1 ) ) - 50) * 1000 + "
		cQuery += "		( ASCII( SUBSTR( " + cField + ", 12, 1 ) ) - 50) * 10 + "
		cQuery += "  	( ASCII( SUBSTR( " + cField + ", 16, 1 ) ) - 50 ) ) END )"
		cQuery += " days ), 'YYYYMMDD' ) "
	
	ElseIf cDBase == 'INFORMIX'

		cQuery += " ( "
		cQuery += " TO_CHAR( DATE( "
		cQuery += 				" CASE WHEN SUBSTR(" + cField + ",  8, 1) = ' ' THEN "
		cQuery += 					" ( ASCII( SUBSTR( " + cField + ", 12, 1 ) ) - 50 ) * 100 + "
		cQuery += 					" ( ASCII( SUBSTR( " + cField + ", 16, 1 ) ) - 50 ) "
		cQuery += 				" ELSE "
		cQuery += 					" ( ASCII( SUBSTR( " + cField + ", 8 , 1 ) ) - 50 ) * 1000 + "
		cQuery += 					" ( ASCII( SUBSTR( " + cField + ", 12, 1 ) ) - 50 ) * 10   + "
		cQuery += 					" ( ASCII( SUBSTR( " + cField + ", 16, 1 ) ) - 50 ) "
		cQuery += 				" END ), '%Y%m%d' )"
		cQuery += ") "

	Else

		cQuery += " ( "
		cQuery += " CONVERT(VARCHAR, DATEADD(DAY,( "
		cQuery += " ( CASE WHEN SUBSTRING(" + cField + ",  8, 1) = ' ' THEN "
		cQuery += " 	( ASCII(Substring(" + cField + ",  12, 1))   - 50 ) * 100 + "
		cQuery += " 	( ASCII( Substring(" + cField + ", 16, 1)) - 50 ) "
		cQuery += " ELSE "
		cQuery += "		( ASCII(SUBSTRING(" + cField + ", 8, 1) ) - 50 ) * 1000 + "
		cQuery += "		( ASCII(SUBSTRING(" + cField + ",12,1)) - 50) * 10 + "
		cQuery += "		( ASCII(SUBSTRING(" + cField + ",16,1)) - 50) "
		cQuery += " END )"
		cQuery += "), '19960101'), 112) )"

	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} isUser
Valida o usuário

@author Maria Elisandra de Paula
@since 14/06/2022
@return array, [1] se usuário é válido, 
				[2] informações do usuário ou descrição do erro
/*/
//---------------------------------------------------------------------
Static Function isUser()

	Local aInfoUser := {}
	Local lSeek := .F.

	PswOrder( 1 ) // ID do usuário ou grupo

	/*
		PswSeek e PswRet chamados em redundância devido a uma inconsit~encias nestas funções do framework
		como não tivemos solução por parte da equipe responsável, estaremos subindo de forma paliativa com
		este contorno.
	*/
	lSeek := PswSeek( cUserLog, .T. )
	lSeek := PswSeek( cUserLog, .T. )

	aInfoUser := PswRet()
	lSeek := PswSeek( cUserLog, .T. )
	aInfoUser := PswRet()

Return { .T., aInfoUser }

//----------------------------------------------------------------------------------
/*/{Protheus.doc} getInputs
Preenche o array aInputs com insumos previstos e realizados.
de acordo com informações passadas pelo mobile

@author	Larissa Thaís de Farias
@since	24/03/16
@param  oParser  , objeto , insumos do objeto (:inputs)
@param  cOrder   , string , código da ordem de serviço
@param  cPlan    , string , código do plano da ordem de serviço
@param  cEquip   , string , código do bem
@param  lGetIns  , boolean, Define se deve inicializar o array aGetIns.
@param  lPlayStop, boolean, Indica que a chamada foi realizada pela rota PlayStop.
@return string , vazio ou descrição do erro
/*/
//----------------------------------------------------------------------------------
Static Function getInputs( oParser, cOrder, cPlan, cEquip, lGetIns, lPlayStop )

	Local nIndex     := 0
	Local nOpcX      := 0
	Local nStatus    := 0
	Local aDate      := {}
	Local aInputTemp := {}
	Local aTask      := {}
	Local cDefUnity  := SuperGetMV("MV_NGUNIDT",.F.,"S")
	Local cError     := ''
	Local cSeqTask   := '000'
	Local lIsDone    := .F.
	Local nSizeUN    := Len( SB1->B1_UM )
	Local cBranchSB1 := FwxFilial( 'SB1' )
	Local lHasFlut   := SuperGetMV( 'MV_NGFLUT' , .F., 'N' ) == 'S'
	Local cOperation := 'C'
	Local cCalend    := ''

	Default cOrder    := "" //somente na alteração esta variável será passada por parâmetro, para validação de previstos
	Default cPlan     := "" //somente na alteração esta variável será passada por parâmetro, para validação de previstos
	Default lGetIns   := .F.
	Default lPlayStop := .F.

	// Zera array de controle de insumos
	aInputs := { { {}, {}, {} }, { {}, {}, {} } }

	For nIndex := 1 To Len( oParser )

		aInputTemp := Array( 33 )

		// Define se o insumo e Realizado ou Previsto
		lIsDone := IIf( AttIsMemberOf( oParser[nIndex], 'isDone' ), oParser[nIndex]:isDone, .F. )

		If AttIsMemberOf( oParser[nIndex], 'operation' )
			cOperation := oParser[nIndex]:operation
		EndIf

		// TL_UNIDADE
		aInputTemp[_UNITY_] := PadR( IIf( AttIsMemberOf( oParser[nIndex], 'unity' ), oParser[nIndex]:unity, 'H' ), Len( SB1->B1_UM ) )

		If AttIsMemberOf( oParser[nIndex], 'unity' )
			If oParser[nIndex]:type == 'P'
				If AllTrim( Upper( oParser[nIndex]:unity ) ) == AllTrim( Upper( Posicione( 'SB1', 1, cBranchSB1 + oParser[nIndex]:code, 'B1_UM' ) ) )
					aInputTemp[_UNITY_] := PadR( oParser[nIndex]:unity, nSizeUN )
				Else
					cError := STR0180 + oParser[nIndex]:code + STR0181 //'Unidade informada no insumo ' ' inválida! Favor verificar o campo unity.'
					exit
				EndIf
			Else
				aInputTemp[_UNITY_] := PadR( oParser[nIndex]:unity, nSizeUN )
			EndIf

		Else
			aInputTemp[_UNITY_] := PadR( 'H', nSizeUN )
		EndIf

		// TL_DESTINO
		If AttIsMemberOf( oParser[nIndex], 'destiny' )
			If Upper( oParser[nIndex]:type ) == 'P'
				If oParser[nIndex]:destiny $ 'A/S/T'
					aInputTemp[_DESTINY_] := oParser[nIndex]:destiny
				Else
					cError := STR0182 + oParser[nIndex]:code + STR0183 // 'Destino informado no insumo ' ' inválido! Favor verificar o campo destiny.'
					exit
				EndIf
			Else
				aInputTemp[_DESTINY_] := oParser[nIndex]:destiny
			EndIf
		Else
			aInputTemp[_DESTINY_] := ''
		EndIf

		// TL_TIPOREG
		aInputTemp[_TYPE_] := IIf( AttIsMemberOf( oParser[nIndex], 'type' ), oParser[nIndex]:type, '' )

		// TL_PERMDOE
		aInputTemp[_PERCENT_] := IIf( AttIsMemberOf( oParser[nIndex], 'percent' ), oParser[nIndex]:percent, 0 )

		// TL_OBSERVA
		aInputTemp[_INPUTNOTE_] := IIf( AttIsMemberOf( oParser[nIndex], 'note' ), Trim( oParser[nIndex]:note ), '' )

		// TL_QUANREC
		aInputTemp[_RESOURCEAMOUNT_] := IIf( AttIsMemberOf( oParser[nIndex], 'resourceAmount' ), oParser[nIndex]:resourceAmount, 0 )

		// TL_QUANTID
		aInputTemp[_AMOUNT_] := IIf( AttIsMemberOf( oParser[nIndex], 'amount' ), oParser[nIndex]:amount, 0 )

		If aInputTemp[_TYPE_] == 'P' .And. Len( cValtoChar(oParser[nIndex]:amount ) ) > 9
			Return STR0029 + " " + STR0030 + " " + NGSEEK( "SB1", oParser[nIndex]:code, 1, "B1_DESC") //"Campo quantidade está incorreto." # "Produto"
		EndIf

		// TL_DTVALID
		aInputTemp[_DATELOT_] := cToD( '' )

		// TL_USACALE
		If AttIsMemberOf( oParser[nIndex], 'useCalendar' )
			aInputTemp[_USECALE_] := oParser[nIndex]:useCalendar
		else
			aInputTemp[_USECALE_] := 'N'			
		EndIf

		// TL_CUSTO
		aInputTemp[_COST_] := 0

		// TL_TIPOHOR
		aInputTemp[_HOURUNITY_] := IIf( AttIsMemberOf( oParser[nIndex], 'hourUnity' ), IIf( Empty( oParser[nIndex]:hourUnity ),;
			cDefUnity, oParser[nIndex]:hourUnity ), cDefUnity )

		// TL_LOCAL
		aInputTemp[_WAREHOUSE_] := PadR( IIf( AttIsMemberOf( oParser[nIndex], 'warehouse' ), oParser[nIndex]:warehouse,;
			IIf( aInputTemp[_TYPE_] == 'T',	PadR( SuperGetMV( 'MV_NGLOCPA', .F., '01' ), Len( STL->TL_LOCAL ) ), '' ) ),;
			Len( STL->TL_LOCAL ) )

		// TL_TAREFA
		aInputTemp[_TASK_] := PadR( IIf( AttIsMemberOf( oParser[nIndex], 'task' ), oParser[nIndex]:task, '0'),;
			Len( STL->TL_TAREFA ) )

		// Backup TL_TAREFA
		aInputTemp[_KEYTASK_] := PadR( IIf( AttIsMemberOf( oParser[nIndex], 'keyTask' ), oParser[nIndex]:keyTask, ''),;
			Len( STL->TL_TAREFA ) )

		// TL_CODIGO
		aInputTemp[_CODE_] := PadR( IIf( AttIsMemberOf( oParser[nIndex], 'code' ), oParser[nIndex]:code, '' ),;
			Len( STL->TL_CODIGO ) )

		// Backup TL_CODIGO
		aInputTemp[_KEYCODE_] := PadR( IIf( AttIsMemberOf( oParser[nIndex], 'keyCode' ), oParser[nIndex]:keyCode, ''),;
			Len( STL->TL_CODIGO ) )

		// TL_SEQRELA
		aInputTemp[_SEQUENCE_] := PadR( IIf( AttIsMemberOf( oParser[nIndex], 'sequence' ), oParser[nIndex]:sequence, '0'),;
			Len( STL->TL_SEQRELA ) )

		// TL_SEQTARE
		aInputTemp[_SEQTASK_] := PadR( IIf( AttIsMemberOf( oParser[nIndex], 'taskSequence' ), oParser[nIndex]:taskSequence,;
			IIf( !lIsDone, fseqTask( cOrder, cPlan, @cSeqTask ), '' ) ), Len( STL->TL_SEQTARE ) )

		// TL_LOCALIZ
		aInputTemp[_LOCATION_] := IIf( AttIsMemberOf( oParser[nIndex], 'location' ), Upper( PadR( oParser[nIndex]:location,;
			Len( STL->TL_LOCALIZ ) ) ), '' )

		// TL_NUMSERI
		aInputTemp[_SERIALNUMBER_] := IIf( AttIsMemberOf( oParser[nIndex], 'serialnumber' ), Upper( PadR( oParser[nIndex]:serialnumber,;
			Len( STL->TL_NUMSERI ) ) ), '' )

		// TL_NUMSA
		aInputTemp[_WHREQUEST_] := IIf( AttIsMemberOf( oParser[nIndex], 'warehouseRequest' ), PadR( oParser[nIndex]:warehouseRequest,;
			Len( STL->TL_NUMSA ) ), '' )

		// TL_ITEMSA
		aInputTemp[_WHITEM_] := IIf( AttIsMemberOf( oParser[nIndex], 'warehouseItem' ), PadR( oParser[nIndex]:warehouseItem,;
			Len( STL->TL_ITEMSA ) ), '' )

		// TL_LOTECTL
		aInputTemp[_LOT_] := IIf( AttIsMemberOf( oParser[nIndex], 'lot' ),  PadR( oParser[nIndex]:lot,;
			Len( STL->TL_LOTECTL ) ) , '' )

		// TL_NUMLOTE
		aInputTemp[_SUBLOT_] := IIf( AttIsMemberOf( oParser[nIndex], 'sublot' ),  PadR( oParser[nIndex]:sublot,;
			Len( STL->TL_NUMLOTE ) ) , '' )

		// TL_DTINICI & TL_HOINICI
		If AttIsMemberOf( oParser[nIndex], 'startDate' )
			aDate := StrTokArr( oParser[nIndex]:startDate, ' ' )
		ElseIf AttIsMemberOf( oParser[nIndex], 'date' )
			aDate := StrTokArr( oParser[nIndex]:date, ' ' )
		Else
			aDate := { dToS( dDataBase ), '08:00' }
		EndIf

		// TL_DTINICI
		aInputTemp[_STARTDATE_] := sToD( aDate[1] )

		// TL_HOINICI
		aInputTemp[_STARTHOUR_] := aDate[2]

		// TL_DTFIM & TL_HOFIM
		If AttIsMemberOf( oParser[nIndex], 'endDate' )
			aDate := StrTokArr( oParser[nIndex]:endDate, ' ' )
		ElseIf AttIsMemberOf( oParser[nIndex], 'date' )
			aDate := StrTokArr( oParser[nIndex]:date, ' ' )
		Else
			aDate := { dToS( dDataBase ), '18:00' }
		EndIf

		// TL_DTFIM
		aInputTemp[_ENDDATE_] := sToD( aDate[1] )

		// TL_HOFIM
		aInputTemp[_ENDHOUR_] := aDate[2]

		If aInputTemp[_TYPE_] == 'T' .And. AttIsMemberOf( oParser[nIndex], 'store' )

			// TL_FORNEC
			aInputTemp[_SUPPLIER_] := aInputTemp[_CODE_]

			// TL_LOJA
			aInputTemp[_STORE_] := oParser[nIndex]:store

		Else

			aInputTemp[_SUPPLIER_] := ''
			aInputTemp[_STORE_] := ''

		EndIf

		If AttIsMemberOf( oParser[nIndex], 'scNum' ) .And. AttIsMemberOf( oParser[nIndex], 'scItem' )
			aInputTemp[_SCNUM_]  := oParser[nIndex]:scNum
			aInputTemp[_SCITEM_] := oParser[nIndex]:scItem
		else
			aInputTemp[_SCNUM_]  := ''
			aInputTemp[_SCITEM_] := ''
		EndIf

		// Ocorrências
		If AttIsMemberOf( oParser[nIndex], 'occurrences' )

			/*
				Preenche uma matriz contendo a indetificação do insumo e a listagem de ocorrências relacionadas para o
				controle de gravação.
			*/
			aInputTemp[_OCCURRENCES_] := aClone( GetOccurrences( oParser[nIndex]:occurrences ) )

		EndIf

		If aInputTemp[_USECALE_] == 'S' .And. aInputTemp[_TYPE_] == 'M' .And. cOperation != 'D'

			cCalend := NGSEEK( 'ST1', Substr( aInputTemp[_CODE_], 1, 6 ), 1, 'T1_TURNO' )
			If lHasFlut //Utiliza turno flutuante
				cCalFlu := MNTCALFLU( Substr( aInputTemp[_CODE_], 1, 6 ), aInputTemp[_STARTDATE_], aInputTemp[_STARTHOUR_] )
				If !Empty( cCalFlu ) //Se o funcionário não estiver relacionado à uma equipe de manutenção
					cCalend := cCalFlu
				EndIf
			EndIf

			/*-----------------------------+
			| Carrega quantidade de horas  |
			-------------------------------*/
			aInputTemp[_AMOUNT_] := NGQUANTIHOR( 'M',, ;
									aInputTemp[_STARTDATE_], ;
									aInputTemp[_STARTHOUR_], ;
									aInputTemp[_ENDDATE_], ;
									aInputTemp[_ENDHOUR_], ;
									'S', ;
									cCalend,; 
									cDefUnity)

			/*-----------------------------+
			| Validação hora inicial       |
			-------------------------------*/
			cError := fVldCalend( cCalend, aInputTemp[_STARTDATE_], aInputTemp[_STARTHOUR_], 'I' )
			If Empty( cError )
				/*-----------------------------+
				| Validação hora final         |
				-------------------------------*/
				cError := fVldCalend( cCalend, aInputTemp[_ENDDATE_], aInputTemp[_ENDHOUR_], 'F' )
			EndIf

		ElseIf aInputTemp[_TYPE_] != 'P' .And. Trim( aInputTemp[_UNITY_] ) == 'H' .And. cDefUnity != 'D'
			aInputTemp[_AMOUNT_] := NGRHODSEXN( aInputTemp[_AMOUNT_], 'D' ) //Converte um valor em decimal para horas (numérico)
		EndIf

		If !Empty( cError )
			Return cError
		EndIf


		nStatus := IIf( lIsDone, _REALIZED_, _FORESEEN_ )

		// Separa os insumos por operação as quais foram acionados.
		Do Case

			Case lPlayStop .Or. oParser[nIndex]:operation == 'C'

				aAdd( aInputs[nStatus,_INSERT_], aInputTemp )

			Case oParser[nIndex]:operation == 'U'

				// Valida e carrega detalhes da S.A. relacionada ao insumo no arrary aInputs.
				cError := checkSA( cOrder, cPlan, @aInputTemp, 'U' )

				If Empty( cError )

					aAdd( aInputs[nStatus,_UPDATE_], aInputTemp )

				Else

					Return cError

				EndIf

			Case oParser[nIndex]:operation == 'D'

				// Valida S.A. relacionada ao insumo.
				cError := checkSA( cOrder, cPlan, aInputTemp, 'D' )

				If Empty( cError )

					aAdd( aInputs[nStatus,_DELETE_], aInputTemp )

				Else

					Return cError

				EndIf

		EndCase

		If lGetIns

			dbSelectArea( 'STL' )
			dbSetOrder( 1 ) // TL_FILIAL + TL_ORDEM + TL_PLANO + TL_TAREFA + TL_TIPOREG + TL_CODIGO + TL_SEQRELA + TL_SEQTARE
			msSeek( FwxFilial( 'STL' ) + cOrder + cPlan + aInputTemp[_KEYTASK_] + aInputTemp[_TYPE_] + aInputTemp[_KEYCODE_] +;
				aInputTemp[_SEQUENCE_] + aInputTemp[_SEQTASK_] )

			aAdd( aGetIns, { aInputTemp[_KEYTASK_], aInputTemp[_TYPE_], aInputTemp[_KEYCODE_], '', aInputTemp[_USECALE_], aInputTemp[_RESOURCEAMOUNT_],;
				aInputTemp[_AMOUNT_], aInputTemp[_UNITY_], aInputTemp[_DESTINY_], aInputTemp[_STARTDATE_], aInputTemp[_STARTHOUR_], aInputTemp[_WAREHOUSE_],;
				lIsDone, STL->( RecNo() ), IIf( oParser[nIndex]:operation == 'D', .T., .F. ) } )

		EndIf

		aInputTemp := {}

	Next nIndex

	// Tratamento exclusivo para inclusão e alteração dos insumos previstos.
	If !Empty( aInputs[_FORESEEN_,_UPDATE_] ) .Or. !Empty( aInputs[_FORESEEN_,_INSERT_] )

		/*
			Loop executado três vezes para que possa abranger insumos previstos dos processo de inclusão/alteração.
		*/
		For nOpcX := 1 To 2

			If !Empty( aInputs[_FORESEEN_,nOpcX] )

				aTask := aClone( aInputs[_FORESEEN_,nOpcX] )

				// Processo de verificação do Produto Alternativo.
				If FindFunction( 'NGALTPROD' ) .And. Trim( SuperGetMv( 'MV_MNTPRAL', .F., '2' ) ) == '1' .And.;
					Trim( SuperGetMv( 'MV_NGGERSA', .F., 'N' ) ) == 'N' .And. Trim( SuperGetMv( 'MV_NGMNTES', .F., 'N' ) ) == 'S'

					aTask := NGALTPROD( aTask, , cEquip, 'TL', 'MNTNG', { _TYPE_, _CODE_, _AMOUNT_, _TASK_, _WAREHOUSE_,;
						_DESTINY_, _COST_ } )

				EndIf

			EndIf

		Next nOpcX

	EndIf

Return cError

//---------------------------------------------------------------------
/*/{Protheus.doc} getCheckList
Preenche o array de checklist

@author	Larissa Thaís de Farias
@since	24/03/16
@param oParser, array, etapas vindos do JSON
@param  cOrder, string, código da ordem
@param cPlan, string, plano
@param cType, string, tipo de manutenção: 'P' ou 'C'
@param cEquipment, string, código do bem 
@param cService, string, código do serviço
@param cSequence, string, sequencia da manutenção

@return string, vazio ou descrição do erro
/*/
//---------------------------------------------------------------------
Static Function getCheckList( oParser,  cOrder, cPlan, cType, cEquipment, cService, cSequence )

	Local aCheckTemp:= {}
	Local aAnswers  := {}
	Local aConvert  := {}
	Local aAux      := {}
	Local cConteudo := ''
	Local cError    := ''
	Local cTask     := ''
	Local cStep     := ''
	Local cWorker   := ''
	Local cOk       := ''
	Local cMarca    := GetMark()
	Local cTaskDef  := Padr( '0', TamSx3( 'TQ_TAREFA' )[1] )
	Local cSeqStep  := Space( TamSx3('TQ_SEQETA')[1] )
	Local cSeqTask  := Space( TamSx3("TQ_SEQTARE")[1] )
	Local nI        := 1
	Local nX        := 0
	Local cKeyManut := ''
	Local cOperat   := 'C'
	Local lVerManut := .F.
	Local lUpdate   := .F.

	Default cOrder := ''
	Default cPlan  := ''

	If cType == 'P'
		cKeyManut := FwxFilial('STF') + cEquipment + cService + cSequence
	EndIf

	aEtapas := { {},{}, {} }

	For nI := 1 To Len( oParser )

		aCheckTemp := Array(7)
		aAnswers   := {}

		cTask    := IIf( AttIsMemberOf( oParser[nI], 'task' ), Padr( oParser[nI]:task, TamSx3( 'TQ_TAREFA' )[1] ), cTaskDef )
		cStep    := IIf( AttIsMemberOf( oParser[nI], 'step' ), Padr( oParser[nI]:step, TamSx3( 'TQ_ETAPA' )[1] ), '' )
		cOk      := IIf( AttIsMemberOf( oParser[nI], 'isDone' ) .And. oParser[nI]:isDone, cMarca, '' )
		cWorker  := IIf( AttIsMemberOf( oParser[nI], 'worker' ), Padr(oParser[nI]:worker, TamSx3('TQ_CODFUNC')[1]), '' )
		cSeqStep := Space( TamSx3('TQ_SEQETA')[1] )
		cSeqTask := Space( TamSx3("TQ_SEQTARE")[1] )

		lVerManut := .T.
		lUpdate   := .F.

		//-----------------------------------------------
		// Busca sequencia da etapa já gravada no banco
		//-----------------------------------------------
		If !Empty(  cOrder )

			dbSelectArea('STQ')
			dbSetOrder(1)
			If dbSeek( FwxFilial('STQ') +  cOrder + cPlan + cTask + cStep )

				cSeqStep := STQ->TQ_SEQETA
				cSeqTask := STQ->TQ_SEQTARE

				lVerManut := .F.
				lUpdate   := .T.
	
			EndIf
		
		EndIf

		//--------------------------------------------------------
		// Busca sequencia das etapas pelo cadastro da manutenção
		//--------------------------------------------------------
		If cType == 'P' .And. lVerManut

			dbSelectArea('ST5')
			dbSetOrder(1)
			If dbSeek( cKeyManut + cTask )
				cSeqTask := CValToChar( ST5->T5_SEQUENC )
			EndIf

			dbSelectArea('STH')
			dbSetOrder(1)
			If dbSeek( cKeyManut + cTask + cStep )
				cSeqStep := STH->TH_SEQETA
			EndIf

		EndIf

		If AttIsMemberOf( oParser[nI], 'operation' )
			cOperat := oParser[nI]:operation
			lAppSimult := .T.
		Else
			lAppSimult := .F.
			If lUpdate
				cOperat := 'U'
			Else
				cOperat := 'C'
			EndIf
		EndIf

		//-------------------------------------
		// Respostas das etapas
		//-------------------------------------
		If AttIsMemberOf( oParser[nI], 'answers' ) .And. cOperat != 'D' .And. !Empty(cOk)
			aAux:= oParser[nI]:answers
			For nX := 1 to Len(aAux)
				aConvert := fToString(oParser[nI]:step,aAux[nX]:code,aAux[nX]:value)
				cConteudo := aConvert[2]

				If !aConvert[1]
					cError := cConteudo
					Exit
				EndIf

				aadd(aAnswers, { Padr(aAux[nX]:code,TamSx3("TPQ_OPCAO")[1]),Padr(cConteudo, TamSx3("TPQ_RESPOS")[1])})
			Next
			If !Empty(cError)
				Exit
			EndIf
		EndIf

		aCheckTemp[_TAREFA_]    := cTask
		aCheckTemp[_ETAPA_]     := cStep
		aCheckTemp[_SEQETA_]    := cSeqStep
		aCheckTemp[_SEQTARE_]   := cSeqTask
		aCheckTemp[_CODFUNC_]   := cWorker
		aCheckTemp[_OK_]        := cOk
		aCheckTemp[_ANSWERS_]   := aAnswers

		Do Case
			Case cOperat == 'C'
				aAdd(aEtapas[_INSERT_], aCheckTemp)
			Case cOperat == 'U'
				aAdd(aEtapas[_UPDATE_], aCheckTemp)
			Otherwise
				aAdd(aEtapas[_DELETE_], aCheckTemp)
		EndCase

	Next nI

	//-------------------------------------------------
	// carrega array para exclusão - app não atualizado
	//-------------------------------------------------
	If !lAppSimult
		dbSelectArea("STQ")
		dbSetOrder(1)
		If dbSeek(FwxFilial("STQ") +  cOrder + cPlan)

			aCheckTemp := Array(7)

			While !Eof() .And. FwxFilial("STQ") + cOrder + cPlan == STQ->TQ_FILIAL + STQ->TQ_ORDEM + STQ->TQ_PLANO

				If aScan(aEtapas[_INSERT_], {|x| Alltrim(x[_TAREFA_]) == Alltrim(STQ->TQ_TAREFA) ;
					.And. Alltrim(x[_ETAPA_]) == Alltrim(STQ->TQ_ETAPA )}) == 0 .And.;
					aScan(aEtapas[_UPDATE_], {|x| Alltrim(x[_TAREFA_]) == Alltrim(STQ->TQ_TAREFA) ;
					.And. Alltrim(x[_ETAPA_]) == Alltrim(STQ->TQ_ETAPA )}) == 0

					aCheckTemp[_TAREFA_]    := STQ->TQ_TAREFA
					aCheckTemp[_ETAPA_]     := STQ->TQ_ETAPA
					aCheckTemp[_SEQETA_]    := STQ->TQ_SEQETA
					aCheckTemp[_SEQTARE_]   := STQ->TQ_SEQTARE
					aCheckTemp[_CODFUNC_]   := STQ->TQ_CODFUNC
					aCheckTemp[_OK_]        := STQ->TQ_OK
					aCheckTemp[_ANSWERS_]   := {}

					aAdd(aEtapas[_DELETE_], aCheckTemp)

				EndIf
				dbSkip()
			EndDo
		EndIf
	EndIf
Return cError

//---------------------------------------------------------------------
/*/{Protheus.doc} InputSTQ
Insere as etapas e respostas

@author	Maria Elisandra de paula
@author	Larissa Thaís de Farias
@since  24/03/16
@param cOrder, caracter, número da Ordem de Serviço
@param cPlan, caracter, código do plano da ordem de serviço
@return array, [1] vazio ou descrição do erro,
               [2] array com as ordens geradas pelas respostas
			   [3] array com as solicitações geradas pelas respostas
			   [4] respostas não geradas
aEtapas:
[1]-TQ_TAREFA
[2]-TQ_ETAPA
[3]-TQ_SEQETA
[4]-TQ_SEQTARE
[5]-TQ_CODFUNC
[6]-TQ_OK
[7]-{TPQ_OPCAO, TPQ_RESPOS}

/*/
//---------------------------------------------------------------------
Static Function InputSTQ(cOrder, cPlan)

	Local oStep
	Local cError     := ""
	Local nI         := 0 
	Local nX         := 0
	Local nOperat    := 0
	Local aOSGeradas := {}
	Local aSSGeradas := {}
	Local aCols      := {}
	Local aNoSTQ     := {}
	Local aInfoList  := {}
	Local nCrud      := 0
	Local aAux       := {}

	//---------------------------------------------------------------
	// Exclusão de etapas - deve ser feito antes das outras operações
	//---------------------------------------------------------------
	For nX := 1 to Len(aEtapas[_DELETE_])

		aAux := aEtapas[_DELETE_,nX]

		oStep := MNTStep():New()
		oStep:setAsk(.F.)//Não apresenta mensagens condicionais (.F.)
		oStep:setOperation(5)//seta operação como 'excluir'
		oStep:Load({FwxFilial("STQ") + cOrder + cPlan + ;
					aAux[_TAREFA_] + ;
					aAux[_ETAPA_] + ;
					aAux[_SEQTARE_]})

		If oStep:valid()// Realiza as validações de Etapas
			oStep:delete()//Deleta a Etapa
		Else
			cError := STR0125 + ":" + Space(1) +  aAux[_ETAPA_] + Space(1) //"Operação excluir etapa"
			cError += STR0126 + ":" + Space(1) + oStep:GetErrorList()[1] //"Erro"
			Exit
		EndIf

	Next nX

	If Empty(cError)

		//------------------------------------
		// Alterações e inclusões de etapas
		//------------------------------------
		For nCrud := 1 to 2

			If nCrud == _INSERT_
				nOperat := 3
			ElseIf nCrud == _UPDATE_
				nOperat := 4
			EndIf

			For nI := 1 to Len(aEtapas[nCrud])

				aAux := aEtapas[nCrud,nI]

				If nOperat == 4 .And. !lAppSimult
					//-------------------------------------------
					//verifica se houve alguma alteração na etapa
					//-------------------------------------------
					dbSelectArea("STQ")
					dbSetOrder(1)
					If dbSeek(FwxFilial("STQ") +  cOrder + cPlan + aAux[_TAREFA_] + aAux[_ETAPA_] + aAux[_SEQTARE_]) .And.;
						!fModifEtapa(cOrder,cPlan,aAux[_TAREFA_],aAux[_ETAPA_],aAux[_OK_],aAux[_ANSWERS_])
						Loop
					EndIf
				EndIf

				oStep := MNTStep():New()
				oStep:setAsk(.F.)//Não apresenta mensagens condicionais (.F.)
				oStep:setOperation(nOperat)//set
				
				If nOperat == 4
					oStep:Load({FwxFilial("STQ") + cOrder + cPlan + aAux[_TAREFA_] + aAux[_ETAPA_] + aAux[_SEQTARE_]})
				EndIf

				oStep:setValue("TQ_FILIAL" , FwxFilial("STQ"))
				oStep:setValue("TQ_ORDEM"  , cOrder)
				oStep:setValue("TQ_PLANO"  , cPlan)
				oStep:setValue("TQ_TAREFA" , aAux[_TAREFA_])
				oStep:setValue("TQ_ETAPA"  , aAux[_ETAPA_])
				oStep:setValue("TQ_SEQETA" , aAux[_SEQETA_])
				oStep:setValue("TQ_SEQTARE", aAux[_SEQTARE_])
				oStep:setValue("TQ_CODFUNC", aAux[_CODFUNC_])
				oStep:setValue("TQ_OK"     , aAux[_OK_])

				//-------------------------------------------------------
				//Carrega acols de acordo com respostas
				//-------------------------------------------------------
				aHeaderAux:= oStep:GetHeader("TPQ")
				aCols := fCargaAcols(cOrder,;
								cPlan,;
								aAux[_TAREFA_],;
								aAux[_ETAPA_],;
								aAux[_ANSWERS_],;
								aHeaderAux,;
								nOperat)

				oStep:setCols("TPQ", aCols)

				aInfoList := {}

				If oStep:valid()// Realiza as validações de Etapas
					If oStep:upsert()//Realiza a gravação das Etapas

						//----------------------------------------
						//recupera ordens geradas pelas respostas
						//-----------------------------------------
						aAdd(aOSGeradas,aClone(oStep:getResultList()[_OS_]))

						//----------------------------------------
						//recupera solicitações geradas pelas respostas
						//-----------------------------------------
						aAdd(aSSGeradas,aClone(oStep:getResultList()[_SS_]))


					Else
						cError:= STR0127 + ":" + Space(1) +  aAux[_ETAPA_] + Space(1) //"Operação alterar/incluir etapa"
						cError+= STR0126 + ":" + oStep:GetErrorList()[1] //"Erro"
						Exit
					EndIf
				Else

					//-----------------------------------------------
					//recupera informações das respostas não geradas
					//-----------------------------------------------
					aInfoList := oStep:getInfoList()
					If Len(aInfoList) > 0
						For nX := 1 to Len(aInfoList)
							aAdd(aNoSTQ, {aAux[_ETAPA_], aAux[_ETAPA_], aInfoList[nX]})
						Next nX
					Else
						cError:= STR0127 + ":" + Space(1) +  aAux[_ETAPA_] + Space(1) //"Operação alterar/incluir etapa"
						cError+= STR0126 + ":" + oStep:GetErrorList()[1] //"Erro"
						Exit
					EndIf
				EndIf
			Next nI
		Next nCrud
	EndIf
Return { cError, aOSGeradas, aSSGeradas, aNoSTQ }

//---------------------------------------------------------------------
/*/{Protheus.doc} InputSTLRea
Realiza processamento dos insumos realizados
@type function

@author	Alexandre Santos
@since  20/11/2020

@param cOrdem, string, número da Ordem de Serviço
@param cType , string, tipo da OS, C: Corretiva, P: Preventiva
@return nil
/*/
//---------------------------------------------------------------------
Static Function InputSTLRea(cOrdem, cType )

	Local cError     := ""
	Local nInput     := 0
	Local lEstNega   := AllTrim(GetMv("MV_ESTNEG")) == "S"
	Local lMoveStock := .F.
	Local cUsaIntEs  := SuperGetMv("MV_NGMNTES",.F.,"N")
	Local aDelete    := {}
	Local aUpdate    := {}
	Local aInsert    := {}

	// Alteração e Inclusão de Insumos
	If !Empty( aInputs[_REALIZED_,_UPDATE_] ) .Or. !Empty( aInputs[_REALIZED_,_INSERT_] )

		// Forma de facilitar a codificação e entendimento da matriz.
		aUpdate := aClone( aInputs[_REALIZED_,_UPDATE_] )

		For nInput := 1 To Len( aUpdate )

			dbSelectArea( 'STL' )
			dbSetOrder( 1 ) // TL_FILIAL + TL_ORDEM + TL_PLANO + TL_TAREFA + TL_TIPOREG + TL_CODIGO + TL_SEQRELA + TL_SEQTARE
			If msSeek( FwxFilial( 'STL' ) + STJ->TJ_ORDEM + STJ->TJ_PLANO + aUpdate[nInput,_KEYTASK_] + aUpdate[nInput,_TYPE_] +;
				aUpdate[nInput,_KEYCODE_] + aUpdate[nInput,_SEQUENCE_] )

				// Indica que não será inclusa uma nova movimentação de estoque - SD3 para o insumo.
				lMoveStock := .F.

				If STL->TL_QUANTID != aUpdate[nInput,_AMOUNT_] .Or. STL->TL_CODIGO != aUpdate[nInput,_CODE_] .Or.;
					STL->TL_LOCAL != aUpdate[nInput,_WAREHOUSE_] .Or. STL->TL_LOCALIZ != aUpdate[nInput,_LOCATION_]

					// Realiza estorno da movimentação de estoque somente quando houver alteração no produto ou quantidade.
	            	cError := RevMovSto()

					If !Empty( cError )
						printf( cError )
						Return cError
					EndIf

					// Indica que será inclusa uma nova movimentação de estoque - SD3 para o insumo.
					lMoveStock := .T.

				EndIf

				printf( '  - Modificando insumo realizado: ' + Trim( STL->TL_TAREFA ) + '/' + Trim( STL->TL_CODIGO ) +;
					' -> ' + Trim( aUpdate[nInput,_TASK_] ) + '/' + Trim( aUpdate[nInput,_CODE_] ) +;
					' ( ' + cValToChar( aUpdate[nInput,_AMOUNT_] ) +      ' )' )

				If !NGRETINS( 	STJ->TJ_ORDEM                   ,;
								STJ->TJ_PLANO                   ,;
								cType                           ,; // PTIPO
								Nil                             ,;	// PCODBEM
								Nil                             ,; // PSERVICO
								Nil                             ,;	// PSEQ
								aUpdate[nInput,_TASK_]       ,;
								aUpdate[nInput,_TYPE_]          ,;
								aUpdate[nInput,_CODE_]       ,;
								aUpdate[nInput,_AMOUNT_]        ,;
								aUpdate[nInput,_UNITY_]         ,;
								aUpdate[nInput,_DESTINY_]       ,;
								'Insumo Realizado.'             ,;
								aUpdate[nInput,_STARTDATE_]     ,;
								aUpdate[nInput,_STARTHOUR_]     ,;
								'F'                             ,; //PGERAFES
								aUpdate[nInput,_WAREHOUSE_]     ,;
								aUpdate[nInput,_LOT_]           ,;
								aUpdate[nInput,_SUBLOT_]        ,;
								aUpdate[nInput,_DATELOT_]       ,;
								aUpdate[nInput,_LOCATION_]      ,;
								aUpdate[nInput,_PERCENT_]       ,;
								aUpdate[nInput,_USECALE_]       ,;
								'N'                             ,; // PGARANT
								Nil                             ,; // PLOCAPL
								Nil                             ,; // PQTDGAR
								Nil                             ,; // PUNIGAR
								Nil                             ,; // PCONGAR
								.T.                             ,; // PLEST
								@cError, ,                      ,;
								aUpdate[nInput,_RESOURCEAMOUNT_],;
								aUpdate[nInput,_SERIALNUMBER_]  ,;
								{ aUpdate[nInput,_KEYTASK_]     ,;
								  aUpdate[nInput,_KEYCODE_] }   ,;
								aUpdate[nInput,_SEQUENCE_]      ,;
								aUpdate[nInput,_SEQTASK_]       ,;
								lMoveStock )

					printf( cError )
					Return cError

				EndIf

				If Empty( cError )
					RecLock( 'STL', .F. )
						STL->TL_OBSERVA := aUpdate[nInput,_INPUTNOTE_]
					STL->( MsUnLock() )
				EndIf

				If !Empty( aUpdate[nInput,_OCCURRENCES_,_INSERT_] ) .Or. !Empty( aUpdate[nInput,_OCCURRENCES_,_UPDATE_] ) .Or.;
					!Empty( aUpdate[nInput,_OCCURRENCES_,_DELETE_] )

					// Grava ocorrências na base de dados
					InputSTN( FwxFilial( 'STN' ), STJ->TJ_ORDEM, STJ->TJ_PLANO, STL->TL_TAREFA, STL->TL_SEQRELA,;
						aUpdate[nInput,_OCCURRENCES_] )

				EndIf

			Else

				// Caso não encontra para alteração, adiciona na lista de inclusão de insumos.
				aAdd( aInputs[_REALIZED_,_INSERT_], aUpdate[nInput] )

			EndIf

		Next nInput

		// Forma de facilitar a codificação e entendimento da matriz.
		aInsert := aClone( aInputs[_REALIZED_,_INSERT_] )

		For nInput := 1 To Len( aInsert )

			If cUsaIntEs == 'S' .And. aInsert[nInput,_TYPE_] == 'P' .And. !lEstNega //Testa poder ter saldo negativo se retornar .T.(Prossegue e nao testa o saldo em estoque)se .F.(Testa se o Saldo esta negativo)

				INCLUI := .T. // Essa variavel foi declarada pq é utilizada na função NGSALSB2

				// Testa se o saldo esta negativo
				If !NGSALSB2( aInsert[nInput,_CODE_], aInsert[nInput,_WAREHOUSE_], aInsert[nInput,_AMOUNT_], .F., ,;
					aInsert[nInput,_STARTDATE_], .T. )
					Return STR0034 + ' ' + NGSEEK( 'SB1', aInsert[nInput,_CODE_], 1, 'B1_DESC' ) // Saldo insuficiente para o produto:
				EndIf

			EndIf

			printf( '  - Incluindo insumo realizado ' + Trim( aInsert[nInput,_TASK_] ) + '/' + Trim( aInsert[nInput,_CODE_] ) + ' ( ' +;
				cValtochar( aInsert[nInput,_AMOUNT_] ) + ' )' )

			If !NGRETINS( 	STJ->TJ_ORDEM              ,;
							STJ->TJ_PLANO              ,;
							cType                      ,; // PTIPO
							Nil                        ,;	// PCODBEM
							Nil                        ,; // PSERVICO
							Nil                        ,;	// PSEQ
							aInsert[nInput,_TASK_]     ,;
							aInsert[nInput,_TYPE_]     ,;
							aInsert[nInput,_CODE_]     ,;
							aInsert[nInput,_AMOUNT_]   ,;
							aInsert[nInput,_UNITY_]    ,;
							aInsert[nInput,_DESTINY_]  ,;
							'Insumo Realizado.'        ,;
							aInsert[nInput,_STARTDATE_],;
							aInsert[nInput,_STARTHOUR_],;
							'F'                        ,; //PGERAFES
							aInsert[nInput,_WAREHOUSE_],;
							aInsert[nInput,_LOT_]      ,;
							aInsert[nInput,_SUBLOT_]   ,;
							Nil                        ,; // PDTVALID
							aInsert[nInput,_LOCATION_] ,;
							aInsert[nInput,_PERCENT_]  ,;
							aInsert[nInput,_USECALE_]  ,; // PCALEND
							'N'                        ,; // PGARANT
							Nil                        ,; // PLOCAPL
							Nil                        ,; // PQTDGAR
							Nil                        ,; // PUNIGAR
							Nil                        ,; // PCONGAR
							.T.                        ,; // PLEST
							@cError, ,                 ,;
							aInsert[nInput,_RESOURCEAMOUNT_],;
							aInsert[nInput,_SERIALNUMBER_] )

				printf( cError )
				Return cError

			EndIf

			If Empty( cError )
				RecLock( 'STL', .F. )
					STL->TL_OBSERVA := aInsert[nInput,_INPUTNOTE_]
				STL->( MsUnLock() )
			EndIf

			If !Empty( aInsert[nInput,_OCCURRENCES_,_INSERT_] ) .Or. !Empty( aInsert[nInput,_OCCURRENCES_,_UPDATE_] ) .Or.;
				!Empty( aInsert[nInput,_OCCURRENCES_,_DELETE_] )

				// Grava ocorrências na base de dados
				InputSTN( FwxFilial( 'STN' ), STJ->TJ_ORDEM, STJ->TJ_PLANO, STL->TL_TAREFA, STL->TL_SEQRELA,;
					aInsert[nInput,_OCCURRENCES_] )

			EndIf

		Next nInput

	EndIf

	// Deleção de insumos
	If !Empty( aInputs[_REALIZED_,_DELETE_] )

		// Forma de facilitar a codificação e entendimento da matriz.
		aDelete := aClone( aInputs[_REALIZED_,_DELETE_] )

		For nInput := 1 To Len( aDelete )

			dbSelectArea( 'STL' )
			dbSetOrder( 1 ) // TL_FILIAL + TL_ORDEM + TL_PLANO + TL_TAREFA + TL_TIPOREG + TL_CODIGO + TL_SEQRELA + TL_SEQTARE
			If msSeek( FwxFilial( 'STL' ) + STJ->TJ_ORDEM + STJ->TJ_PLANO + aDelete[nInput,_KEYTASK_] + aDelete[nInput,_TYPE_] +;
				aDelete[nInput,_KEYCODE_] + aDelete[nInput,_SEQUENCE_] )

				// Verificar se o insumo foi gerado por meio de uma requisicao do estoque e nao deleta
				// Insumos realizados com solicitação de armazém não devem ser deletados
	            If ( STL->TL_ORIGNFE $ 'SD3%SD1' ) .Or. ( !Empty( STL->TL_NUMSA ) )
	                Loop
	            EndIf

				printf( '  - Excluindo insumo realizado: ' + Trim( STL->TL_TAREFA ) + '/' + Trim( STL->TL_CODIGO ) +;
					' (' + cValToChar( STL->TL_QUANTID ) + ')' )

	            cError := RevMovSto()

				If !Empty( cError )
					printf( cError )
					Return cError
				EndIf

				dbSelectArea("TPZ")
				dbSetOrder(1)
				dbSeek(FwxFilial("TPZ")+STJ->TJ_ORDEM+STJ->TJ_PLANO)
	            While !EoF() .And. TPZ->(TPZ_FILIAL+TPZ_ORDEM+TPZ_PLANO+TPZ_SEQREL) == FwxFilial("TPZ")+STJ->TJ_ORDEM+STJ->TJ_PLANO+STL->TL_SEQRELA
					RecLock("TPZ",.F.)
					DbDelete()
					TPZ->(MsUnLock())
					TPZ->(dbSkip())
				EndDo

				RecLock( 'STL', .F. )
					dbDelete()
				STL->( MsUnLock() )

			EndIf

		Next nInput

	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} InputSTLPrev
Realiza processamento dos insumos previstos

@author	Larissa Thaís de Farias
@since  24/03/16
@param cOrdem, string, número da Ordem de Serviço
@param lAltera, boolean, se operação é alteração
@param cType, string, tipo da OS, C: Corretiva, P: Preventiva
@return string, vazio ou descrição do erro
/*/
//---------------------------------------------------------------------
Static Function InputSTLPrev(cOrdem, cType, lAltera, oWS)

	Local nI     := 1
	Local nInput := 0
	Local cError := ""

	Private aDtSa  := {}

	//Variável aRotina é utilizada na função NGRETINS quando insumo tipo produto com estrutura
	Private aRotina := {}

	// Gravação e bloqueio de insumos
	If !Empty( aInputs[_FORESEEN_,_UPDATE_] ) .Or. !Empty( aInputs[_FORESEEN_,_INSERT_] )

		//-------------------------------------------------------------------
		// Realiza a criação dos Insumos Previstos e gera array de bloqueio
		//-------------------------------------------------------------------
		aBLO := NGGSTLSTQ( STJ->TJ_ORDEM, STJ->TJ_PLANO, STJ->TJ_CCUSTO, oWs )

		//-------------------------------------------------------------
		// Efetua o bloqueio de Ferramentas
		//-------------------------------------------------------------
		For nI := 1 to Len(aBLO[1])
			printf( ' - Bloqueando Ferramentas' )
			a330FER(aBLO[1][nI])
		Next nI

		//-------------------------------------------------------------
		// Efetua o bloqueio de Mao de Obra
		//-------------------------------------------------------------
		For nI := 1 To Len(aBLO[2])
			printf(" - Bloqueando Mao de Obra")
			a330FUN(aBLO[2][nI])
		Next nI

		//-------------------------------------------------------------
		// Efetua o bloqueio de Especialistas
		//-------------------------------------------------------------
		For nI := 1 To Len(aBLO[3])
			printf(" - Bloqueando Especialistas")
			a330ESP(aBLO[3][nI])
		Next nI

		//-------------------------------------------------------------
		// Efetua o bloqueio de Produtos
		//-------------------------------------------------------------
		If Len(aBLO[4]) > 0

			cError := blockProduct(3, lAltera )

		EndIf

		//-------------------------------------------------------------
		// Gera Solicitacao de compra para terceiros
		//-------------------------------------------------------------
		If Empty( cError ) .And. Len( aBLO[5] ) > 0

			blockThird()

		EndIf

		aBLO := {}

	EndIf

	// Deleção de insumos
	If !Empty( aInputs[_FORESEEN_,_DELETE_] )

		// Forma de facilitar a codificação e entendimento da matriz.
		aDelete := aClone( aInputs[_FORESEEN_,_DELETE_] )

		For nInput := 1 To Len( aDelete )

			dbSelectArea( 'STL' )
			dbSetOrder( 1 ) // TL_FILIAL + TL_ORDEM + TL_PLANO + TL_TAREFA + TL_TIPOREG + TL_CODIGO + TL_SEQRELA + TL_SEQTARE
			If msSeek( FwxFilial( 'STL' ) + STJ->TJ_ORDEM + STJ->TJ_PLANO + aDelete[nInput,_KEYTASK_] + aDelete[nInput,_TYPE_] +;
				aDelete[nInput,_KEYCODE_] + aDelete[nInput,_SEQUENCE_] + aDelete[nInput,_SEQTASK_] )

				// Remove relacionamentos associados ao insumo.
				DeleteRelation()

				printf( '  - Excluindo insumo previsto: ' + Trim( STL->TL_TAREFA ) + '/' + Trim( STL->TL_CODIGO ) +;
						' (' + cValToChar( STL->TL_QUANTID ) + ')' )

				RecLock( 'STL', .F. )
					dbDelete()
				STL->( MsUnLock() )

			EndIf

		Next nInput

	EndIf

Return cError


//---------------------------------------------------------------------
/*/{Protheus.doc} NGGSTLSTQ
Grava as etapas e insumos previstos

@author	Larissa Thaís de Farias
@since	24/03/16

@param cORDEM, string, numero da Ordem de Servico
@param cPLANOOS, string, numero do plano da Ordem de Servico
@param cCENTCUS, string, codigo do centro de custo

@return aBLO, array, insumos para fazer bloqueio
/*/
//---------------------------------------------------------------------
Static Function NGGSTLSTQ( cORDEM, cPLANOOS, cCENTCUS, oWS )

	Local aBlo      := { {}, {}, {}, {}, {} }
	Local cUsaBloqC := AllTrim(GETMV("MV_NGCORPR"))
	Local cRecno := ''
	Local aTask  := {}
	Local nInput := 0
	Local nOpcX  := 0

	If cPLANOOS > "000000"
		M->TI_BLOQFUN := "S"
		M->TI_BLOQFER := "S"
		M->TI_BLOQITE := "S"
		M->TI_PLANO   := cPLANOOS
	Else
		M->TI_BLOQFUN := If(cUsaBloqC == "S","S","N")
		M->TI_BLOQFER := If(cUsaBloqC == "S","S","N")
		M->TI_BLOQITE := If(cUsaBloqC == "S","S","N")
		M->TI_PLANO   := cPLANOOS
	EndIf

	/*
		Loop executado duas vezes para que possa abranger insumos previstos do processo de inclusão/alteração.
	*/
	For nOpcX := 1 To 2

		aTask := aClone( aInputs[_FORESEEN_,nOpcX] )

		For nInput := 1 to Len( aTask )

			dbSelectArea( 'STL' )
			dbSetOrder( 1 ) // TL_FILIAL + TL_ORDEM + TL_PLANO + TL_TAREFA + TL_TIPOREG + TL_CODIGO + TL_SEQRELA + TL_SEQTARE
			If nOpcX == 1 .And. msSeek( FwxFilial( 'STL' ) + STJ->TJ_ORDEM + STJ->TJ_PLANO + aTask[nInput,_KEYTASK_] + aTask[nInput,_TYPE_] +;
				aTask[nInput,_KEYCODE_] + aTask[nInput,_SEQUENCE_] + aTask[nInput,_SEQTASK_] )

				printf( ' - Modificando insumo previsto: ' + Trim( aTask[nInput,_KEYTASK_] ) + '/' + Trim( aTask[nInput,_KEYCODE_] ) +;
					' -> ' + Trim( aTask[nInput,_TASK_] ) + '/' + Trim( aTask[nInput,_CODE_] ) +;
					' ( ' + cValToChar( aTask[nInput,_AMOUNT_] ) + ' )' )

				// Remove relacionamentos associados ao insumo.
				DeleteRelation( @aTask[nInput] )

				RecLock( 'STL', .F. )

			Else

				printf( ' - Incluindo insumo previsto ' + Trim( aTask[nInput,_TASK_] ) + '/' + Trim( aTask[nInput,_CODE_] ) +;
					'( ' + cValToChar( aTask[nInput,_AMOUNT_] ) + ' )' )

				RecLock( 'STL', .T. )
				STL->TL_FILIAL  := FwxFilial( 'STL' )
				STL->TL_ORDEM   := cORDEM
				STL->TL_PLANO   := cPLANOOS

			EndIf

			STL->TL_TAREFA  := aTask[nInput,_TASK_]
			STL->TL_TIPOREG := aTask[nInput,_TYPE_]
			STL->TL_CODIGO  := aTask[nInput,_CODE_]
			STL->TL_SEQRELA := '0  '
			STL->TL_SEQTARE := aTask[nInput,_SEQTASK_]
			STL->TL_DTINICI := aTask[nInput,_STARTDATE_]
			STL->TL_HOINICI := aTask[nInput,_STARTHOUR_]
			STL->TL_DTFIM   := aTask[nInput,_ENDDATE_]
			STL->TL_HOFIM   := aTask[nInput,_ENDHOUR_]
			STL->TL_QUANREC := aTask[nInput,_RESOURCEAMOUNT_]
			STL->TL_QUANTID := aTask[nInput,_AMOUNT_]
			STL->TL_UNIDADE := aTask[nInput,_UNITY_]
			STL->TL_DESTINO := aTask[nInput,_DESTINY_]
			STL->TL_LOCAL   := aTask[nInput,_WAREHOUSE_]
			STL->TL_TIPOHOR := aTask[nInput,_HOURUNITY_]
			STL->TL_USACALE := aTask[nInput,_USECALE_]
			STL->TL_FORNEC  := aTask[nInput,_SUPPLIER_]
			STL->TL_LOJA    := aTask[nInput,_STORE_]
			STL->TL_NUMSA   := aTask[nInput,_WHREQUEST_]
			STL->TL_ITEMSA  := aTask[nInput,_WHITEM_]
			STL->TL_OBSERVA := aTask[nInput,_INPUTNOTE_]
			STL->TL_CUSTO   := NGCALCUSTI( aTask[nInput,_CODE_], aTask[nInput,_TYPE_], aTask[nInput,_AMOUNT_], ,;
				aTask[nInput,_HOURUNITY_] )

			STL->(MsUnlock())


			If lPeMntNg
				ExecBlock("MNTNG",.F.,.F.,{ "CREATED_PLANNED_INPUT", oWs })
			EndIf

			cRecno := STL->( Recno() )

			nTIP := 0
			If aTask[nInput,_TYPE_] == "F"
				nTIP := If(M->TI_BLOQFER == "S",1,0)
			ElseIf aTask[nInput,_TYPE_] == "M"
				nTIP := If(M->TI_BLOQFUN == "S",2,0)
			ElseIf aTask[nInput,_TYPE_] == "E"
				nTIP := If(M->TI_BLOQFUN == "S",3,0)
			ElseIf aTask[nInput,_TYPE_] == "P"
				nTIP := If(M->TI_BLOQITE == "S",4,0)
			ElseIf aTask[nInput,_TYPE_] == "T"
				nTIP := If(M->TI_BLOQITE == "S",5,0)
			EndIf

			If nTIP > 0 .And. Empty(STL->TL_NUMSA+STL->TL_ITEMSA)

				//---------------------
				// Estrutura array aBlo, grava STL
				//---------------------
				aAdd( aBlo[nTIP] , MntBloArr( cRecno, cCENTCUS ) )

			EndIf

		Next nInput

	Next nOpcX

Return aBLO

//---------------------------------------------------------------------
/*/{Protheus.doc} blockProduct
Bloqueia Produtos
@type function

@author	Larissa Thaís de Farias
@since	24/03/2016

@param  nOpM    , numérico, número da operação
@return Caracter, Mensagem de erro, caso tenha.

@obs Cópia da função A330PRO
/*/
//---------------------------------------------------------------------
Static Function blockProduct(nOpM, lAltera )

	Local aRet       := { .T., '' }
	Local lLogix     := AllTrim( GetNewPar("MV_NGINTER", "N") ) == "L"
	Local lNGTARGE   := SuperGetMV( 'MV_NGTARGE', .F., '2' ) == '1'
	Local lNGGERSA   := SuperGetMV( 'MV_NGGERSA', .F., 'N' ) == 'S'
	Local lNGMNTAS   := SuperGetMV( 'MV_NGMNTAS', .F., '2' ) == '1'
	Local aLinhaProd := {}

	Private aIAglu := {} // [PRODUTO],[LOCAL],[QUANTIDADE],[OP],[TAREFA],[C.C.],[DT. INICIO],[RESERVA],[ORDEM],[PLANO]....[QUANTIDADE REAL]
	Private nPRO := 1 //Variavel utilizada pela funcao NGPRODALTER
	Private lGeraSA	:= NG420CHKSA()
	Private aSCGer	:= {}
	Private	cNuISC1 := 0 //utilizada na S.C.

	//Variáveis utilizadas para não ocorrer erros nas chamadas de funções posteriorres a blockProduct
	M->TJ_ORDEM := STJ->TJ_ORDEM
	M->TJ_PLANO := STJ->TJ_PLANO
	M->TJ_CODBEM:= STJ->TJ_CODBEM

	cOP  := M->TJ_ORDEM + "OS001"
	cOP := Alltrim(cOP)+Space(Len(SC1->C1_OP) - Len(Alltrim(cOP)))

	printf(" - Bloqueando Produtos")

	While nPRO <= Len(aBLO[4])

		Iold		:= nPRO
		cCodPro		:= Left(aBLO[4][nPRO][2], Len(SB1->B1_COD))
		cOP			:= AllTrim(aBLO[4][nPRO][8]) + "OS001"
		cOP			:= Alltrim(cOP)+Space(Len(SC1->C1_OP) - Len(Alltrim(cOP)))
		cLOCSTL		:= aBLO[4][nPRO][18]
		cLocAux		:= aBLO[4][nPRO][18]
		nQTDCOMP	:= aBLO[4][nPRO][3] //0.00
		lPROBLEMA	:= .F.
		cALMCOMP	:= '01'
		cALMEMPE	:= '01'
		cOPrin		:= cOP
		cTAREFA		:= aBLO[4][nPRO][1]

		If lNGTARGE .And. lNGGERSA .And. !lNGMNTAS

			nPosSC := aScan( aIAglu, { |x| x[5] + x[1] + x[2] == cTarefa + cCodPro + cLocSTL } )

		Else
		
			nPosSC := aScan( aIAglu, { |x| x[1] + x[2] == cCodPro + cLocSTL } )

		EndIf

		If nPosSC > 0

			aIAglu[nPosSC][3] += nQTDCOMP

			If lAltera
				aIAglu[nPosSC,Len(aIAglu[nPosSC])] += nQTDCOMP
			EndIf

		Else

			aAdd( aIAglu, { cCodPro, cLOCSTL, nQTDCOMP, cOp, cTAREFA, STJ->TJ_CCUSTO,;
				aBLO[4][nPRO][4], "S", aBLO[4,nPRO,8], aBLO[4,nPRO, 9] } )

			If lAltera

				Aadd(aIAglu[Len(aIAglu)],nQTDCOMP)
			
			EndIf

		EndIf

		nPRO++

	End

	If STJ->TJ_SITUACA == "L"

		If lAltera
			// RETIRA A QUANTIDADE JA SOLICITADA, ESTA NO NGUTIL02
			NGRETJACOMP(cOP)
		EndIf

		If lLogix .And. Empty(aLinhaProd)
			dbSelectArea("STL")
			dbSetOrder(1)
			If dbSeek( FwxFilial("STL") + STJ->TJ_ORDEM + STJ->TJ_PLANO )
				While !Eof() .And. STJ->TJ_ORDEM == STL->TL_ORDEM .And. STJ->TJ_PLANO == STL->TL_PLANO
					If Alltrim(STL->TL_SEQRELA) == "0"
						aAdd(aLinhaProd, {STL->TL_CODIGO, STL->TL_ORDEM, STL->TL_QUANTID, STL->TL_CODAEN})
					EndIf

					dbSelectArea("STL")
					dbSkip()
				End
			EndIf
		EndIf

		aRet := NGINTCOMPEST( STJ->TJ_DTMPINI, STJ->TJ_DTMPFIM, 'MNTA420', , aLinhaProd, , .T. )

	EndIf

	aIAglu := {}

Return IIf( ValType( aRet ) == 'A', aRet[2], '' )

//---------------------------------------------------------------------
/*/{Protheus.doc} blockThird
Bloqueia Terceiros

@author	Larissa Thaís de Farias
@since	24/03/16
@obs Cópia da função A330TER
@return nil
/*/
//---------------------------------------------------------------------
Static Function blockThird()

	Local i := 0
	Local cAlmox := PADR( SuperGetMV("MV_NGLOCPA",.F.,"01") , Len(STL->TL_LOCAL) )

	printf( ' - Gera S.A./S.C. para terceiros' )

	//Ordena registros conforme a maior quantidade solicitada
	aSort(aBLO[5],,,{|x,y| x[3] > y[3]})
	For i := 1 To Len(aBLO[5])

		If STJ->TJ_SITUACA = "L"
			If Empty(aBLO[5][i][18])
				a340TER(aBLO[5][i],cAlmox,aBLO[5][i][3],aBLO[5][i][19],.F.,i)
			Else
				a340TER(aBLO[5][i],aBLO[5][i][18],aBLO[5][i][3],aBLO[5][i][19],.F.,i)
			EndIf
		EndIf

	Next i

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MntBloArr
Preenche array aBlo com informacoes do insumo

@Param	nRecnoSTL - Registro da STL

@author Lucas Guszak
@author Larissa Farias
@since 29/08/2014
@param nRecnoSTL, numérico, recno da STL
@return .T.
/*/
//---------------------------------------------------------------------
Static Function MntBloArr( nRecnoSTL, cCusto )

	Local nQuantid  := 0
	Local aBloqueio := {}
	Local aAreaSTL  := STL->( GetArea() )
	Local cLocalSpc := Space(TamSx3('TL_LOCAL')[1])

	//------------------------------------------------
	// Posiciona no registro( Insumo ) a ser bloqueado
	//------------------------------------------------
	DbSelectArea( "STL" )
	DbGoTo( nRecnoSTL )

	//---------------------------------------------------------
	// Atribui quantidade para bloqueio conforme tipo do insumo
	//---------------------------------------------------------
	If STL->TL_TIPOREG $ "E/F"
		nQuantid := STL->TL_QUANREC
	Else
		nQuantid := STL->TL_QUANTID
	EndIf

	//---------------------
	// Estrutura array aBlo
	//---------------------
	aAdd( aBloqueio , STL->TL_TAREFA	) // 01 - Tarefa
	aAdd( aBloqueio , STL->TL_CODIGO	) // 02 - Codigo Insumo
	aAdd( aBloqueio , nQuantid			) // 03 - Quantidade
	aAdd( aBloqueio , STL->TL_DTINICI	) // 04 - Data Inicio
	aAdd( aBloqueio , STL->TL_HOINICI	) // 05 - Hora Inicio
	aAdd( aBloqueio , STL->TL_DTFIM		) // 06 - Data Fim
	aAdd( aBloqueio , STL->TL_HOFIM		) // 07 - Hora Fim
	aAdd( aBloqueio , STL->TL_ORDEM		) // 08 - Ordem de Servico
	aAdd( aBloqueio , STL->TL_PLANO		) // 09 - Plano
	aAdd( aBloqueio , cCusto			) // 10 - Centro de Custo	
	aAdd( aBloqueio , STL->TL_NUMSC		) // 11 - Numero da SC
	aAdd( aBloqueio , STL->TL_ITEMSC	) // 12 - Numero do Item da SC
	aAdd( aBloqueio , 0.00				) // 13 - Quantidade do Estoque da Opercao - TL_QTDOPER
	aAdd( aBloqueio , cLocalSpc         ) // 14 - Almoxarifado da Operacao - TL_ALMOPERA
	aAdd( aBloqueio , 0.00				) // 15 - Quantidade de estoque da matriz - TL_QTDOMAT
	aAdd( aBloqueio , cLocalSpc         ) // 16 - Almoxarifado da matriz - TL_ALMOMAT
	aAdd( aBloqueio , 0.00				) // 17 - Quantidade da SC  - TL_QTDSC1
	aAdd( aBloqueio , STL->TL_LOCAL		) // 18 - Codigo do local gravado na STL
	aAdd( aBloqueio , STL->TL_UNIDADE	) // 19 - Unidade
	aAdd( aBloqueio , ''                ) // 20 - Observacao do Insumo
	aAdd( aBloqueio , 0.00				) // 21 - Quantidade da SC TL_QTDSC1
	aAdd( aBloqueio , STL->TL_FORNEC	) // 22 - Fornecedor TL_FORNEC
	aAdd( aBloqueio , STL->TL_LOJA		) // 23 - Loja do fornecedor TL_LOJA
	aAdd( aBloqueio , STL->TL_NUMSA		) // 24 - Número da S.A
	aAdd( aBloqueio , STL->TL_ITEMSA	) // 25 - Item S.A
	aAdd( aBloqueio , STL->TL_LOCALIZ	) // 26 - Localização

	RestArea( aAreaSTL )

Return aBloqueio

//---------------------------------------------------------------------
/*/{Protheus.doc}  fEqualOrder
Verifica se a OS já tenha foi inserida.
obs.: ocorre caso o aplicativo envie a requisição de create
e a internet caia antes de o WS dar o retorno.

@param aStartDate, array, data e Hora de início
@param cObservation, string, observação
@param nCounter, numérico, valor do primeiro contador
@param nCounter2, numérico, valor do segundo contador
@param cService, string, serviço
@param aEndDate, array, data e Hora de Fim
@param cEquipment, string, equipamento
@param cSequence, string, sequencia (caso Preventiva)
@param cType, string, tipo da ordem "P" para preventiva ou "C" para corretiva
@param dDtStopIni, date, data da parada
@param cHrStopIni, hora, hora da parada

@author Larissa Thaís de Farias
@since 08/04/2016
@return string, vazio ou código da ordem quando encontrada
/*/
//---------------------------------------------------------------------
Static Function fEqualOrder( aStartDate, cObservation, nCounter, nCounter2,;
				cService, aEndDate, cEquipment, cSequence, cType, dDtStopIni, cHrStopIni )

	Local cAliasQry := GetNextAlias()
	Local cOrdem    := ""
	Local cCondSql	:= "%%"

	If cType == "C"
		cCondSql := "%AND STJ.TJ_DTPRINI = " + ValToSQL( dDtStopIni ) + " AND STJ.TJ_HOPRINI = " + ValToSQL( cHrStopIni ) + "%"
	EndIf

	//-----------------------------------------
	// Busca O.S com mesmas características
	//-----------------------------------------
	BeginSql Alias cAliasQry

		SELECT STJ.TJ_ORDEM
		FROM %Table:STJ% STJ
		WHERE STJ.TJ_FILIAL = %xFilial:STJ%
			AND STJ.TJ_CODBEM = %exp:cEquipment%
			AND STJ.TJ_SERVICO = %exp:cService%
			AND STJ.TJ_SEQRELA = %exp:cSequence%
			AND STJ.TJ_DTMPINI = %exp:Stod( aStartDate[1] )%
			AND STJ.TJ_HOMPINI = %exp:aStartDate[2]%
			AND STJ.TJ_DTMPFIM = %exp:Stod( aEndDate[1] )%
			AND STJ.TJ_HOMPFIM = %exp:aEndDate[2]%
			AND STJ.TJ_POSCONT = %exp:nCounter%
			AND STJ.TJ_POSCON2 = %exp:nCounter2%
			AND STJ.TJ_SITUACA = 'L'
			AND %notDel%
			%exp:cCondSql%
		ORDER BY STJ.TJ_ORDEM DESC

	EndSql

	If !( cAliasQry )->( EoF() )
		cOrdem := (cAliasQry)->TJ_ORDEM
	EndIf

	(cAliasQry)->(dbCloseArea())

	If Empty( cOrdem )
		Return ""
	EndIf

	//-------------------------------------------------------
	// Trechos a seguir compara outras caracterícticas da OS
	//-------------------------------------------------------
	dbSelectArea("STJ")
	dbSetOrder(1)
	If !dbSeek( FwxFilial("STJ") + cOrdem ) .Or. Alltrim( STJ->TJ_OBSERVA ) != Alltrim( cObservation )
		Return ""
	EndIf

	// Quando insumos do json = zero e há STL
	dbSelectArea( 'STL' )
	dbSetOrder( 1 )
	If ( Empty( aInputs[_REALIZED_,_INSERT_] ) .Or. Empty( aInputs[_REALIZED_,_UPDATE_] ) .Or. Empty( aInputs[_REALIZED_,_DELETE_] ) ) .And.;
	   ( Empty( aInputs[_FORESEEN_,_INSERT_] ) .Or. Empty( aInputs[_FORESEEN_,_UPDATE_] ) .Or. Empty( aInputs[_FORESEEN_,_DELETE_] ) ) .And.;
	   dbSeek( FwxFilial( 'STL' ) + cOrdem )
		Return ''
	EndIf

Return cOrdem

//---------------------------------------------------------------------
/*/{Protheus.doc} verifyInput
Verifica se possui pelo menos um insumo realizado

@param cCode, string, código da ordem de serviço
@param cPlan, string, plano da ordem de serviço
@author Maria Elisandra de Paula
@since 23/05/2016
@return logic, se há pelo menos um insumo realizado
/*/
//---------------------------------------------------------------------
Static Function verifyInput(cCode, cPlan)

	/*
	Obs.: não utilizamos consultas por query pois ao conectar o banco ainda não estarão gravadas/liberadas
	as tabelas necessárias para validação (devido ao beginTransaction)
	*/
	dbSelectArea("STL")
	dbSetOrder(1)
	dbSeek(FwxFilial("STL")+cCode+cPlan)
	While !Eof() .And. STL->TL_FILIAL == FwxFilial("STL") .And. STL->TL_ORDEM == cCode .And. STL->TL_PLANO == cPlan

		If Val(STL->TL_SEQRELA) > 0
			Return .T.
		EndIf

		dbSkip()
	EndDo

Return .F.

//---------------------------------------------------------------------
/*/{Protheus.doc} MakeFilter
Gera, parcialmente, uma query que localiza ou rejeita os itens baseados em
sua chave primária

@author	Larissa Thaís de Farias
@author Marcelo Camargo
@since 02/06/2016
@param aArray, array, valores vindos do portal
@param cField, string, campo no qual será aplicado o filtro
@param lNotIn, boolean, se permite concatenar "NOT" na string
@return string, utilizada em condições where
/*/
//---------------------------------------------------------------------
Static Function MakeFilter( aArray, cField , lNotIn)
	Local cQuery := ""
	Local nI
	Default lNotIn := .t.

	If Len( aArray ) > 1
		cQuery += " AND " + cField + " "

		If aArray[ 1 ] == "reject" .And. lNotIn
			cQuery += "NOT "
		EndIf
		cQuery += "IN ("

		For nI := 2 To Len( aArray )
			If nI > 2
				cQuery += ','
			EndIf

			cQuery += "'" + aArray[ nI ] + "'"
		Next nI
		cQuery += ") "
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} playStop
Aponta um insumo como realizado e grava a hora ínicio e fim de um insumo

@author Larissa Thaís de Farias
@param cBody, string, objeto com o JSON que contém os dados para o play e stop
@since 06/06/2016
@return array, [1] sucesso da operação, [2] json para retorno
/*/
//---------------------------------------------------------------------
Function playStop(cBody)

	Local oParser
	Local cError := ""
	Local cOrder
	Local cPlan
	Local cJson
	Local lRet := .T.
	Local dMvUlmes := SuperGetMv("MV_ULMES",.F.,Stod(""))
	Local cUsaIntEs := SuperGetMv("MV_NGMNTES",.F.,"N")

	printf('Inicio de reporte via PlayStop')

	If FWJsonDeserialize(cBody,@oParser)

		cOrder  := oParser:order
		cPlan	:= oParser:plan
		oParser := oParser:json

		DbSelectArea("STJ")
		dbSetOrder(1)

		If dbSeek(FwxFilial('STJ')+cOrder+cPlan) .and. STJ->TJ_TERMINO == 'N' .and. STJ->TJ_SITUACA == 'L'

			//---------------------------------------------------------------------------
			// Trecho abaixo abre as tabelas para tratar msg "AJUSTAR PARAMETRO MV_DOCSEQ"
			//---------------------------------------------------------------------------

			If Select('SD1') <= 0
				dbSelectArea('SD1')
			EndIf
			If Select('SD2') <= 0
				dbSelectArea('SD2')
			EndIf
			If Select('SD3') <= 0
				dbSelectArea('SD3')
			EndIf

			cError := getInputs( oParser, , , , , .T. )

            If Empty(cError)

				// Valida se há conflito de horários nos insumos de mão de obra
                If aInputs[_REALIZED_,_INSERT_,1,_TYPE_] == 'M' .And. !NGVALDATIN( aInputs[_REALIZED_,_INSERT_,1,_CODE_], cOrder, cPlan,;
					aInputs[_REALIZED_,_INSERT_,1,_STARTDATE_], aInputs[_REALIZED_,_INSERT_,1,_STARTHOUR_], aInputs[_REALIZED_,_INSERT_,1,_ENDDATE_],;
					aInputs[_REALIZED_,_INSERT_,1,_ENDHOUR_], aInputs[_REALIZED_,_INSERT_,1,_TYPE_], , 'STL', , )[1]

                    // Conflito de horários no insumo de mão de obra do funcionário: # entre o período de # até
					Return { .F., STR0031 + ' ' + NGSeek( 'ST1', aInputs[_REALIZED_,_INSERT_,1,_CODE_], 1, 'T1_NOME' ) + ' ' + STR0032 + ' ' +;
						dToC( aInputs[_REALIZED_,_INSERT_,1,_STARTDATE_] ) + ' ' + aInputs[_REALIZED_,_INSERT_,1,_STARTHOUR_] + ' ' + STR0033 + ' ' +;
						dToC( aInputs[_REALIZED_,_INSERT_,1,_ENDDATE_] )   + ' ' + aInputs[_REALIZED_,_INSERT_,1,_ENDHOUR_]   + '.' }

                EndIf

				//Valida data de fechamento de estoque
				If aInputs[_REALIZED_,_INSERT_,1,_TYPE_] == 'M' .And. cUsaIntEs == 'S' .And. aInputs[_REALIZED_,_INSERT_,1,_STARTDATE_] <= dMvUlmes

					// A data não pode ser menor ou igual a data do último fechamento do estoque
					Return { .F., STR0084 + ' ' + dToC( dMvUlmes ) }

				EndIf

				printf( ' - Inclusao de insumo realizado via PlayStop ' + Trim( aInputs[_REALIZED_,_INSERT_,1,_TASK_] ) + '/' +;
					Trim( aInputs[_REALIZED_,_INSERT_,1,_CODE_] ) + ' ( ' + cValtochar( aInputs[_REALIZED_,_INSERT_,1,_AMOUNT_] ) + ' )' )

                NGRETINS(	cOrder				  						,;
                		  	cPlan 				  						,;
                		 	oParser[1]:type		  						,;
							      				  						,;
                    			  				  						,;
                    			  				  						,;
                    		aInputs[_REALIZED_,_INSERT_,1,_TASK_]     	,;
                    		aInputs[_REALIZED_,_INSERT_,1,_TYPE_]     	,;
                    		aInputs[_REALIZED_,_INSERT_,1,_CODE_]     	,;
                    		aInputs[_REALIZED_,_INSERT_,1,_AMOUNT_]   	,;
                    		aInputs[_REALIZED_,_INSERT_,1,_UNITY_]    	,;
                    		aInputs[_REALIZED_,_INSERT_,1,_DESTINY_]  	,;
                    		'Insumo Realizado.'   						,;
                    		aInputs[_REALIZED_,_INSERT_,1,_STARTDATE_]	,;
                    		aInputs[_REALIZED_,_INSERT_,1,_STARTHOUR_]	,;
                    		"F"                   						,;
                    		aInputs[_REALIZED_,_INSERT_,1,_WAREHOUSE_]	,;
                    							  						,;
                    							  						,;
                    							  						,;
                    							  						,;
                    		aInputs[_REALIZED_,_INSERT_,1,_PERCENT_]  	,;
                    		aInputs[_REALIZED_,_INSERT_,1,_USECALE_]  	,;
                    		"N"     			  						,;
                    							  						,;
                    							  						,;
                    							 						,;
                    							  						,;
                    		.T.					  						,;
                    		@cError				   						;
                    	)
            EndIf

		Else
			cError := STR0035 // "Insumo não enviado."
		EndIf
	Else
		cError := STR0022 // "Json inválido."
	EndIf

	If Empty(cError)
		cJson := JSONResult(  )
	Else
		cJson := cError
		lRet := .F.
	EndIf

	printf('Final de reporte via PlayStop.')

return { lRet, cJson }

//---------------------------------------------------------------------
/*/{Protheus.doc} validCounter
Valida contador

@author Larissa Thaís de Farias
@since 06/06/2016
@param cEquipment, string, código do Bem
@param nCounter, numérico, leitura do contador
@param dDate, data, data da leitura
@param cHour, string, hora da Leitura
@param nTipoC, numérico, tipo do contador (Primeiro ou Segundo)
@return string, vazio ou descrição do erro
/*/
//---------------------------------------------------------------------
Static Function ValidCounter(cEquipment, nCounter, dDate, cHour , nTipoC)

	Local aVerifica
	Local aValida := {}

	Default dDate := dDataBase
	Default cHour := SubStr( Time(), 1, 5 )
	Default nTipoC:= 1

	If nTipoC == 1
		aValida:= {"ST9","STP","STP->TP_ACUMCON"}
	Else
		aValida:= {"TPE","TPP","TPP->TPP_ACUMCO"}
	EndIf

	If !Positivo(nCounter) .Or. nCounter == 0
		Return STR0036 // "Contador vazio ou não possui um valor positivo."
	End

	// Valida data e/ou hora posterior
	If ( DToS( dDate ) + cHour ) > ( DToS( Date() ) + SubStr( Time(), 1, 5 ) )

		// A hora de leitura do contador 1: XX:XX não deve ser maior que a hora atual do sistema: XX:XX
		Return STR0041 + Trim( cValToChar( nTipoC ) ) + ': ' + cHour + STR0176 + SubStr( Time(), 1, 5 )

	EndIf

	aVerifica := NGCHKHISTO( cEquipment, dDate, nCounter, cHour, nTipoC, , .F., , , .F. )

	If !aVerifica[1]
		Return STR0037+" "+aVerifica[2] //"Problemas com o histórico do contador: "
	EndIf

	If !CHKPOSLIM(cEquipment,nCounter,nTipoC)
		Return STR0038 // "Contador excede o seu limite. Favor verificar troca de contador."
	End

	//Obs.: A validação de variação dia não é necessária pois no padrão existe um MsgYesNo, deixando que o usuário prossiga com a operação

Return ""

//---------------------------------------------------------------------
/*/{Protheus.doc} MntWSError
Faz tratamento de erro.log

@param, oError, objeto, objeto errorblock
@author Larissa Thaís de Farias
@since 04/04/2016
@return nil
/*/
//---------------------------------------------------------------------
Function MntWSError( oError )

	conout('','')
	printf('Inicio de tratamento de erro-----------------------')
	printf('O seguinte erro ocorreu: ' + oError:Description)
	printf('------------------------------------------------------------------')
	conout('','')
	printf('Stack: ' + oError:ErrorStack)
	printf('Fim do tratamento de erro-----------------------')
	conout('','')

	SetRestFault(500, EncodeUtf8( STR0128 + ": " + oError:Description) ) //"O seguinte erro ocorreu"

	DisarmTransaction()

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} JSONResult
Formato do JSON para sucesso

@author	Marcelo Camargo
@since	 14/03/2016
@version P12
@return	string
/*/
//---------------------------------------------------------------------
Static Function JSONResult( cResult )
Return '{ "hasError": false, "hasStack": false' + If(!Empty(cResult),',"data": ' + cResult,'') + ' }'

//---------------------------------------------------------------------
/*/{Protheus.doc} fRetError
String no formato JSON para erro

@author	Maria Elisandra de Paula
@since 14/06/2022
@param cResult, string, descrição do erro
@param oSelf, objeto, instância do ws
@return	boolean, sempre verdadeiro
@obs retorna verdadeiro para neste caso possa ser tratado no aplicativo
/*/
//---------------------------------------------------------------------
Static Function fRetError(cResult,oSelf)
	oSelf:SetResponse('{ "hasError": true, "message":"' + EncodeUtf8( cResult ) + ' "}')
	Printf(cResult)
Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fItemInit
Retorna string com inicialização de uma entidade

@param cId, string, nome da entidade
@param cType, string, tipo de ação (update ou delete)
@author Maria Elisandra de Paula
@since 21/09/2022
/*/
//---------------------------------------------------------------------
Static Function fItemInit( cId, cType )
	Default cType := "update"
Return '{"name":"' + cId + '","action":"' + cType + '","data":['

//---------------------------------------------------------------------
/*/{Protheus.doc} fJsonDel
Grava/envia dados de delete

@param cId, string, nome da entidade
@param cType, string, tipo de ação (update ou delete)
@author Maria Elisandra de Paula
@since 21/09/2022
/*/
//---------------------------------------------------------------------
Static Function fJsonDel(oWs, cDelete, cId)

	If !Empty(cDelete)
		oWs:SetResponse( ',' + fItemInit( cId, 'delete' ))
		oWs:SetResponse( cDelete)
		oWs:SetResponse(']}')
	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fInsBase
Retorna string para query com insumos criados/alterados não deletados da ordem+plano

@param cOrdem, string, ordem de Serviço
@param cPlano, string, plano da ordem de serviço

@author	Maria Elisandra de Paula
@since 08/03/2017
@version P12
@return	string, query para buscar insumos
/*/
//---------------------------------------------------------------------
Static Function fInsBase( cOrdem, cPlano )

	Local cQuery:= " SELECT "

	cQuery += " 	TL_TAREFA, "
	cQuery += " 	TL_TIPOREG,"
	cQuery += " 	TL_TIPOHOR,"
	cQuery += " 	TL_CODIGO, "
	cQuery += " 	TL_SEQRELA,"
	cQuery += " 	TL_SEQTARE,"
	cQuery += " 	TL_QUANTID,"
	cQuery += " 	TL_QUANREC,"
	cQuery += " 	TL_OBSERVA,"
	cQuery += " 	TL_UNIDADE,"
	cQuery += " 	TL_DTINICI,"
	cQuery += " 	TL_HOINICI,"
	cQuery += " 	TL_DTFIM,  "
	cQuery += " 	TL_PERMDOE,"
	cQuery += " 	TL_HOFIM,  "
	cQuery += " 	TL_LOCAL,  "
	cQuery += " 	TL_LOCALIZ,"
	cQuery += " 	TL_NUMSERI,"
	cQuery += " 	TL_LOTECTL,"
	cQuery += " 	TL_NUMLOTE,"
	cQuery += "		TL_NUMSA, TL_ITEMSA,"
	cQuery += " 	TL_DESTINO,"
	cQuery += " 	TL_CUSTO, TL_FORNEC, TL_LOJA, TL_DTVALID"

	cQuery += " FROM " + RetSqlName("STL") + " STL "
	cQuery += " WHERE TL_FILIAL = "  + ValtoSql(FwxFilial("STL"))
	cQuery += " 	AND TL_ORDEM = " + ValtoSql(cOrdem)
	cQuery += " 	AND TL_PLANO = " + ValtoSql(cPlano)
	cQuery += "     AND D_E_L_E_T_ = ' ' "

Return cQuery

//-----------------------------------------------------------------------------
/*/{Protheus.doc} fValidIns
Valida insumos

@author	Maria Elisandra de Paula
@param cOrdem, string, ordem de Serviço
@param cPlano, string, plano da ordem de serviço
@param nOpc, numérico, operação: 3=inclui O.S, 4=altera O.S, 5=cancela O.S
@since 14/03/2017
@return	string, vazia ou com descrição do erro
/*/
//-----------------------------------------------------------------------------
Static Function fValidIns( cOrdem, cPlano , nOpc )

	Local cReturn  := ""
	Local aInsBase := {}
	Local nPosArr  := 0
	Local cAliasQry:= ""
	Local cQuery   := ""
	Local nY       := 0
	Local nOpcX    := 0
	Local nInput   := 0
	Local nI       := 0
	Local cOP      := ""
	Local lTemCotac:= .F.
	Local nQtdComp := 0
	Local aInsAPP  := {}
	Local aInsRastro:= {}
	Local aInsLocal := {}
	Local aInpRea   := {}
	Local aBaseRas:= {}
	Local aBaseLocal:= {}
	Local cUsaIntEs := SuperGetMv("MV_NGMNTES",.F.,"N")
	Local cInicio
	Local cFim
	Local dMvUlmes := SuperGetMv("MV_ULMES",.F.,Stod(""))
	Local nRegLog := 0

	Private aHEADER := {}

	For nOpcX := 1 To 6

		If nOpcX == 1
			aInputTemp := aClone( aInputs[_REALIZED_,_UPDATE_] ) // update realizados
		ElseIf nOpcX == 2
			aInputTemp := aClone( aInputs[_FORESEEN_,_UPDATE_] ) // update previstos
		ElseIf nOpcX == 3
			aInputTemp := aClone( aInputs[_REALIZED_,_INSERT_] ) // insert realizados
		ElseIf nOpcX == 4
			aInputTemp := aClone( aInputs[_FORESEEN_,_INSERT_] ) // insert previstos
		ElseIf nOpcX == 5
			aInputTemp := aClone( aInputs[_REALIZED_,_DELETE_] ) // delete realizados
		ElseIf nOpcX == 6
			aInputTemp := aClone( aInputs[_FORESEEN_,_DELETE_] ) // delete previstos
		EndIf

		For nInput := 1 to Len( aInputTemp )

			If nOpcX < 5 .And. aInputTemp[nInput,_TYPE_] == 'P' .And. Empty( aInputTemp[nInput,_WAREHOUSE_] )
				Return cOrdem + CRLF + STR0129 + ': ' + AllTrim( aInputTemp[nInput,_CODE_] ) // O almoxarifado é obrigatório. Produto
			EndIf

			If cUsaIntEs == 'S' .And. aInputTemp[nInput,_TYPE_] $ 'P/M' .And. aInputTemp[nInput,_STARTDATE_] <= dMvUlmes
				If nOpcX <= 4
					Return cOrdem + CRLF + STR0086 + ' ' + Dtoc( dMvUlmes ) //"Os insumos não podem ter a data menor ou igual a data do último fechamento do estoque"
				Else
					Return cOrdem + CRLF + STR0177 + ' ' + Dtoc( dMvUlmes ) // "Não é permitido excluir o insumo com data menor ou igual a data do último fechamento do estoque"
				EndIf
			EndIf

			If aInputTemp[nInput,_TYPE_] == 'M'

				dbSelectArea( 'ST1' )
				dbSetOrder( 1 ) // T1_FILIAL + T1_CODFUNC
				If msSeek( FwxFilial( 'ST1' ) + aInputTemp[nInput,_CODE_] ) .And. ST1->T1_DISPONI != 'S'
					Return STR0209 + CRLF; //'Funcionário da manutenção indisponível:'
							+ Trim( aInputTemp[nInput,_CODE_] ) + ' -> ' + Trim( ST1->T1_NOME )
				EndIf

			EndIf

		Next nInput

	Next nOpcX

	If nOpc == 4 .Or. nOpc == 5 // Alteração ou cancelamento

		cOP       := AllTrim(cOrdem) + "OS001"
		cQuery    := ChangeQuery( fInsBase(cOrdem, cPlano) )
		cAliasQry := GetNextAlias()

		dbUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),cAliasQry,.F.,.T.)

		dbSelectArea(cAliasQry)
		While !(cAliasQry)->(Eof())

			If nOpc == 5 .And. Val((cAliasQry)->TL_SEQRELA) > 0
				cReturn:=  " " + STR0042 // "Cancelamento não permitido, esta ordem de serviço já tem insumos reportados."
				Exit
			EndIf

			//aInsBase:insumos PREVISTOS (produtos/terceiros) - BASE
			If (cAliasQry)->TL_TIPOREG $ "P/T"
				If (nPosArr := aScan(aInsBase, {|x| x[1] + x[2] == (cAliasQry)->TL_CODIGO + (cAliasQry)->TL_LOCAL})) == 0
		    		aAdd(aInsBase, {(cAliasQry)->TL_CODIGO, (cAliasQry)->TL_LOCAL, 0 ,0 } )
		    		nPosArr := Len( aInsBase )
		    	EndIf
				aInsBase[nPosArr][3] += (cAliasQry)->TL_QUANTID

				nQtdComp := NGBUSC1COM( cOP, (cAliasQry)->TL_CODIGO, (cAliasQry)->TL_LOCAL, '' )
				aInsBase[nPosArr][4] := nQtdComp

				If nQtdComp > 0
					lTemCotac := .T.

					If nOpc == 5
						//Aqui já foi verificado que um item da base possui cotação
						cReturn := STR0043 // "Não é permitido cancelar a ordem de serviço, pois há solicitações de cotação em aberto para o item '"
						cReturn += Alltrim((cAliasQry)->TL_CODIGO) + STR0044 // "' . Verifique se as cotações para esta ordem de serviço foram liberadas. Se não libere-as."
						Exit
					EndIf

				EndIf
			EndIf

			If nOpc == 4

				//aBaseRas :insumos REALIZADOS para validação de Rastro - BASE
				If (cAliasQry)->TL_TIPOREG $ "P" .And. Val((cAliasQry)->TL_SEQRELA) > 0
					If (nPosArr :=  aScan(aBaseRas, {|x| x[1] + x[2] + x[3] + x[4] == ;
									(cAliasQry)->TL_CODIGO 	+ ;
									(cAliasQry)->TL_LOCAL 	+ ;
									(cAliasQry)->TL_LOTECTL + ;
									(cAliasQry)->TL_NUMLOTE })) == 0

			    		aAdd(aBaseRas, {(cAliasQry)->TL_CODIGO,(cAliasQry)->TL_LOCAL,(cAliasQry)->TL_LOTECTL ,(cAliasQry)->TL_NUMLOTE , 0 } )
			    		nPosArr := Len( aBaseRas )
			    	EndIf
					aBaseRas[nPosArr][5] += (cAliasQry)->TL_QUANTID
				EndIf

				//aBaseLocal :insumos REALIZADOS para validação de Localização - BASE
				If (cAliasQry)->TL_TIPOREG $ "P" .And. Val((cAliasQry)->TL_SEQRELA) > 0
					If (nPosArr :=  aScan(aBaseLocal, {|x| x[1] + x[2] + x[3] + x[4] + x[5] + x[6] == ;
									(cAliasQry)->TL_CODIGO 	+ ;
									(cAliasQry)->TL_LOCAL 	+ ;
									(cAliasQry)->TL_LOTECTL + ;
									(cAliasQry)->TL_NUMLOTE + ;
									(cAliasQry)->TL_LOCALIZ + ;
									(cAliasQry)->TL_NUMSERI  })) == 0

			    		aAdd(aBaseLocal, ;
			    				{(cAliasQry)->TL_CODIGO	,;
			    				(cAliasQry)->TL_LOCAL	,;
			    				(cAliasQry)->TL_LOTECTL ,;
			    				(cAliasQry)->TL_NUMLOTE	,;
			    				(cAliasQry)->TL_LOCALIZ ,;
			    				(cAliasQry)->TL_NUMSERI ,0 } )

			    		nPosArr := Len( aBaseLocal )
			    	EndIf
					aBaseLocal[nPosArr][7] += (cAliasQry)->TL_QUANTID
				EndIf
			EndIf

			(cAliasQry)->(dbSkip())
		EndDo

		(cAliasQry)->(dbCloseArea())

		//Neste bloco valida se algum item já tem cotação para não permitir alterar a quantidade para menos
		If Empty( cReturn ) .And. nOpc != 5

			If lTemCotac

				For nInput := 1 To Len( aInputs[_FORESEEN_,_UPDATE_] )

					// aInsAPP: Insumos PREVISTOS vindos do APP ( Produtos/Terceiros ).
					If aInputs[_FORESEEN_,_UPDATE_,nInput,_TYPE_] $ 'P/T'

						If ( nPosArr := aScan( aInsAPP, { |x| x[1] + x[2] == aInputs[_FORESEEN_,_UPDATE_,nInput,_KEYCODE_] +;
							aInputs[_FORESEEN_,_UPDATE_,nInput,_WAREHOUSE_] } ) ) == 0

				    		aAdd( aInsAPP, { aInputs[_FORESEEN_,_UPDATE_,nInput,_KEYCODE_], aInputs[_FORESEEN_,_UPDATE_,nInput,_WAREHOUSE_], 0 } )
				    		nPosArr := Len( aInsAPP )

				    	EndIf

						aInsAPP[nPosArr,3] += aInputs[_FORESEEN_,_UPDATE_,nInput,_AMOUNT_]

					EndIf

				Next nInput

				// Valida quantidade de insumos da base com cotados caso tenha cotação de compras
				For nInput := 1 To Len( aInsBase )

					If aInsBase[nInput,4] > 0

						// Identifica que um item da base possui cotação e está sendo modificado
						If ( nPosArr := aScan( aInsAPP, { |x| x[1] + x[2] == aInsBase[nInput,1] + aInsBase[nInput,2] } ) ) > 0 .And.;
							aInsAPP[nPosArr,3] < aInsBase[nInput,4]

							cReturn := STR0045 // Não é permitido modificar/excluir a ordem de serviço, pois há solicitações de cotação em aberto para o item
							cReturn += aInsBase[nInput,1] + STR0046 // Verifique se as cotações para esta ordem de serviço foram liberadas. Se não libere-as.
							Exit

						EndIf

					EndIf

				Next nInput

			EndIf

		EndIf

	EndIf

	// Neste bloco carrega vetores de itens e os valida caso tenha rastro e localização
	If Empty( cReturn ) .And. nOpc != 5

		// Verifica insumos das operações INSERT e UPDATE
		For nOpcX := 1 To 2

			aInpRea := aClone( aInputs[_REALIZED_,nOpcX] )

			// Carrega vetores de insumos realizados para validações
			If !Empty( aInpRea ) .And. cUsaIntEs == 'S'

				For nY := 1 To Len( aInpRea )

					If aInpRea[nY,_TYPE_] == 'P'

						/*
							aInsRastro: insumos REALIZADOS do mobile com soma dos repetidos para Rastro.
							{ TL_CODIGO, TL_LOCAL, TL_LOTECTL, TL_NUMLOTE, Total }
						*/
						If ( nPosArr := aScan( aInsRastro, { |x| x[1] + x[2] + x[3]+ x[4] ==;
								aInpRea[nY,_CODE_] + aInpRea[nY,_WAREHOUSE_] + aInpRea[nY,_LOT_]+ aInpRea[nY,_SUBLOT_] } ) ) == 0

							aAdd( aInsRastro, { aInpRea[nY,_CODE_], aInpRea[nY,_WAREHOUSE_], aInpRea[nY,_LOT_],;
								aInpRea[nY,_SUBLOT_], 0 } )
							nPosArr := Len( aInsRastro )

						EndIf

						aInsRastro[nPosArr,5] += aInpRea[nY,_AMOUNT_]

						/*
							aInsLocal: insumos REALIZADOS do mobile com soma dos repetidos para Localização.
							{ TL_CODIGO, TL_LOCAL, TL_LOTECTL, TL_NUMLOTE, TL_LOCALIZ, TL_NUMSERI, Total }
						*/
						If ( nPosArr := aScan( aInsLocal, { |x| x[1] + x[2] + x[3]+ x[4] + x[5]+ x[6] ==;
							aInpRea[nY,_CODE_] + aInpRea[nY,_WAREHOUSE_] + aInpRea[nY,_LOT_] + aInpRea[nY,_SUBLOT_] +;
							aInpRea[nY,_LOCATION_] + aInpRea[nY,_SERIALNUMBER_] } ) ) == 0

							aAdd( aInsLocal, { aInpRea[nY,_CODE_], aInpRea[nY,_WAREHOUSE_], aInpRea[nY,_LOT_],;
								aInpRea[nY,_SUBLOT_], aInpRea[nY,_LOCATION_], aInpRea[nY,_SERIALNUMBER_], 0 } )
							nPosArr := Len( aInsLocal )

						EndIf

						aInsLocal[nPosArr,7] += aInpRea[nY,_AMOUNT_]

					EndIf

				Next nY

				//Valida insumos produto realizados - Rastro e Localização
				cError := NG400VLD( aInsRastro, aInsLocal, aBaseRas, aBaseLocal, cOrdem )
				If !Empty(cError)
					Return cError
				EndIf
			EndIf

			/*
				verifica conflito de horários nos insumos realizados passados pelo APP ( com os insumos da ordem(app) e
				depois com os insumos da base )
			*/
			For nI := 1 To Len( aInpRea )

				If aInpRea[nI,_TYPE_] == 'M'

					cInicio := dToC( aInpRea[nI,_STARTDATE_] ) + aInpRea[nI,_STARTHOUR_]
					cFim    := dToC( aInpRea[nI,_ENDDATE_] )   + aInpRea[nI,_ENDHOUR_]
					nRegLog := 0

					If nOpcX == 1 // update de insumo

						dbSelectArea( 'STL' )
						dbSetOrder( 1 ) // TL_FILIAL + TL_ORDEM + TL_PLANO + TL_TAREFA + TL_TIPOREG + TL_CODIGO + TL_SEQRELA
						If dbSeek( FwxFilial( 'STL' ) + cOrdem + cPlano + aInpRea[nI,_KEYTASK_] + aInpRea[nI,_TYPE_] + aInpRea[nI,_KEYCODE_] + aInpRea[nI,_SEQUENCE_] )

							nRegLog := STL->( Recno() )

						EndIf

					EndIf

					// aScanX: busca conflitos dentro da própria ordem sem validar com o insumo que está sendo passado ( y <> nI )
					If ( aScanX( aInpRea , { |x,y| 	x[_TYPE_] == 'M'                .And.; // MDO
													x[_CODE_] == aInpRea[nI,_CODE_] .And.; // Código
							( ( cInicio > dToC( x[_STARTDATE_] ) + x[_STARTHOUR_]   .And.;
								cInicio < dToC( x[_ENDDATE_] )   + x[_ENDHOUR_] )    .Or.; // cInicio: 07:30 - X 07:00 - 08:00
							  ( cFim > dToC( x[_STARTDATE_] )    + x[_STARTHOUR_]   .And.;
								cFim < dToC( x[_ENDDATE_] )      + x[_ENDHOUR_] )    .Or.; // cFim: 09:30 - X 09:00 - 10:00
							  ( dToC( x[_STARTDATE_] ) + x[_STARTHOUR_] > cInicio   .And.;
								dToC( x[_STARTDATE_] ) + x[_STARTHOUR_] < cFim  )    .Or.; // X INICIO: 08:00 - cInicio:07:30 cFim: 08:30
							  ( dToC( x[_ENDDATE_] )   + x[_ENDHOUR_]   > cInicio   .And.;
								dToC( x[_ENDDATE_] )   + x[_ENDHOUR_]   < cFim )     .Or.; // X FIM: 09:00 - cInicio:08:30 cFim:09:30
							  ( cInicio == dToC( x[_STARTDATE_] ) + x[_STARTHOUR_] ) .Or.; // Hora inicio iguais
							  ( cFim == dToC( x[_ENDDATE_] ) + x[_ENDHOUR_] ) )     .And.; // Hora fim iguais
								y + nI } ) > 0 );  // Não validar com ele mesmo
						.Or. ( !NGVALDATIN( aInpRea[nI,_CODE_],;
							cOrdem,;
							cPlano,;
							aInpRea[nI,_STARTDATE_],;
							aInpRea[nI,_STARTHOUR_],;
							aInpRea[nI,_ENDDATE_],;
							aInpRea[nI,_ENDHOUR_],;
							aInpRea[nI,_TYPE_],;
							IIf( nRegLog > 0, nRegLog,Nil ),;
							'STL' )[1] )

						// "Conflito de horários no insumo de mão de obra do funcionário#"entre o período:" #"até"
						Return 	STR0031 + ' ' + Trim( NGSEEK( 'ST1', aInpRea[nI,_CODE_], 1, 'T1_NOME' ) )        + ' ' +;
								STR0032 + ' ' + dToC( aInpRea[nI,_STARTDATE_] )  + ' ' + aInpRea[nI,_STARTHOUR_] + ' ' +;
								STR0033 + ' ' + dToC( aInpRea[nI,_ENDDATE_] )    + ' ' + aInpRea[nI,_ENDHOUR_]   + '.'

					EndIf

				EndIf

			Next nI

		Next nOpcX

	EndIf

Return cReturn

//---------------------------------------------------------------------
/*/{Protheus.doc} NG400VLD - Validações do MNTA400
Validação de insumos realizados
	aInsRastro[1]-TL_CODIGO
	aInsRastro[2]-TL_LOCAL
	aInsRastro[3]-TL_LOTECTL
	aInsRastro[4]-TL_NUMLOTE
	aInsRastro[5]-TL_QUANTID

	aInsLocal[1]-TL_CODIGO
	aInsLocal[2]-TL_LOCAL
	aInsLocal[3]-TL_LOTECTL
	aInsLocal[4]-TL_NUMLOTE
	aInsLocal[5]-TL_LOCALIZ
	aInsLocal[6]-TL_NUMSERI
	aInsLocal[7]-TL_QUANTID

@author	Maria Elisandra de Paula
@since 21/03/2017
@version P12
@return	string, vazia ou descrição do erro
/*/
//---------------------------------------------------------------------
Static Function NG400VLD( aInsRastro, aInsLocal, aBaseRas, aBaseLocal, cOrdem )

	Local nQtdDe    := 0
	Local cReturn   := ""
	Local nY        := 0
	Local nSaldoLote:= 0
	Local lEstNega  := AllTrim(GetMv("MV_ESTNEG")) == "S"
	Local nSaldoSBF := 0

	If Len(aInsRastro) > 0
		For nY:= 1 to Len(aInsRastro)

			dbSelectArea("SB8")
			//Valida Rastro ---------------------------------------------------------------------
			If fRastro(aInsRastro[nY][1])
				//Busca no vetor aBaseRas (insumo-produto-realizado-base-rastro) e soma quantidade
				//nQtdDe: quantidade de produtos iguais já gravados na base
				If (nBusca := aScan(aBaseRas,{|x| x[1] + x[2]+ x[3]+ x[4] == aInsRastro[nY][1] + aInsRastro[nY][2] + aInsRastro[nY][3] + aInsRastro[nY][4] })) == 0
					nQtdDe := 0
				Else
					nQtdDe :=  aBaseRas[nBusca][5]
				EndIf

				dbSelectArea("SB8")
				If fRastro(aInsRastro[nY][1],"S")
					//Valida o sub-lote
					If Empty(aInsRastro[nY][4])
						Return STR0047  + CRLF + STR0048 + Alltrim(aInsRastro[nY][1]) + CRLF + STR0049 + Alltrim(aInsRastro[nY][2])// "Numero do sub-lote não informado."#"Produto: "#"local "
					Else
						dbSelectArea("SB8")
						dbSetOrder(02)
						If dbSeek(FwxFilial("SB8")+aInsRastro[nY][4]+aInsRastro[nY][3]+aInsRastro[nY][1]+aInsRastro[nY][2])

							nSaldoLote := SB8Saldo(.F.,!Empty(aInsRastro[nY][3]+aInsRastro[nY][4]),NIL,NIL,NIL,NIL,NIL,""/*M->TL_DTINICI*/)

		  					If QtdComp(nSaldoLote)+ nQtdDe < QtdComp(aInsRastro[nY][5])
		     					Return STR0050 + CRLF + STR0051 + Alltrim(aInsRastro[nY][1]) + CRLF + STR0049 + Alltrim(aInsRastro[nY][2]) + CRLF + STR0052 + Alltrim(aInsRastro[nY][3]) + CRLF + STR0053 + Alltrim(aInsRastro[nY][4])
		     					//"Saldo indisponível: "#"produto: "#"local " #"lote " #"sub-lote "
							EndIf
						Else
			            	Return STR0054 + CRLF + STR0048 + Alltrim(aInsRastro[nY][1]) + CRLF + STR0049 + Alltrim(aInsRastro[nY][2])
			            			//"Numero do sub-lote não corresponde ao produto que foi informado."#"Produto: " #"local "
						EndIf
					EndIf
				ElseIf fRastro( aInsRastro[nY][1] , "L" )
					//Valida somente lote
					If Empty(aInsRastro[nY][3])
						Return STR0055  + CRLF + STR0048 + Alltrim(aInsRastro[nY][1]) + CRLF + STR0049 + Alltrim(aInsRastro[nY][2])
								// "Numero do lote não informado."#"Produto: "#"local "
					Else
						dbSelectArea("SB8")
						dbSetOrder(03)
						If dbSeek(FwxFilial("SB8")+aInsRastro[nY][1]+aInsRastro[nY][2]+aInsRastro[nY][3])
							nSaldo:= SaldoLote(aInsRastro[nY][1],aInsRastro[nY][2],aInsRastro[nY][3],NIL,.F.,!Empty(aInsRastro[nY][3]+aInsRastro[nY][4]),NIL,dDatabase)
							If QtdComp(nSaldo)+ nQtdDe < QtdComp(aInsRastro[nY][5])
								Return STR0050  + CRLF + STR0048  + Alltrim(aInsRastro[nY][1]) + CRLF + STR0049 + Alltrim(aInsRastro[nY][2])+ CRLF + STR0052 + Alltrim(aInsRastro[nY][3])
										//"Saldo indisponível."#"produto: "#"local " #"lote "
			        		EndIf
						Else
							Return STR0056 + CRLF + STR0048 + Alltrim( aInsRastro[nY][1]) + CRLF + STR0049 + Alltrim(aInsRastro[nY][2])
									//"Numero do lote não corresponde ao produto informado."#"Produto: " #"local "
						EndIf
					EndIf
				EndIf
			EndIf
		Next nY
	EndIf

	If Len(aInsLocal) > 0
		For nY:= 1 to Len(aInsLocal)
			//nQtdDe: quantidade de produtos iguais já gravados na base
			If (nBusca := aScan(aBaseLocal,{|x| x[1] + x[2]+ x[3]+ x[4] + x[5] + x[6]== ;
					aInsLocal[nY][1] + aInsLocal[nY][2] + aInsLocal[nY][3] + aInsLocal[nY][4] + aInsLocal[nY][5]+ aInsLocal[nY][6]})) == 0
				nQtdDe := 0
			Else
				nQtdDe :=  aBaseLocal[nBusca][7]
			EndIf

			//Validacao do LOCALIZACAO--------------------------------------------
			//Verifica se ha problema na habilitacao do controle por enderecamento fisico
			If !Empty(aInsLocal[nY][5]) .Or. !Empty(aInsLocal[nY][6])
				If !FLocaliza( Padr( aInsLocal[nY][1], TAMSX3("B1_COD")[1] ) )
		        	Return STR0057 + aInsLocal[nY][1] + STR0058 // "O parâmetro 'MV_LOCALIZ' esta desativado ou o campo 'B1_LOCALIZ' do produto: " #" está preenchido com 'N'."
				EndIf
			EndIf

			If FLocaliza( Padr( aInsLocal[nY][1], TAMSX3("B1_COD")[1] ) )
				//Valida a obrigatoriedade de informar o enderecamento fisico se o produto tem o controle
				If Empty(aInsLocal[nY][5]) .And. Empty(aInsLocal[nY][6])
			       Return STR0059  + CRLF + STR0048  + aInsLocal[nY][1] + CRLF + STR0049 + aInsLocal[nY][2]
			       			//"Localização e numero de série não informados."#" Produto: "#"local "
				EndIf

				If !Empty( aInsLocal[nY,5] ) .And. !Empty( aInsLocal[nY,2] ) .And. !NGIFDBSEEK( 'SBE', aInsLocal[nY,2] +;
					aInsLocal[nY,5], 1, .F. )
					Return STR0061 // "Campo localização não existe."
				EndIf

				If !lEstNega .And. ( !Empty(aInsLocal[nY][5]) .Or. !Empty(aInsLocal[nY][6]) )
					nSaldoSBF := QtdComp(SaldoSBF(aInsLocal[nY][2],aInsLocal[nY][5],aInsLocal[nY][1],aInsLocal[nY][6],;
								aInsLocal[nY][3],aInsLocal[nY][4],.F.,,, cOrdem + 'OS001' ))

					If nSaldoSBF + nQtdDe < QtdComp( aInsLocal[nY][7] )
						Return STR0062 + CRLF + STR0048 + aInsLocal[nY][1] + CRLF + STR0049 + aInsLocal[nY][2]//"O endereço informado não possui saldo suficiente."#" Produto: "#"local "
					EndIf

				EndIf

			EndIf
		Next nY
	EndIf
Return cReturn
//---------------------------------------------------------------------
/*/{Protheus.doc} updCounter
Realiza a criação do contador

@author	Maria Elisandra de Paula
@since 14/02/2017
@param cJson - Objeto com o JSON que contém os dados do contador para inclusão
@return array, [1] se obteve sucesso da operação,[2] json
/*/
//---------------------------------------------------------------------
Static Function updCounter(cJson)

	Local oParser
	Local cError     := ""
	Local aCounter   := 0
	Local cEquipment := ""
	Local lRet := .T.
	Local aDtLeitura := {}
	Local nI := 0
	Local cGERAPREV  := AllTrim(GETMv("MV_NGGERPR"))
	Local nCounter   := 0

	If FWJsonDeserialize(cJson,@oParser)

		printf("Inicio Inclusão de contador: " + DTOC(dDataBase) + " " + Time())

		cEquipment:= Upper(Padr(oParser:equipment,16))
		aCounter  := oParser:counter

		//Valida contador
		For nI:= 1 to Len(aCounter)

			If aCounter[nI]:value > 0
				aDtLeitura   := StrTokArr(aCounter[nI]:datetime," ")
				cError := ValidCounter(cEquipment,aCounter[nI]:value,Stod(aDtLeitura[1]),aDtLeitura[2],nI)
				If !Empty(cError)
					Exit
				EndIf
			EndIf
		Next nI

		//Aplica contador
		If Empty(cError)
			For nI:= 1 to Len(aCounter)
				If aCounter[nI]:value > 0
					aDtLeitura := StrTokArr(aCounter[nI]:datetime," ")
					NGTRETCON(cEquipment,Stod(aDtLeitura[1]),aCounter[nI]:value,aDtLeitura[2],nI)

					printf("Contador criado. Leitura: " + aDtLeitura[1] + " " + aDtLeitura[2] )
					nCounter:= aCounter[nI]:value
				EndIf
			Next nI
			//GERAR O.S AUTOMATICA POR CONTADOR
			If ( cGERAPREV == "S" .Or. cGERAPREV == "C" )
				NGGEROSAUT(cEquipment,nCounter,FwxFilial("STJ"))
			EndIf
		Else
			Return {.F.,cError}
		EndIf

	Else
		cError := STR0022 // "Json inválido."
	EndIf

	If Empty(cError)
		cJson := JSONResult(  )
	Else
		cJson := cError
		lRet := .F.
	EndIf

Return { lRet, EncodeUtf8(cJson) }

//---------------------------------------------------------------------
/*/{Protheus.doc} fRastro
Verifica se produto utiliza Rastro - lote e/ou sublote

@author	Maria Elisandra de Paula
@since 02/05/2017
@param cProduto - produto a pesquisar
@param cTipo - "L" - lote ou "S"-Sublote
@return logic, se possui controle de rastro
/*/
//---------------------------------------------------------------------
Static Function fRastro( cProduto, cTipo )

	Local lUsaLote := SuperGetMV("MV_RASTRO",.F.,'N') == "S"
	Local lLote    := .f.
	Default cTipo := ""

	If lUsaLote
		dbSelectArea("SB1")
		dbSetOrder(1)
		If dbSeek(FwxFilial("SB1") +  cProduto )
			lLote := If( Empty(cTipo),(SB1->B1_RASTRO $ "SL" ),(SB1->B1_RASTRO $ cTipo) )
		EndIf
	EndIf

Return lLote
//---------------------------------------------------------------------
/*/{Protheus.doc} fLocaliza
Verifica se produto utiliza LOCALIZAÇÃO - SERIE

@author	Maria Elisandra de Paula
@since 02/05/2017
@param cProduto - produto a pesquisar
@return logic, se possui controle de localização
/*/
//---------------------------------------------------------------------
Static Function fLocaliza( cProduto )

	Local lUsaLocal := SuperGetMV("MV_LOCALIZ") == "S"
	Local lLocaliza := .f.

	If lUsaLocal
		dbSelectArea("SB1")
		dbSetOrder(1)
		If dbSeek(FwxFilial("SB1") +  cProduto )
			lLocaliza := SB1->B1_LOCALIZ == "S"
		EndIf
	EndIf

Return lLocaliza

//---------------------------------------------------------------------
/*/{Protheus.doc} printf
Função para apresentar ou não mensagens no server, utilizado geralmente
para testes de desenvolvimento

@author	Vitor Emanuel Batista
@since 06/07/2017
@return string, log com data e hora
/*/
//---------------------------------------------------------------------
Static Function printf(cLog)
Return conout("["+time()+" - "+cValToChar(ThreadId())+"] " + cLog)

//---------------------------------------------------------------------
/*/{Protheus.doc} CounterFinish
Validações de contador na finalização
@type function

@author	Maria Elisandra de Paula
@since 19/07/2017

@param cDadCode  , string , Código do bem pai para reporte de contador.
@param nCounter1 , numeric, Valor do contador 1
@param cHour1    , string , Hora do contador 1
@param nCounter2 , numeric, Valor do contador 2
@param cHour2    , string , Hora do contador 2
@param dDtMRFim  , date   , Data real fim da os
@param oWS       , object , Instância do ws
@param lShowField, boolean, Define se o campo contador foi apresentado.

@return string, vazio ou descrição de erro
/*/
//---------------------------------------------------------------------
Static Function CounterFinish( cDadCode, nCounter1, cHour1, nCounter2, cHour2, dDtMRFim, oWS, lShowField )

	Local cError     := ''
    Local lHasCount1 := .F.
	Local lHasCount2 := .F.
	Local lVldPos    := .T.
    Local lVldPos2   := .T.
	Local aNGCONTRET := {}

	// Valida se informação que o bem encontra-se ou não na estrutura está atualizada na base do app.
	dbSelectArea( 'ST9' )
	dbSetOrder( 1 )
	If dbSeek( FwxFilial( 'ST9' ) + STJ->TJ_CODBEM ) .And. ST9->T9_TEMCONT $ 'P#I'

		If lShowField .And. ST9->T9_ESTRUTU == 'N'

			/*
				Este equipamento não encontra-se mais em uma estrutura, sendo assim não é permitido o reporte de contador. ###
				Para seguir com a finalização da O.S. deve-se ( cancelar ou reverter ) a finalização em andamento e realizar um sincronismo.
			*/
			cError := STR0164 + STR0166

		ElseIf !lShowField .And. ST9->T9_ESTRUTU == 'S'

			/*
				Este equipamento encontra-se em uma estrutura, sendo assim deve-se realizar o reporte de contador. ###
				Para seguir com a finalização da O.S. deve-se ( cancelar ou reverter ) a finalização em andamento e realizar um sincronismo.
			*/
			cError := STR0165 + STR0166

		EndIf

	EndIf

	// Somente executar este trecho se bem é controlado por algum tipo de contador.
	If Empty( cError ) .And. ( lHasCount1 := NGSEEK( 'ST9', cDadCode, 1, 'T9_TEMCONT' ) $ 'S#P#I' )

		// Verifica se bem possui segundo contador.
		lHasCount2 := MNTCont2( FwxFilial( 'TPE' ), cDadCode, .T. )

		If Val( STJ->TJ_PLANO ) > 0
			dbSelectArea("STF")
			dbSetOrder(1)
			dbSeek( FwxFilial("STF")  + STJ->TJ_CODBEM + STJ->TJ_SERVICO + STJ->TJ_SEQRELA)

			If STF->TF_TIPACOM $ "CAF" .And. ( nCounter1 == 0 .Or. Empty( cHour1 ) )
				Return STR0130 //"Para finalizar uma ordem de serviço preventiva controlada por contador, é obrigatório informá-lo."
			Else
				lVldPos := .F.
			EndIf

			If lHasCount2 .And. STF->TF_TIPACOM == "S" .And. ( nCounter2 == 0 .Or. Empty( cHour2 ) )
				Return STR0131 //"Para finalizar uma ordem de serviço preventiva controlada pelo segundo contador, é obrigatório informá-lo."
			Else
				lVldPos2 := .F.
			EndIf
		EndIf

		aNGCONTRET := NGCONTRET( dDtMRFim, nCounter1, cHour1, lHasCount1 .And. lVldPos,;
								 dDtMRFim , nCounter2, cHour2, lHasCount2 .And. lVldPos2, .F.)

		If !Empty( aNGCONTRET[2] )
			Return aNGCONTRET[2]
		EndIf

	    If Empty( cError )

			If nCounter1 > 0
				cError := ValidCounter( cDadCode, nCounter1, dDtMRFim, cHour1, 1 )
			EndIf

			If Empty( cError ) .And. lHasCount2 .And. nCounter2 > 0
				cError := ValidCounter( cDadCode, nCounter2, dDtMRFim, cHour2, 2 )
			EndIf

		EndIf

		If Empty( cError ) .And. lPeMntNg
			cError:= ExecBlock("MNTNG",.F.,.F.,{ "COUNTER_VALID_FINISH" , oWS })
		EndIf

	EndIf

Return cError
//---------------------------------------------------------------------
/*/{Protheus.doc} UpdDatesStj
Atualiza as datas previstas da ordem de serviço

@param cOrdem, string, OS a ser alterada
@param cPlano, string, plano da ordem
@param dDTMPINI, data, data prevista inicio inserida pelo usuário
@param cHOMPINI, string, hora prevista inicio inserida pelo usuário
@param dDTMPFIM, data, data prevista fim inserida pelo usuário
@param cHOMPFIM, string, hora prevista fim inserida pelo usuário
@author	Maria Elisandra de Paula
@since 07/08/2017
@return nil
/*/
//---------------------------------------------------------------------
Static Function UpdDatesStj( cOrdem, cPlano, dDTMPINI, cHOMPINI, dDTMPFIM, cHOMPFIM )

	Local dMIN
	Local cMin
	Local dMAX
	Local cMax

	//variáveis private utilizadas na função NGDTHORFINAL
	vVETRE := {}
	lPRIMD := .T.

	dbSelectArea("STL")
	dbSetOrder(1)
	If dbSeek( FwxFilial("STL") + cOrdem + cPlano )
		While !Eof() .And. STL->TL_FILIAL == FwxFilial("STL");
					 .And. STL->TL_ORDEM == cOrdem;
					 .And. STL->TL_PLANO == cPlano

			If Alltrim(STL->TL_SEQRELA) == "0"
				NGDTHORFINAL( STL->TL_DTINICI, STL->TL_HOINICI, STL->TL_DTFIM,;
								STL->TL_HOFIM, STL->TL_TIPOREG, STL->TL_SEQRELA, "P" )
			   dMIN := vVETRE[1]
			   cMin := vVETRE[2]
			   dMAX := vVETRE[3]
			   cMax := vVETRE[4]
			EndIf
			dbSelectArea("STL")
			dbSkip()
		EndDo
	EndIf

	dbSelectArea("STJ")
	dbSetOrder(1)
	If dbSeek(FwxFilial("STJ") + cOrdem + cPlano)
		RecLock( "STJ", .F. )
		STJ->TJ_DTMPINI := If( Empty( dMIN ), dDTMPINI, dMIN )
		STJ->TJ_HOMPINI := If( Empty( cMin ), cHOMPINI, cMin )
		STJ->TJ_DTMPFIM := If( Empty( dMAX ), dDTMPFIM, dMAX )
		STJ->TJ_HOMPFIM := If( Empty( cMax ), cHOMPFIM, cMax )
		MsUnLock()
	EndIf

Return
//---------------------------------------------------------------------
/*/{Protheus.doc} fToJson
Retorna estrutura propriedade e valor para json

@param cPropri, string, propriedade do elemento
@param xValue, indefinido, valor do elemento

@author	Maria Elisandra de Paula
@since 07/08/2017
@return string, json
/*/
//---------------------------------------------------------------------
Static Function fToJson(cPropri,xValue)

	Local xConteudo
	Local cRet:= ""
	Local lEscape := .T.

	cRet+= '"' + cPropri + '"' + ':'

	If Valtype(xValue) == "C"
		cRet+= '"'
		xConteudo := xValue
	ElseIf Valtype(xValue) == "N"
		xConteudo := cValtoChar(xValue)
		lEscape := .F.
	ElseIf Valtype(xValue) == "L"
		If xValue
			xConteudo := "true"
		Else
			xConteudo := "false"
		EndIf
		lEscape := .F.
	EndIf

	If lEscape
		cRet+= NGEscape(xConteudo)
	Else
		cRet+= xConteudo
	EndIf

	If Valtype(xValue) == "C"
		cRet += '"'
	EndIf

Return cRet
//---------------------------------------------------------------------
/*/{Protheus.doc} fToString
Retorna string de resposta de acordo com o tipo de opção da etapa

@author	Maria Elisandra de Paula
@since 07/08/2017
@param cEtapa, caracter, código da etapa
@param cOption, caracter, código da opção da etapa
@param xValue, indefined, valor de resposta
@return array, {se conversão ocorreu corretamente, conteúdo}
/*/
//---------------------------------------------------------------------
Static Function fToString(cEtapa, cOption, xValue)

	Local aRet := {.T., ""}
	Local cType:= ""

	dbSelectArea("TPA")
	dbSetOrder(1)
	If !dbseek(FwxFilial("TPA") + cEtapa)
		aRet := {.F., Alltrim(cEtapa) + Space(1) + STR0132 } // "o código da etapa não existe ou pertence à tabela TPA - Etapas Genéricas"
	ElseIf TPA->TPA_OPCOES == "0"
			aRet := {.F., STR0075 + ":" + Space(1) + Alltrim(cEtapa) + Space(1) + ; // "Etapa"
							STR0133 } // "tipo de opções '0',não deve ter respostas."
	ElseIf TPA->TPA_OPCOES $ "1/2"
		If NGIFDBSEEK("TPC", TPA->TPA_ETAPA + cOption, 1)

			If TPC->TPC_TIPRES == "1" //marcar
				If !Empty(xValue) .And. ValType(xValue) <> "L"
					Return {.F., STR0075 + ":" + Space(1) + Alltrim(cEtapa) + Space(1) +; //"Etapa"
								 STR0076 + ":" + Space(1) + Alltrim(cOption) + Space(1) +; //"Opção"
								 STR0134 +; //"Valor informado não corresponde com o tipo utilizado."
								 STR0135 } //"Informe um valor vazio ou do tipo lógico."
				Else
					Return aRet
				EndIf
			ElseIf TPC->TPC_TIPCAM == "D" .And. Valtype( xValue ) == "C" .And. !Empty( CToD ( xValue ) )
				cType:= Valtype( CToD ( xValue ) )
			Else
				cType:= Valtype(xValue)
			EndIf

			If TPC->TPC_TIPCAM <> cType
				aRet := {.F., STR0075 + ":" + Space(1) + Alltrim(cEtapa) + Space(1) +; //"Etapa"
							  STR0076 + ":" + Space(1) + Alltrim(cOption) + Space(1) +; //"Opção"
							  STR0134 +; //"Valor informado não corresponde com o tipo utilizado."
							STR0136 + Space(1) + NGRETSX3BOX("TPC_TIPCAM",TPC->TPC_TIPCAM)} //"Informe um valor do tipo"
			ElseIf Valtype(xValue) == "C" .Or. Valtype(xValue) == "D"
				aRet[2] := xValue
			ElseIf Valtype(xValue) == "N"
				aRet[2] := cValtoChar(xValue)
			ElseIf Valtype(xValue) == "L"
				aRet[2] := If(xValue,".T.",".F.")
			EndIf

		Else
			aRet := {.F., STR0075 + ":" + Space(1) + Alltrim(cEtapa) + Space(1) +; //"Etapa"
						  STR0076 + ":" + Space(1) + Alltrim(cOption) + Space(1) +; //"Opção"
						  STR0137 } //"não existe ou não pertence à tabela TPC - Opções da Etapa Genérica."
		Endif
	EndIf
Return aRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fModifEtapa
Verifica se uma etapa foi modificada

@author	Maria Elisandra de Paula
@since 14/08/2018
@param cOrder, caracter, código da ordem de serviço
@param cPlan, caracter, código do plano
@param cTarefa, caracter, código da tarefa
@param cEtapa, caracter, código da etapa
@param cOk, caracter, marcação campo TQ_OK
@param aAnswers, array, respostas da etapa
@return logic, se houve alteração
/*/
//---------------------------------------------------------------------
Static Function fModifEtapa(cOrder,cPlan,cTarefa,cEtapa,cOk,aAnswers)

	Local lModified := .F.
	Local cAliasQry := GetNextAlias()
	Local cQuery    := ""
	Local nI

	If (Empty(STQ->TQ_OK) .And. !Empty(cOk)) ; //marcou como executada
		.Or. (!Empty(STQ->TQ_OK) .And. Empty(cOk)) //desmarcou
		Return .T.
	EndIf

	cQuery := "SELECT TPQ_OPCAO, TPQ_RESPOS "
	cQuery += " FROM " + RetSqlName("TPQ")
	cQuery += " WHERE TPQ_FILIAL = " + ValtoSql( FwxFilial("TPQ") )
	cQuery += "   AND TPQ_ORDEM  = " + ValtoSql(cOrder)
	cQuery += "   AND TPQ_PLANO  = " + ValtoSql(cPlan)
	cQuery += "   AND TPQ_TAREFA = " + ValtoSql(cTarefa)
	cQuery += "   AND TPQ_ETAPA  = " + ValtoSql(cEtapa)
	cQuery += "		AND D_E_L_E_T_ = ' ' "
	cQuery := ChangeQuery(cQuery)

	MPSysOpenQuery(cQuery, cAliasQry)

	While (cAliasQry)->(!EoF())
		If aScan(aAnswers, {|x| x[1] == (cAliasQry)->TPQ_OPCAO .And. Alltrim(x[2]) == Alltrim((cAliasQry)->TPQ_RESPOS ) }) == 0 //resposta igual
			lModified := .T. //modificou a resposta ou a excluiu
			Exit
		EndIf
		(cAliasQry)->(dbSkip())
	EndDo

	(cAliasQry)->(dbCloseArea())

	If !lModified
		For nI := 1 to Len(aAnswers)
			dbSelectArea("TPQ")
			dbSetOrder(1)
			If !dbSeek(FwxFilial("TPQ") + cOrder + cPlan + cTarefa + cEtapa + aAnswers[nI][1])
				lModified := .T. //incluiu uma resposta na etapa
				Exit
			EndIf
		Next nI
	EndIf
Return lModified
//---------------------------------------------------------------------
/*/{Protheus.doc} fCargaAcols
Verifica se uma etapa foi modificada

@author	Maria Elisandra de Paula
@since 14/05/2018
@param cOrder, caracter, código da ordem de serviço
@param cPlan, caracter, código do plano
@param cTarefa, caracter, código da tarefa
@param cEtapa, caracter, código da etapa
@param aAnswers, array, respostas da etapa
@param aHeaderAux, array, header de respostas
@return array, estrutura do acols para respostas da etapa
/*/
//---------------------------------------------------------------------
Static Function fCargaAcols(cOrder, cPlan, cTarefa, cEtapa, aAnswers, aHeaderAux,nOperat)

	Local nX
	Local aLinha     := BlankGetd(aHeaderAux)[1]
	Local aCols      := {}
	Local nPosFilial := aScan( aHeaderAux , {|x| Alltrim(x[2]) == "TPQ_FILIAL" })
	Local nPosOrdem  := aScan( aHeaderAux , {|x| Alltrim(x[2]) == "TPQ_ORDEM"  })
	Local nPosPlano  := aScan( aHeaderAux , {|x| Alltrim(x[2]) == "TPQ_PLANO"  })
	Local nPosTarefa := aScan( aHeaderAux , {|x| Alltrim(x[2]) == "TPQ_TAREFA" })
	Local nPosEtapa  := aScan( aHeaderAux , {|x| Alltrim(x[2]) == "TPQ_ETAPA"  })
	Local nPosOk     := aScan( aHeaderAux , {|x| Alltrim(x[2]) == "TPQ_OK"     })
	Local nPosOpcao  := aScan( aHeaderAux , {|x| Alltrim(x[2]) == "TPQ_OPCAO"  })
	Local nPosRespos := aScan( aHeaderAux , {|x| Alltrim(x[2]) == "TPQ_RESPOS" })
	Local cMarca  := GetMark()

	//-------------------------------------------------------
	// carrega acols com as respostas que devem ser gravadas
	//-------------------------------------------------------
	For nX := 1 to Len(aAnswers)
		aLinha[nPosFilial] := FwxFilial("TPQ")
		aLinha[nPosOrdem]  := cOrder
		aLinha[nPosPlano]  := cPlan
		aLinha[nPosTarefa] := cTarefa
		aLinha[nPosEtapa]  := cEtapa
		aLinha[nPosOk]     := cMarca
		aLinha[nPosOpcao]  := aAnswers[nX][1]
		aLinha[nPosRespos] := aAnswers[nX][2]

		aAdd(aCols,aClone(aLinha))
	Next nX

	//--------------------------------------------------------
	// carrega acols com as respostas que devem ser excluídas
	//--------------------------------------------------------
	If nOperat > 3
		dbSelectArea("TPQ")
		dbSetOrder(1)
		If dbSeek(FwxFilial("TPQ") + cOrder + cPlan + cTarefa + cEtapa)

			While !Eof() .And. cOrder + cPlan + cTarefa + cEtapa == ;
				TPQ->TPQ_ORDEM + TPQ->TPQ_PLANO + TPQ->TPQ_TAREFA + TPQ->TPQ_ETAPA

				If aScan(aAnswers, {|x| x[1] == TPQ->TPQ_OPCAO }) == 0
					aLinha[nPosFilial] := FwxFilial("TPQ")
					aLinha[nPosOrdem]  := cOrder
					aLinha[nPosPlano]  := cPlan
					aLinha[nPosTarefa] := cTarefa
					aLinha[nPosEtapa]  := cEtapa
					aLinha[nPosOpcao]  := TPQ->TPQ_OPCAO
					aTail(aLinha)      := .T. //deletada

					aAdd(aCols,aClone(aLinha))
				EndIf
				dbSkip()
			EndDo
		EndIf
	EndIf
Return aCols

//---------------------------------------------------------------------
/*/{Protheus.doc} fMessage
Retorna Json de mensagens

@author	Maria Elisandra de Paula
@since 11/06/2018
@param aOSGeradas, array, ordens ou solicitações geradas
	{TPQ->TPQ_TAREFA,TPQ->TPQ_ETAPA,TPQ->TPQ_OPCAO,TPQ->TPQ_ORDEMG}
@param aSSGeradas, array, solicitações geradas
	{TPQ->TPQ_TAREFA,TPQ->TPQ_ETAPA,TPQ->TPQ_OPCAO,TPQ->TPQ_ORDEMG}
@param aNoStQ, array, etapas não criadas/alteradas
	{TPQ->TPQ_TAREFA,TPQ->TPQ_ETAPA,TPQ->TPQ_OPCAO}
@param cOpenSR, caracter, solicitações vinculada na finalização da ordem
@return string, json
/*/
//---------------------------------------------------------------------
Static Function fMessage( aOSGeradas, aSSGeradas,aNoStQ, cOpenSR)

	Local cRet     := ""
	Local lItem    := .F.
	Local lFirst   := .T.
 	Local nX       := 0
 	Local cJsonItem:= ""

	Default cOpenSR:= ""

	//----------------------------------------
	// SS geradas pelas respostas de checklist
	//----------------------------------------
	cJsonItem := fJsonRes( aOSGeradas )
	If !Empty( cJsonItem )
		lItem := .T.
		cRet += '{"id":"serviceOrder",'
		cRet += '"items":[' + cJsonItem + ']}'
	EndIf

	//----------------------------------------
	// OS geradas pelas respostas de checklist
	//----------------------------------------
	cJsonItem := fJsonRes( aSSGeradas )

	If !Empty( cJsonItem )
		cRet += If(lItem,',','')
		lItem := .T.
		cRet += '{"id":"serviceRequest",'
		cRet += '"items":[' + cJsonItem + ']}'
	EndIf

	//----------------------------------------
	// checklist (STQ) não incluídos
	//----------------------------------------
	If Len( aNoSTQ ) > 0

		cRet += If(lItem,',','')
		lItem := .T.
		lFirst:= .T.

		cRet += '{"id":"checklist",'
		cRet += '"items":['

		For nX := 1 to Len( aNoSTQ )

			cRet  += If(lFirst,'',',')
			lFirst := .F.

			cRet += '{"task":"'     + Alltrim(aNoSTQ[nX][1]) + '",'
			cRet += '"checklist":"' + Alltrim(aNoSTQ[nX][2]) + '",'
			cRet += '"answer":"'    + Alltrim(aNoSTQ[nX][3]) + '"}'
		Next nX
		cRet += ']}'
	EndIf

	//------------------------------------------------
	// solicitações que ficam abertas na finalização
	//------------------------------------------------
	If !Empty( cOpenSR )
		cRet += If(lItem,',','')
		lItem := .T.
		cRet += '{"id":"openServiceRequest",'
		cRet += '"items":["' + Alltrim(cOpenSR) + '"]}'
	EndIf

Return cRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fJsonRes
Retorna Json de ordens/solicitações geradas pelas respostas de etapas

@author	Maria Elisandra de Paula
@since 15/05/2018
@param aGeradas, array, ordens ou solicitações geradas
@sample fJsonRes({TPQ->TPQ_TAREFA,TPQ->TPQ_ETAPA,TPQ->TPQ_OPCAO,TPQ->TPQ_ORDEMG})
@return string, json
/*/
//---------------------------------------------------------------------
Static Function fJsonRes(aGeradas)

	Local cRet    := ''
	Local lFirst  := .T.
	Local nI,nX
	Local aOrdens := {}

	For nI := 1 to Len(aGeradas)

		For nX := 1 to Len(aGeradas[nI])
			aOrdens:= aGeradas[nI]
			cRet  += ','
			If lFirst
				lFirst := .F.
				cRet := ''
			EndIf

			cRet += '{"task":"'     + Alltrim(aOrdens[nX][1]) + '",'
			cRet += '"checklist":"' + Alltrim(aOrdens[nX][2]) + '",'
			cRet += '"answer":"'    + Alltrim(aOrdens[nX][3]) + '"'
			cRet += ',"code":"'     + Alltrim(aOrdens[nX][4])
			cRet += '"}'
		Next nX
	Next nI
Return cRet

//---------------------------------------------------------------------
/*/{Protheus.doc} Localization
Busca localização do bem na TAF

@param cCode, Caracter, Código do Bem
@param cType, Caracter, Tipo do código (1=Bem; 2=Localização)

@author	Maria Elisandra de Paula
@since 23/01/2019

@return string, hierarquia completa do equipamento/localização
/*/
//---------------------------------------------------------------------
Static Function Localization( cCode, cType )

	Local cAliasQry := GetNextAlias()
	Local lAdd      := .F.
	Local cLocTree  := ""
	Local cQuery
	Local lAsset

	Default cType := '1'

	lAsset := cType == '1'

	cQuery := " WITH RECUR_TAF"
	cQuery += "    AS ("
	cQuery += "        SELECT TAF.TAF_CODNIV,"
	cQuery += "               TAF.TAF_NIVSUP,"
	cQuery += "               TAF.TAF_INDCON,"
	cQuery += "               TAF.TAF_CODCON,"
	cQuery += "               0 AS LEVEL,"

	//------------------------------------------------
	// Define origem do nome do registro base (bem/localização)
	//------------------------------------------------
	If lAsset
		// Para bem, captura o nome do equipamento (T9_NOME)
		cQuery += " Rtrim(Cast(ST9.T9_NOME AS VARCHAR("+ cValToChar( TamSx3("TAF_NOMNIV")[1] ) + "))) AS TAF_NOMNIV"
	Else
		// Para localização, utiliza o próprio nome da localização
		cQuery += " TAF.TAF_NOMNIV"
	EndIf

	cQuery += " FROM " + RetSqlName("TAF") + " TAF"

	//------------------------------------------------
	// Para bem, confirma existencia do equipamento na ST9
	//------------------------------------------------
	If lAsset
		cQuery += " INNER JOIN " + RetSqlName("ST9") + " ST9"
		cQuery += " ON ST9.T9_FILIAL = " + ValtoSql( FwxFilial("ST9") )
		cQuery += " 	AND ST9.T9_CODBEM = " + ValtoSql( cCode )
		cQuery += "     AND ST9.D_E_L_E_T_ = ' ' "
	EndIf

	//------------------------------------------------
	// Filtros para busca do bem/localização base na TAF
	//------------------------------------------------
	cQuery += " WHERE  TAF.TAF_FILIAL = " + ValtoSql( FwxFilial("TAF") )
	cQuery += " 	AND TAF.TAF_MODMNT = 'X'"
	cQuery += "     AND TAF.TAF_INDCON = " + ValToSql( cType )
	cQuery += "     AND TAF.D_E_L_E_T_ = ' '"

	//------------------------------------------------
	// Filtra o código do bem/localização base
	//------------------------------------------------
	If lAsset
		// Para bem, busca pelo código do bem (TAF_CODCON)
		cQuery += " AND TAF.TAF_CODCON = " + ValToSql( cCode )
	Else
		// Para localização, busca pelo código da localização (TAF_CODNIV)
		cQuery += " AND TAF.TAF_CODNIV = " + ValToSql( cCode )
	EndIf

	cQuery += " UNION ALL"

	//------------------------------------------------
	// Caso recursivo
	//------------------------------------------------
	cQuery += "         SELECT A.TAF_CODNIV, "
	cQuery += "                A.TAF_NIVSUP, "
	cQuery += "                A.TAF_INDCON, "
	cQuery += "                A.TAF_CODCON, "
	cQuery += "                ( R.LEVEL + 1 ) AS LEVEL, " // Nivel para ordenar
	cQuery += "                Rtrim(A.TAF_NOMNIV) "
	cQuery += "         FROM " + RetSqlName("TAF") + " A "
	cQuery += "                INNER JOIN RECUR_TAF R "
	cQuery += "                        ON R.TAF_NIVSUP = A.TAF_CODNIV "
	cQuery += "         WHERE  A.TAF_FILIAL = " + ValtoSql( FwxFilial("TAF") )
	cQuery += "                AND A.TAF_MODMNT = 'X' "
	cQuery += "                AND A.TAF_INDCON = '2' "
	cQuery += "                AND A.D_E_L_E_T_ = ' ')"

	cQuery += " SELECT NOMNIV = R.TAF_NOMNIV FROM RECUR_TAF R"
	cQuery += " ORDER BY R.LEVEL DESC"

	MPSysOpenQuery( cQuery, cAliasQry )
	dbSelectArea( cAliasQry )

	Do While !( cAliasQry )->( Eof() )

		If lAdd
			cLocTree += " > "
		Else
			lAdd := .T.
		EndIf

		cLocTree += Alltrim( ( cAliasQry )->NOMNIV )
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

Return cLocTree

//---------------------------------------------------------------------
/*/{Protheus.doc} ExtractBitmap
Extrai uma imagem do RPO para um arquivo determinado

@author Marcelo Camargo
@since 26/01/2018
@param cObject, string, nome do objeto
@param cPath, string, caminho de saída
@return booleanm, se extraiu imagem do RPO
/*/
//---------------------------------------------------------------------
Static Function ExtractBitmap( cObject, cPath )

	Local oReposit

	oReposit := FWBmpRep():New()
	If !oReposit:ExistBmp( cObject )
		oReposit:CloseRepository()
		Return .F.
	EndIf
	oReposit:Extract( cObject, cPath )
	oReposit:CloseRepository()

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} InsertBitmap
Insere um item no repositório de imagens

@author  Marcelo Camargo
@since   26/01/2016
@version P12
@param   cPath, string, localização atual do arquivo
@param   cObject, string, nome do objeto
@param   cEnterprise, string, empresa para posicionar
@param   cBranch, string, filial para posicionar
@return  Character, se inseriu o item no RPO de imagens
/*/
//---------------------------------------------------------------------
Function InsertBitmap( cPath, cObject, cEnterprise, cBranch )

	Local oReposit

	RpcSetType( 3 )
	RpcSetEnv( cEnterprise, cBranch, Nil, Nil, 'MNT' )
	oReposit := FWBmpRep():New()
	cObject := oReposit:InsertBmp( cPath, cObject, .T. )
	oReposit:CloseRepository()
	RpcClearEnv()
Return cObject

//---------------------------------------------------------------------
/*/{Protheus.doc} QServiceType
Query para tipos de serviços

@author	Maria Elisandra de paula
@since 28/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de tipos de serviços da ss
/*/
//---------------------------------------------------------------------
Static Function QServiceType( oWs, cDate, cOrigin )

	Local lBlock := NGCADICBASE("TQ3_MSBLQL","A","TQ3",.F.)
	Local cQuery := " SELECT TQ3_CDSERV "

	If cOrigin == "sServiceType"

		cQuery += " , TQ3_NMSERV, TQ3_CDRESP, "
		cQuery += fCaseDel('TQ3')

		If lBlock
			cQuery += " CASE WHEN TQ3.TQ3_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
		Else
			cQuery += "'' AS BLOCKED "
		EndIf
	EndIf

	cQuery += " FROM " + RetSqlName('TQ3') + " TQ3"
	cQuery += "	WHERE TQ3_FILIAL = " + ValtoSql(FwxFilial("TQ3"))

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "TQ3_USERGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "TQ3_USERGI" ) + " >=  " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND TQ3.D_E_L_E_T_ = ' '"
	EndIf

	cQuery := ChangeQuery(cQuery)

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sServiceType
Gera um arquivo json contendo as informações de tipos de serviços
para a sincronização com o aplicativo mobile

@author	Maria Elisandra de paula
@since 01/08/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sServiceType( oWs, cDate )

	Local cDelete   := ''
	Local lFirst	:= .T.
	Local lFirstD	:= .T.
	Local nCount	:= 0
	Local cHrIn		:= Time()
	Local cSubJSON  := ""
	Local cQuery    := QServiceType( oWs, cDate, "sServiceType" )
	Local cAliasQry	:= GeraTemp( cQuery, 'ServiceType' )
	Local nDelete   := 0
	Local nUpdate   := 0
	Local aFileName := {}
	Local cEntity   := 'servicetype'
	Local aInit     := fInitWrite(oWs, cEntity)
	
	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf


	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If fCondDel(cAliasQry)
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{"serviceType":"' + NGEscape( (cAliasQry)->TQ3_CDSERV ) + '",'
			cSubJSON += '"name":"' + NGEscape( (cAliasQry)->TQ3_NMSERV ) + '",'

			If (cAliasQry)->BLOCKED == "TRUE"
				cSubJSON += '"blocked":true,'
			EndIf

			cSubJSON += '"responsible":"' + NGEscape( (cAliasQry)->TQ3_CDRESP ) + '"}'

			fWriteJson(cSubJSON, nUpdate, oWs)

		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + NGEscape( (cAliasQry)->TQ3_CDSERV ) + '"'
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} sExecutor
Gera um arquivo json contendo as informações de executantes de SS
para a sincronização com o aplicativo mobile

@author	Maria Elisandra de paula
@since 01/08/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sExecutor( oWs, cDate )

	Local cDelete   := ''
	Local lFirst	:= .T.
	Local lFirstD	:= .T.
	Local nCount	:= 0
	Local cHrIn		:= Time()
	Local cSubJSON  := ""
	Local cQuery    := QExecutor( oWs, cDate, "sExecutor" )
	Local cAliasQry	:= GeraTemp( cQuery, 'Executor')
	Local nDelete   := 0
	Local nUpdate   := 0
	Local aFileName := {}
	Local cEntity   := 'executor'
	Local aInit     := fInitWrite(oWs, cEntity)
	
	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf


	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If fCondDel(cAliasQry)
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{"executor":"' + NGEscape( (cAliasQry)->TQ4_CDEXEC ) + '",'
			cSubJSON += '"name":"' + NGEscape( (cAliasQry)->TQ4_NMEXEC ) + '",'

			If (cAliasQry)->BLOCKED == "TRUE"
				cSubJSON += '"blocked":true,'
			EndIf

			cSubJSON += '"email":"' + NGEscape( (cAliasQry)->TQ4_EMAIL1 ) + '"}'

			fWriteJson(cSubJSON, nUpdate, oWs)

		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + NGEscape( (cAliasQry)->TQ4_CDEXEC ) + '"'

		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QExecutor
Query para executante de solciitações

@author	Maria Elisandra de paula
@since 01/08/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de executantes de ss
/*/
//---------------------------------------------------------------------
Static Function QExecutor( oWs, cDate, cOrigin )

	Local lBlock := NGCADICBASE("TQ4_MSBLQL","A","TQ4",.F.)
	Local cQuery := "	SELECT TQ4_CDEXEC "
	Local cUserEmail := Trim( UsrRetMail( cUserLog ))
	Local cFilter := ''

	If cOrigin == "sExecutor"

		cQuery += " , TQ4_NMEXEC, TQ4_EMAIL1, "
		cQuery += fCaseDel('TQ4')

		If lBlock
			cQuery += " CASE WHEN TQ4.TQ4_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
		Else
			cQuery += "'' AS BLOCKED "
		EndIf

	EndIf

	cQuery += " FROM " + RetSqlName('TQ4') + " TQ4"
	cQuery += "	WHERE TQ4_FILIAL = " + ValtoSql(FwxFilial("TQ4"))

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "TQ4_USERGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "TQ4_USERGI" ) + " >=  " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND TQ4.D_E_L_E_T_ = ' '"
	EndIf

	// Ponto de entrada para filtrar usuário logado no App
	If lPeMntNg
		cFilter := ExecBlock("MNTNG",.F.,.F.,{"FILTER_EXECUTOR",oWS, cUserEmail })
		If !Empty( cFilter )
			cQuery += cFilter
		EndIf
	EndIf

	cQuery := ChangeQuery(cQuery)

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sWorkCenter
Gera um arquivo json contendo as informações de centro de trabalho
para a sincronização com o aplicativo mobile

@author	Maria Elisandra de paula
@since 01/08/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sWorkCenter( oWs, cDate )

	Local cDelete   := ''
	Local lFirst	:= .T.
	Local lFirstD	:= .T.
	Local nCount	:= 0
	Local cHrIn		:= Time()
	Local cSubJSON  := ""
	Local cQuery    := QWorkCenter( oWs, cDate, "sWorkCenter" )
	Local cAliasQry := GeraTemp( cQuery, 'WorkCenter' )
	Local nDelete   := 0
	Local nUpdate   := 0
	Local aFileName := {}
	Local cEntity   := 'workcenter'
	Local aInit     := fInitWrite(oWs, cEntity)
	
	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If fCondDel(cAliasQry)
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{"workCenter":"' + NGEscape( (cAliasQry)->HB_COD ) + '",'
			cSubJSON += '"name":"' + NGEscape( (cAliasQry)->HB_NOME ) + '",'

			If (cAliasQry)->BLOCKED == "TRUE"
				cSubJSON += '"blocked":true,'
			EndIf

			cSubJSON += '"costCenter":"' + NGEscape( (cAliasQry)->HB_CC ) + '"}'

			fWriteJson(cSubJSON, nUpdate, oWs)

		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + NGEscape( (cAliasQry)->HB_COD ) + '"'

		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QWorkCenter
Query para centro de trabalho

@author	Maria Elisandra de paula
@since 01/08/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de centro de trabalho
/*/
//---------------------------------------------------------------------
Static Function QWorkCenter( oWs, cDate, cOrigin )

	Local lBlock := NGCADICBASE("HB_MSBLQL","A","SHB",.F.)
	Local cQuery := " SELECT HB_COD "

	If cOrigin == "sWorkCenter"

		cQuery += " , HB_NOME, HB_CC, "
		cQuery += fCaseDel('SHB')

		If lBlock
			cQuery += " CASE WHEN SHB.HB_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
		Else
			cQuery += "'' AS BLOCKED "
		EndIf

	EndIf

	cQuery += " FROM " + RetSqlName('SHB') + " SHB"
	cQuery += "	WHERE HB_FILIAL = " + ValtoSql(FwxFilial("SHB"))

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "HB_USERLGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "HB_USERLGI" ) + " >=  " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND SHB.D_E_L_E_T_ = ' '"
	EndIf

	cQuery := ChangeQuery(cQuery)

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} QRequestOrders
Query para ordens das solicitações

@author	Maria Elisandra de paula
@since 01/08/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de ordens da ss
/*/
//---------------------------------------------------------------------
Static Function QRequestOrders( oWs, cDate, cOrigin, lOnlyExec )

	Local cQuery	:= ""
	Local lMultiple := SuperGetMv( 'MV_NGMULOS', .F., 'S' ) == 'S'
	Local lLocOS := fHasPerms('location-order')

	Default lOnlyExec := .F.

	If cOrigin <> "sRequestOrders"
		cQuery := " SELECT STJ.TJ_ORDEM "
	Else

		cQuery := " SELECT TQB.TQB_SOLICI SOLICI, STJ.TJ_TIPOOS, "
		cQuery += " STJ.TJ_ORDEM, STJ.TJ_PLANO, STJ.TJ_SERVICO, STJ.TJ_SEQRELA, ST4.T4_NOME, STJ.TJ_SITUACA, STJ.R_E_C_N_O_, "
		cQuery += " STJ.TJ_CODBEM, STJ.TJ_HOMPINI, STJ.TJ_DTMPINI, STJ.TJ_DTMPFIM, STJ.TJ_DTORIGI, "
		cQuery += "	STJ.TJ_HOMPFIM, STJ.TJ_CCUSTO, CTT.CTT_DESC01, STJ.TJ_TERMINO, "
		cQuery += "	CASE WHEN STE.TE_CARACTE = 'P' THEN 'P' Else 'C' END AS TYPE, "
		If lLocOS
			cQuery += "	CASE WHEN STJ.TJ_TIPOOS = 'L' THEN TAF.TAF_NOMNIV Else ST9.T9_NOME END AS NOME, "
		Else
			cQuery += " ST9.T9_NOME AS NOME,
		EndIf

		//---------------------------------------------------------------------------------------------
		//O trecho abaixo deve ser o mesmo da query Qrequest
		//pois na entidade citada o controle de deletados também é realizado pela TQB como é feito aqui
		//----------------------------------------------------------------------------------------------
		cQuery += " CASE WHEN TQB.D_E_L_E_T_ = '*' THEN 'true' "
		cQuery += "	WHEN TQB.TQB_SOLUCA = 'C' THEN 'true' "
		 //Encerrada sem necessidade de feedback
		cQuery += " WHEN TQB.TQB_SOLUCA = 'E' AND TQ3.TQ3_PESQST = '2' THEN 'true' "
		 //Encerrada e já respondida
		cQuery += "	WHEN TQB.TQB_SOLUCA = 'E' AND TQ3.TQ3_PESQST = '1' AND TQB.TQB_PSAP <> ' ' THEN 'true' "
		//Encerrada não-respondida mas é de outro usuário
		cQuery += "	WHEN TQB.TQB_SOLUCA = 'E' AND TQ3.TQ3_PESQST = '1' AND TQB.TQB_PSAP = ' ' "
		cQuery += "		AND TQB.TQB_CDSOLI <> " + ValToSql( cUserLog ) + " THEN 'true' "
		cQuery += "	ELSE ' ' END AS IS_DELETED "

	EndIf

	cQuery += " FROM " + RetSqlName("STJ") + " STJ"

	If lMultiple
		cQuery += " JOIN " + RetSqlName("TT7") + " TT7 "
		cQuery += " 	ON TT7.TT7_FILIAL = " + ValtoSql(FwxFilial("TT7"))
		cQuery += "		AND TT7.TT7_ORDEM = STJ.TJ_ORDEM "
		cQuery += "		AND TT7.D_E_L_E_T_ = ' ' "
	EndIf

	cQuery += " JOIN " + RetSqlName("TQB") + " TQB ON "
	cQuery += "    TQB.TQB_FILIAL = " + ValtoSql(FwxFilial("TQB"))

	If lMultiple
		cQuery += " AND TT7.TT7_SOLICI = TQB.TQB_SOLICI "
	Else
		//Quando não é de multiplas ordens, o vínculo é pelo campo TQB_ORDEM
		cQuery += " AND TQB.TQB_ORDEM = STJ.TJ_ORDEM "
	EndIf

	//------------------------------------------------------------------------
	//Deve ser passado o parâmetro de data para que sejam carregadas
	//todas as ordens de serviço das solicitações modificadas.
	//-------------------------------------------------------------------------
	cQuery += " AND TQB.TQB_SOLICI IN (" + QRequest( oWs, cDate, "sRequestOrders", lOnlyExec ) + ") "

	cQuery += " LEFT JOIN " + RetSqlName("TQ3") + " TQ3 " 
	cQuery += "		ON TQ3.TQ3_FILIAL = " + ValtoSql(FwxFilial("TQ3"))
	cQuery += " 	AND TQ3.TQ3_CDSERV = TQB.TQB_CDSERV"
	cQuery += " 	AND TQ3.D_E_L_E_T_ = ' '"

	//--------------------------------------------------------------
	// Condições de junção tabelas relacionadas a ordens de serviço
	//--------------------------------------------------------------
	cQuery += fJoinSTJ( oWs )

	cQuery += "    AND STJ.TJ_SITUACA IN( 'L', 'P' ) "

	// tratamento para evitar inconsistências e considerar filtros entre STJ e ST9/TAF/ST6
	If lLocOS
		cQuery += " AND (( STJ.TJ_TIPOOS = 'B' AND ST9.T9_CODBEM IS NOT NULL AND ST6.T6_CODFAMI IS NOT NULL AND CTT.CTT_CUSTO IS NOT NULL)  " 
		cQuery += " 	OR ( STJ.TJ_TIPOOS = 'L' AND TAF.TAF_CODNIV IS NOT NULL AND ( CTT.CTT_CUSTO IS NOT NULL OR TAF.TAF_CCUSTO = ' ' ) ) )"
	Else
		cQuery += " AND ( ST9.T9_CODBEM IS NOT NULL AND ST6.T6_CODFAMI IS NOT NULL AND CTT.CTT_CUSTO IS NOT NULL) "
	EndIf

	cQuery += "    AND STJ.D_E_L_E_T_ = ' ' "

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sRequestOrders
Gera um arquivo json contendo as informações das ordens de serviço de solicitações

@author	Maria Elisandra de paula
@since 01/08/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sRequestOrders( oWs, cDate )

	Local cDelete   := ''
	Local lFirst	 := .T.
	Local lFirstD	 := .T.
	Local nCount	 := 0
	Local cHrIn		 := Time()
	Local cSubJSON   := ""
	Local cDtInicial := ""
	Local cDtFinal   := ""
	Local lSYP       := NGCADICBASE("TJ_MMSYP","A","STJ",.F.)
	Local cDescri    := ""
	Local cQuery	 := ChangeQuery( QRequestOrders( oWs, cDate, "sRequestOrders" ) )
	Local cAliasQry := GeraTemp( cQuery, 'RequestOrders' )
	Local nDelete   := 0
	Local nUpdate   := 0
	Local aFileName := {}
	Local cEntity   := 'requestorders'
	Local aInit     := fInitWrite(oWs, cEntity)
	
	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If fCondDel(cAliasQry)
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			If !Empty((cAliasQry)->TJ_DTMPINI)
				cDtInicial := (cAliasQry)->TJ_DTMPINI
			Else
				cDtInicial := (cAliasQry)->TJ_DTORIGI
				printf('Ordem ' + (cAliasQry)->TJ_ORDEM + ' nao possui data inicial.')
			EndIf

			If !Empty((cAliasQry)->TJ_DTMPFIM)
				cDtFinal := (cAliasQry)->TJ_DTMPFIM
			Else
				cDtFinal := (cAliasQry)->TJ_DTORIGI
				printf('Ordem ' + (cAliasQry)->TJ_ORDEM + ' nao possui data final.')
			EndIf

			cSubJSON += '{"serviceRequest":"' 	+ NGEscape((cAliasQry)->SOLICI ) + '",'
			cSubJSON += '"orderCode":"' 		+ NGEscape((cAliasQry)->TJ_ORDEM ) + '",'
			cSubJSON += '"plan":"'				+ NGEscape( (cAliasQry)->TJ_PLANO ) + '",'
			cSubJSON += '"serviceCode":"' 		+ NGEscape((cAliasQry)->TJ_SERVICO ) + '",'
			cSubJSON += '"sequence":"' 			+ NGEscape( (cAliasQry)->TJ_SEQRELA ) + '",'
			cSubJSON += '"serviceName":"' 		+ NGEscape((cAliasQry)->T4_NOME ) + '",'
			cSubJSON += '"equipmentCode":"' 	+ NGEscape((cAliasQry)->TJ_CODBEM ) + '",'
			cSubJSON += '"equipmentName":"'		+ NGEscape((cAliasQry)->NOME ) + '",'
			cSubJSON += '"startDateTime":"'		+ cDtInicial + " " + NGEscape((cAliasQry)->TJ_HOMPINI ) + '",'
			cSubJSON += '"endDateTime":"'		+ cDtFinal   + " " + NGEscape((cAliasQry)->TJ_HOMPFIM ) + '",'
			cSubJSON += '"situation":"'			+ Alltrim( (cAliasQry)->TJ_SITUACA ) + '",'
			cSubJSON += '"type":"'				+ NGEscape( (cAliasQry)->TYPE ) + '",'

			If !Empty( (cAliasQry)->TJ_CCUSTO )
				cSubJSON += '"costCenterCode":"'	+ NGEscape((cAliasQry)->TJ_CCUSTO ) + '",'
				cSubJSON += '"costCenterName":"'	+ NGEscape((cAliasQry)->CTT_DESC01 ) + '",'
			Endif

			If (cAliasQry)->TJ_TERMINO == 'S'
				cSubJSON += '"finished":true,'
			EndIf

			// Caso a S.S. seja do tipo localização adiciona o item LOCATION como true
			If (cAliasQry)->TJ_TIPOOS == 'L'
				cSubJSON += '"location":true,'
			EndIf

			dbSelectArea('STJ')
			dbGoTo( (cAliasQry)->R_E_C_N_O_ )

			If lSYP
				cDescri := NGMEMOSYP(STJ->TJ_MMSYP)
			Else
				cDescri := STJ->TJ_OBSERVA
			EndIf
			cSubJSON += '"description":"' + NGEscape( cDescri ) + '"}'

			fWriteJson(cSubJSON, nUpdate, oWs)

		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + NGEscape( (cAliasQry)->TJ_ORDEM ) + '"'

		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//----------------------------------------------------------------------
/*/{Protheus.doc} QRequest
Query para solicitações de serviço

@author	Maria Elisandra de paula
@since 01/08/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de ss
/*/
//----------------------------------------------------------------------
Static Function QRequest( oWs, cDate, cOrigin, lOnlyExec )

	Local cQuery        := " SELECT TQB.TQB_SOLICI "
	Local lFilterUserSS := fHasPerms('onlyUserRelatedRequests')
	Local lLocSS    	:= fHasPerms('location-ss')

	Default lOnlyExec := .F.

	If cOrigin == "sRequest"

		cQuery += ", TQB.TQB_CODBEM, TQB.TQB_CCUSTO, TQB.R_E_C_N_O_, "
		cQuery += "	 TQB.TQB_DTABER, TQB.TQB_HOABER, TQB.TQB_CDSOLI, TQB.TQB_USUARI, TQB.TQB_RAMAL, "
		cQuery += "	 TQB.TQB_SOLUCA, TQB.TQB_CDSERV, TQB.TQB_DTFECH, TQB.TQB_HOFECH, "
		cQuery += "	 TQB.TQB_TEMPO,  TQB.TQB_CDEXEC, TQB.TQB_PRIORI, TQB.TQB_PSAP, TQB.TQB_PSAN, TQ3.TQ3_PESQST, "
		cQuery += "	 TQB.TQB_POSCON, TQB.TQB_POSCO2, TQB.TQB_TIPOSS, "
		cQuery += cIsNull + "(TQ4_NMEXEC,' ') AS EXECNAME,"

		//---------------------------------------------------------------------------------------------
		//Se o trecho abaixo for modificado, deve ser replicado na query Qrequest Orders
		//pois na entidade citada o controle de deletados também é realizado pela TQB como é feito aqui
		//----------------------------------------------------------------------------------------------
		cQuery += " CASE WHEN TQB.D_E_L_E_T_ = '*' THEN 'true' "
		cQuery += "	WHEN TQB.TQB_SOLUCA = 'C' THEN 'true' "
		 //Encerrada sem necessidade de feedback
		cQuery += " WHEN TQB.TQB_SOLUCA = 'E' AND TQ3.TQ3_PESQST = '2' THEN 'true' "
		 //Encerrada e já respondida
		cQuery += "	WHEN TQB.TQB_SOLUCA = 'E' AND TQ3.TQ3_PESQST = '1' AND TQB.TQB_PSAP <> ' ' THEN 'true' "
		//Encerrada não-respondida mas é de outro usuário
		cQuery += "	WHEN TQB.TQB_SOLUCA = 'E' AND TQ3.TQ3_PESQST = '1' AND TQB.TQB_PSAP = ' ' "
		cQuery += "		AND TQB.TQB_CDSOLI <> " + ValToSql( cUserLog ) + " THEN 'true' "

		//-----------------------------------------------------------------------------------
		// Envio de solicitações para serem deletadas, caso foi alterado o executante da ss
		//-----------------------------------------------------------------------------------
		If lFilterUserSS .And. cDate != '0'

			cQuery += " WHEN TQB.TQB_CDSOLI <> " + ValtoSql( cUserLog )

			If !Empty( cUserTQ4 ) //é executante de SS
				cQuery += " AND TQB.TQB_CDEXEC <> " + ValtoSql( cUserTQ4 )
			EndIf

			cQuery += " THEN 'true' "

		EndIf

		cQuery += "	ELSE ' ' END AS IS_DELETED "
	EndIf

	cQuery += " FROM " + RetSqlName("TQB") + " TQB"

	cQuery += " LEFT JOIN " + RetSqlName("TQ3") + " TQ3 "
	cQuery += " 	ON TQ3.TQ3_FILIAL = " + ValtoSql(FwxFilial("TQ3"))
	cQuery += "		AND TQ3.TQ3_CDSERV = TQB.TQB_CDSERV "

	cQuery += " LEFT JOIN " + RetSqlName("TQ4") + " TQ4 "
	cQuery += " 	ON TQ4.TQ4_FILIAL = " + ValtoSql(FwxFilial("TQ4"))
	cQuery += "		AND TQ4.TQ4_CDEXEC = TQB.TQB_CDEXEC "
	cQuery += "		AND TQ4.D_E_L_E_T_ = ' ' "

	// tratamento para considerar filtros de centro de custo
	cQuery += " LEFT JOIN  " + RetSQLName("CTT") + " CTT "
	cQuery += "		ON CTT.CTT_FILIAL = " + ValtoSql( FwxFilial("CTT") )
	cQuery += "		AND CTT.CTT_CUSTO = TQB.TQB_CCUSTO "
	cQuery += fWhereCtt( oWs )
	cQuery += "     AND CTT.D_E_L_E_T_ = ' ' "

	// tratamento para considerar filtros de bens e impedir inconsistencias entre TQB e ST9
	cQuery += " LEFT JOIN " + RetSqlName("ST9") + " ST9 "
	cQuery += " 	ON ST9.T9_FILIAL = " + ValtoSql( FwxFilial("ST9") )
	cQuery += "		AND ST9.T9_CODBEM = TQB.TQB_CODBEM "
	cQuery += fWhereSt9( oWs )
	cQuery += "		AND ST9.D_E_L_E_T_ = ' ' "

	// tratamento para considerar filtros de família de bens e impedir inconsistencias entre TQB e ST9/ST6
	cQuery += " LEFT JOIN " + RetSqlName("ST6") + " ST6 "
	cQuery += "		ON ST6.T6_FILIAL = " + ValtoSql( FwxFilial("ST6") )
	cQuery += "		AND  ST6.T6_CODFAMI = ST9.T9_CODFAMI "
	cQuery += fWhereSt6( oWs )
	cQuery += "		AND ST6.D_E_L_E_T_ = ' ' "

	If lMigrated

		// trecho que verifica as famílias(ST6) que não devem ser enviadas
		cQuery += " LEFT JOIN "+ RetSQLName('HP3') + " HP3_ST6 "
		cQuery += "  ON  HP3_ST6.HP3_FILIAL = " + ValToSQL( FWxFilial( "HP3" ) )
		cQuery += "  AND HP3_ST6.HP3_FILORI = ST6.T6_FILIAL "
		cQuery += "  AND HP3_ST6.HP3_CODGRP = " + ValToSQL( cUserGrp )
		cQuery += "  AND HP3_ST6.HP3_TABLE  = 'ST6' "
		cQuery += "  AND HP3_ST6.HP3_CODE   = ST6.T6_CODFAMI"
		cQuery += "  AND HP3_ST6.D_E_L_E_T_ = ' '"

		// trecho que verifica as areas(STD) que não devem ser enviadas
		cQuery += " LEFT JOIN "+ RetSQLName('HP3') + " HP3_CTT "
		cQuery += "  ON  HP3_CTT.HP3_FILIAL = " + ValToSQL( FWxFilial( "HP3" ) )
		cQuery += "  AND HP3_CTT.HP3_FILORI = CTT.CTT_FILIAL "
		cQuery += "  AND HP3_CTT.HP3_CODGRP = " + ValToSQL( cUserGrp )
		cQuery += "  AND HP3_CTT.HP3_TABLE  = 'CTT' "
		cQuery += "  AND HP3_CTT.HP3_CODE   = CTT.CTT_CUSTO"
		cQuery += "  AND HP3_CTT.D_E_L_E_T_ = ' '"

	EndIf

	If lLocSS

		// tratamento para considerar as ordens de localizações
		cQuery += " LEFT JOIN " + RetSqlName("TAF") + " TAF "
		cQuery += "		ON TAF.TAF_FILIAL = " + ValtoSql( FwxFilial("TAF") )
		cQuery += "		AND TAF.TAF_CODNIV = TQB.TQB_CODBEM "
		cQuery += "		AND TAF.D_E_L_E_T_ = ' ' "

	EndIf

	cQuery += " WHERE TQB.TQB_FILIAL = " + ValtoSql(FwxFilial("TQB"))

	cQuery += fFilterPe( oWs, 'FILTER_REQUEST' )

	// trecho que corresponde às condições left join da tabela HP3 logo acima
	If lMigrated
		cQuery += " AND HP3_ST6.HP3_CODE IS NULL "
		cQuery += " AND HP3_CTT.HP3_CODE IS NULL "
	EndIf

	//-------------------------------------------------------------------
	// Somente as solicitações de serviço relacionadas ao usuário
	// Deve haver o filtro somente no primeiro sync
	// A partir do segundo sync será tratado no case when
	//-------------------------------------------------------------------
	If lFilterUserSS .And. cDate == '0'

		If !lOnlyExec

			cQuery += " AND ( TQB.TQB_CDSOLI = " + ValtoSql( cUserLog )

			If !Empty( cUserTQ4 ) //é executante de SS
				cQuery += " OR TQB.TQB_CDEXEC = " + ValtoSql( cUserTQ4 )
			EndIf

			cQuery += ")"

		ElseIf lOnlyExec .And. !Empty( cUserTQ4 ) // Somente SS do executante

			cQuery += " AND ( TQB.TQB_CDEXEC = " + ValtoSql( cUserTQ4 ) +")" 
		
		EndIf
		
	EndIf

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "TQB_USERGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "TQB_USERGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cQuery += "	AND ( TQB.TQB_SOLUCA IN('A','D') "
		cQuery += " 	OR ( TQB.TQB_SOLUCA = 'E' AND TQ3.TQ3_PESQST = '1' "
		cQuery += " 		AND TQB.TQB_CDSOLI = " + ValToSql( cUserLog )
		cQuery += " 		AND TQB.TQB_PSAP = ' ' ) )" //pendente de feedback
		cQuery += " AND TQB.D_E_L_E_T_ = ' ' "
	EndIf

	// tratamento para evitar inconsistências e considerar filtros entre TQB e ST9/TAF/ST6
	If lLocSS
		cQuery += " AND ( ( TQB.TQB_TIPOSS = 'B' AND ST9.T9_CODBEM IS NOT NULL AND ST6.T6_CODFAMI IS NOT NULL AND CTT.CTT_CUSTO IS NOT NULL )  " 
		cQuery += " 	OR ( TQB.TQB_TIPOSS = 'L' AND TAF.TAF_CODNIV IS NOT NULL ) "
		cQuery += " 		AND ( TQB.TQB_CCUSTO = ' ' OR CTT.CTT_CUSTO IS NOT NULL ) ) "
	Else
		cQuery += " AND ( ST9.T9_CODBEM IS NOT NULL AND ST6.T6_CODFAMI IS NOT NULL AND CTT.CTT_CUSTO IS NOT NULL) "
	EndIf

Return cQuery

//----------------------------------------------------------------------
/*/{Protheus.doc} sRequest
Gera um arquivo json contendo as informações das solicitações de serviço
para a sincronização com o aplicativo mobile

@author	Maria Elisandra de paula
@since 01/08/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//----------------------------------------------------------------------
Static Function sRequest( oWs, cDate )

	Local cDelete   := ''
	Local lFirst	:= .T.
	Local lFirstD	:= .T.
	Local nCount	:= 0
	Local cHrIn		:= Time()
	Local cDescss   := ""
	Local cSolution := ""
	Local lMemoSS   := NGCADICBASE("TQB_CODMSS","A","TQB",.F.)
	Local lMemoSolu := NGCADICBASE("TQB_CODMSO","A","TQB",.F.)
	Local cSubJSON  := ""
	Local cQuery    := ChangeQuery( QRequest( oWs, cDate, "sRequest" ) )
	Local cAliasQry := GeraTemp( cQuery, 'Request' )
	Local nDelete   := 0
	Local nUpdate   := 0
	Local aFileName := {}
	Local cEntity   := 'request'
	Local aInit     := fInitWrite(oWs, cEntity)

	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If fCondDel(cAliasQry)
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			//----------------------------------------------
			// Tratamento para campos memo
			//----------------------------------------------
			dbSelectArea("TQB")
			dbGoTo((cAliasQry)->R_E_C_N_O_)

			If lMemoSS
				cDescss := NGMEMOSYP(TQB->TQB_CODMSS)
			Else
				cDescss := TQB->TQB_DESCSS
			EndIf

			If lMemoSolu
				cSolution := NGMEMOSYP(TQB->TQB_CODMSO)
			Else
				cSolution := TQB->TQB_DESCSO
			EndIf

			//-------------------------------------------------
			// Rótulos enviados independente da situação da ss
			//-------------------------------------------------
			cSubJSON += '{"serviceRequest":"' 	+ NGEscape((cAliasQry)->TQB_SOLICI ) + '",'
			cSubJSON += '"equipment":"'			+ NGEscape((cAliasQry)->TQB_CODBEM ) + '",'
			cSubJSON += '"dateTime":"'			+ (cAliasQry)->TQB_DTABER + " " + (cAliasQry)->TQB_HOABER + '",'
			cSubJSON += '"description":"' 		+ NGEscape(cDescss) + '",'
			cSubJSON += '"requesterCode":"'		+ NGEscape((cAliasQry)->TQB_CDSOLI) + '",'
			cSubJSON += '"requesterName":"'		+ NGEscape((cAliasQry)->TQB_USUARI ) + '",'
			cSubJSON += '"situation":"' 		+ (cAliasQry)->TQB_SOLUCA + '",'

			If !Empty((cAliasQry)->TQB_CDSERV)
				cSubJSON += '"serviceType":"' + NGEscape((cAliasQry)->TQB_CDSERV) + '",'
			EndIf

			If !Empty((cAliasQry)->TQB_RAMAL)
				cSubJSON += '"telephoneExtension":"'+ NGEscape((cAliasQry)->TQB_RAMAL) + '",'
			EndIf

			//-------------------------------------------------------------
			// Encerradas serão enviadas somente se tem pesquisa pendente
			//-------------------------------------------------------------
			If (cAliasQry)->TQB_SOLUCA == 'E' .AND. (cAliasQry)->TQ3_PESQST == '1' .AND.;
				 Alltrim((cAliasQry)->TQB_CDSOLI) == Alltrim( cUserLog )
				cSubJSON += '"finish":"' + (cAliasQry)->TQB_DTFECH + " " + (cAliasQry)->TQB_HOFECH + '",'
				cSubJSON += '"duration":"' + (cAliasQry)->TQB_TEMPO + '",'
			EndIf

			If (cAliasQry)->TQB_SOLUCA != 'A'
				cSubJSON += '"executor":"' + NGEscape((cAliasQry)->TQB_CDEXEC) + '",'

				If !Empty( (cAliasQry)->EXECNAME )
					cSubJSON += '"executorName":"' + NGEscape((cAliasQry)->EXECNAME) + '",'
				EndIf

				If !Empty( (cAliasQry)->TQB_PRIORI )
					cSubJSON += '"priority":"' + (cAliasQry)->TQB_PRIORI + '",'
				EndIf
			EndIf

			//-------------------------------------------------------------------------
			// Contadores serão enviados somente se foram informados na abertura da ss
			//-------------------------------------------------------------------------
			If (cAliasQry)->TQB_POSCON > 0
				cSubJSON += '"counter":' + cValtoChar((cAliasQry)->TQB_POSCON) + ','
			EndIf

			If (cAliasQry)->TQB_POSCO2 > 0
				cSubJSON += '"secondCounter":' + cValtoChar((cAliasQry)->TQB_POSCO2) + ','
			EndIf

			If !Empty( cSolution )
				cSubJSON += '"solution":"' + NGEscape( cSolution ) + '",'
			EndIf

			// Caso a S.S. seja do tipo localização adiciona o item LOCATION como true
			If (cAliasQry)->TQB_TIPOSS == 'L'
				cSubJSON += '"location":true,'
			EndIf

			//------------------------------
			// costCenter para fechar o json
			//------------------------------
			cSubJSON += '"costCenter":"' + NGEscape((cAliasQry)->TQB_CCUSTO ) + '"}'

			fWriteJson(cSubJSON, nUpdate, oWs)

		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + NGEscape( (cAliasQry)->TQB_SOLICI ) + '"'

		EndIf

		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//----------------------------------------------------------------------
/*/{Protheus.doc} NGUpsertSR
Realiza a inclusão/alteração da solicitação de serviço de acordo com a operação

@author	Maria Elisandra de paula
@since 02/08/2018
@param oWS, objeto, referência ao webservice
@param cOperation, caracter, operação para gerar/alterar solicitações:
		'update', 'distribute', 'finish', 'feedback' or 'order'
@param cSolici, caracter, código da solicitação (quando alteração)
@return array, [1] se obteve sucesso na operação
               [2] vazio ou descrição do erro
/*/
//----------------------------------------------------------------------
Function NGUpsertSR( oWS, cOperation, cSolici )

	Local aRet	 := { .T., ""}
	Local cJson	 := oWs:GetContent()
	Local oMntSR
	Local oParser
	Local cEqual := ""
	Local cError := ""
	Local aOrder := {}

	Default cSolici := ""

	printf("service-request: inicio " + cSolici)
	
	oMntSR := MntSR():New()

	If FWJsonDeserialize(cJson,@oParser) .And. ValType( oParser ) == "O"

		If cOperation == "create"
			//Variáveis públicas obrigatórias
			Public Inclui := .F.
			Public lLecancel := .F.
		ElseIf !NGIFDBSEEK("TQB", cSolici, 1)
			aRet := {.F., STR0138 } //"não localizada."
		EndIf

		If aRet[1]

			oMntSR:setOperation( IIf(cOperation == "create", 3, 4)) //Determina a operação
			oMntSR:setAsk(.F.)//Não apresenta mensagens condicionais

			//-----------------------------------------------------
			//Preenche os campos de acordo com a requisição do ws
			//-----------------------------------------------------
			aRet := fSetValueSS( oParser, oMntSR, cOperation, cSolici )

			If aRet[1]

				//-----------------------------------------------------
				//Verifica se a solicitação já foi incluída/alterada
				//-----------------------------------------------------
				cEqual := EqualRequest( oMntSR, cOperation, cSolici )

				If Empty(cEqual)

					printf("service-request: validando...")
					If !(oMntSR:valid()) //Validação da classe
						aRet[1] := .F.
						aRet[2] := oMntSR:GetErrorList()[1]
					Else
						printf("service-request: gravando dados...")
						If (cOperation $ "create/update/feedback" .And. oMntSR:upsert()) .Or.; //Realiza inclusão/alteração
							(cOperation == "distribute" .And. oMntSR:assign()) .Or. ;
							(cOperation == "finish" .And. oMntSR:close()) .Or.;
							(cOperation == "order" .And. Len(aOrder := oMntSR:createSO()) > 0 )

							If cOperation == "create"
								aRet[2] := '{"serviceRequest":"' + oMntSR:getValue("TQB_SOLICI") + '"}'
								Printf("service-request: " + oMntSR:getValue("TQB_SOLICI") + " incluida com sucesso!")
							ElseIf cOperation == "order"

								//-----------------------------------------------------
								//Inclusão de insumos realizados na ordem de serviço
								//-----------------------------------------------------
								If NGIFDBSEEK( "STJ", aOrder[1], 1 ) .And. !Empty( aInputs[_REALIZED_,_INSERT_] )

									printf(" Verificando insumos realizados XX ")
									aRet[2] := MNTNGInput( 1, aOrder[1], If( AttIsMemberOf( oParser, 'type' ), oParser:type, "C" ) )

									If Empty( aRet[2] )
										//----------------------------------------------------------------
										//caso não ocorra erro na inclusão da ordem de serviço e insumos,
										//a segunda posição do array é o código da ordem gerada
										//----------------------------------------------------------------
										aRet[2] := aOrder[1]
									Else
										aRet[1] := .F.
									EndIf

									printf(" Termino da verificacao de insumos realizados ")
								EndIf

								If aRet[1]
									aRet[2] := aOrder[1]
									Printf("service-request: ordem de servico " + aOrder[1] +  " incluida com sucesso!")
								EndIf

							Else
								Printf("service-request: " + oMntSR:getValue("TQB_SOLICI") +" alterada com sucesso!")
							EndIf

						Else
							aRet := { .F., oMntSR:GetErrorList()[1] }
						EndIf
					EndIf
				Else

					RollBackSX8() // Cancela utilização de numero sugerido caso exista			
					If cOperation == "create"
						aRet[2] := '{"serviceRequest":"' + cEqual + '"}'
					ElseIf cOperation == "order"
						aRet[2] := cEqual
					EndIf

					Printf("service-request: " + cEqual + " - operacao " + cOperation + " ja foi realizada")

				EndIf
			EndIf
		EndIf
	Else
		aRet := { .F., STR0070 } // "Corpo da requisição inválido"
	EndIf

	//--------------------------------
	// mensagem de erro, caso ocorra
	//---------------------------------
	If !aRet[1]
		DO CASE
		CASE cOperation == "create"
			cError += STR0139 //"Erro ao incluir solicitação"
		CASE cOperation == "distribute"
			cError += STR0140 + " " + cSolici //"Erro ao distribuir a solicitação"
		CASE cOperation == "finish"
			cError += STR0141 + " " + cSolici //"Erro ao encerrar a solicitação "
		CASE cOperation == "order"
			cError += STR0142 + " " + cSolici //"Erro ao gerar ordem de serviço para a solicitação "
		OTHERWISE
			cError += STR0143 + " " + cSolici //"Erro ao alterar a solicitação"
		ENDCASE

		aRet[2] := cError + ": " + aRet[2]
	EndIf

	oMntSR:Free() //Elimina o objeto da memória.
Return aRet

//----------------------------------------------------------------------
/*/{Protheus.doc} removeSR
Realiza a exclusão da solicitação

@author	Maria Elisandra de paula
@since 06/08/2018
@param oWS, objeto, referência ao webservice
@param cSolici, caracter, código da solicitação a ser excluída
@return array, [1] se obteve sucesso na operação
               [2] vazio ou descrição do erro
/*/
//----------------------------------------------------------------------
Static Function removeSR( oWS, cSolici )

	Local aRet	 := { .T., "" }
	Local oMntSR
	Local cAliasQry

	Printf("service-request: " + cSolici + " - excluir")

	oMntSR := MntSR():New()

	If !NGIFDBSEEK("TQB", cSolici, 1)

		cAliasQry := GetNextAlias()
		BeginSql Alias cAliasQry
			SELECT D_E_L_E_T_ EXCLUIDO FROM %table:TQB%
			WHERE TQB_FILIAL = %xFilial:TQB% AND TQB_SOLICI = %Exp:cSolici%
		EndSql

		If (cAliasQry)->EXCLUIDO == "*"
			Printf("service-request: operacao excluir ja realizada.")
			(cAliasQry)->(dbCloseArea())
			Return aRet
		Else
			Printf("service-request: " + cSolici + " nao localizada.")
			(cAliasQry)->(dbCloseArea())
			Return {.F., STR0145 } //"Solicitação não localizada."
		EndIf
	EndIf

	oMntSR:setAsk(.F.)//Não apresenta mensagens condicionais
	oMntSR:setOperation(5)
	oMntSR:load({FwxFilial("TQB") + cSolici}) // carrega campos da solicitação

	// Retira campo prioridade
	oMntSR:removeField( "TQB_PRIORI" )

	If !(oMntSR:valid() .And. oMntSR:delete()) //Realiza inclusão
		aRet[1] := .F.
		aRet[2] := STR0144 + ":" + Space(1) + cSolici + Space(1) + oMntSR:GetErrorList()[1] //"Erro ao excluir a solicitação"
		Printf("service-request: " + aRet[2])
	Else
		Printf("service-request: " + oMntSR:getValue("TQB_SOLICI") + " excluida com sucesso!")
	EndIf

	oMntSR:Free() //Elimina o objeto da memória.
Return aRet

//----------------------------------------------------------------------
/*/{Protheus.doc} fSetValueSS
Carrega os campos necessários de acordo com a objeto ws

@author	Maria Elisandra de paula
@since 06/08/2018
@param oParser, objeto, conteúdo recebido pela requisição
@param oMntSR, objeto, instância da classe MNTSR - ss
@param cOperation, caracter, tipo de operação ex.: "distribute"
@param cSolici, caracter, código da solicitação de serviço
@return array, [1] se obteve sucesso na operação
               [2] vazio ou descrição do erro
/*/
//----------------------------------------------------------------------
Static Function fSetValueSS( oParser, oMntSR, cOperation, cSolici )

	Local xValue
	Local aFieldsOrder := {}
	Local aChecklist := {}
	Local aJSON_Inputs := {}
	Local aTemp := {}
	Local ochecklist
	Local nX
	Local cError     := ""
	Local lRepCont   := SuperGetMV( 'MV_NGLANEX', .F., '' ) != 'A'
	Local cEquipment := ''

	Default cSolici := ""

	printf("service-request: carregando dados...")

	If cOperation == "create"

		//------------------------------------------------
		//Campos que só podem ser preenchidos na inclusão
		//------------------------------------------------

		oMntSR:setValue("TQB_FILIAL", FwxFilial("TQB"))
		oMntSR:setValue("TQB_ORIGEM", IIf( AttIsMemberOf( oParser, "origin" ), oParser:origin, "MNTNG" ) )

		If AttIsMemberOf( oParser, "equipment" )
			cEquipment := PadR( oParser:equipment, TamSx3( 'T9_CODBEM' )[1] )
			oMntSR:setValue( 'TQB_CODBEM', cEquipment )
		EndIf

		//----------------------------------------------------------------------------------------------
		// Data e hora é considerado as informações enviadas do app para não gerar duplicadas
		//----------------------------------------------------------------------------------------------
		If AttIsMemberOf( oParser, "datetime" )
			xValue := StrTokArr( oParser:datetime," ")
			oMntSR:setValue( "TQB_DTABER", Stod( xValue[1] ) )
			oMntSR:setValue( "TQB_HOABER", xValue[2] )
			xValue := Nil
		EndIf

		//---------------------------------------------------------------------------
		// Recupera o centro de custo e centro de trabalho do equipamento no período
		//---------------------------------------------------------------------------
		If AttIsMemberOf( oParser, "location" )

			oMntSR:setValue( 'TQB_TIPOSS', 'L' )
			// Caso centro de custo esteja no Header, utilizará seu conteúdo
			If AttIsMemberOf( oParser, "costCenter" )

				If NGIFDBSEEK( 'CTT', oParser:costCenter, 1, .F.  )
					oMntSR:setValue( 'TQB_CCUSTO', Padr( oParser:costCenter, TamSx3("CTT_CUSTO")[1] ) )
				Else
					Return { .F., STR0186 } // 'Centro de custo informado não é válido! Favor verificar o conteúdo do campo costCenter'
				EndIf
				
			Else
				oMntSR:setValue( 'TQB_CCUSTO', Posicione( 'TAF', 7, FwxFilial( 'TAF' ) + 'X2' + SubStr( oParser:equipment, 1, 3 ), 'TAF_CCUSTO' ) )
			EndIf
			oMntSR:setValue( 'TQB_CENTRA', Posicione( 'TAF', 7, FwxFilial( 'TAF' ) + 'X2' + SubStr( oParser:equipment, 1, 3 ), 'TAF_CENTRA' ) )

		Else

			dbSelectArea('ST9')
			dbSetOrder(1)
			If MsSeek( FwxFilial('ST9') + cEquipment)
				oMntSR:setValue( 'TQB_CCUSTO', ST9->T9_CCUSTO )
				oMntSR:setValue( 'TQB_CENTRA', ST9->T9_CENTRAB )
			EndIf

		EndIf

		xValue := Nil
		
		If lRepCont
			
			If AttIsMemberOf( oParser, "counter" ) .And. Valtype( oParser:counter ) == 'N'
				oMntSR:setValue("TQB_POSCON", oParser:counter)
			EndIf

			If AttIsMemberOf( oParser, "secondCounter" ) .And. Valtype( oParser:secondCounter ) == 'N'
				oMntSR:setValue("TQB_POSCO2", oParser:secondCounter)
			EndIf

		EndIf

	Else

		oMntSR:load({FwxFilial("TQB") + cSolici}) // Busca a chave da tabela de solicitação de serviço

	EndIf

	//----------------------------------------
	//Carrega status de acordo com operação
	//----------------------------------------
	Do Case
		Case cOperation == "create"
			oMntSR:setValue("TQB_SOLUCA", "A") //em análise
		Case cOperation == "distribute"
			oMntSR:setValue("TQB_SOLUCA", "D") //distribuída
		Case cOperation == "finish"
			oMntSR:setValue("TQB_SOLUCA", "E") //encerrada

	EndCase

	If AttIsMemberOf( oParser, "telephoneExtension" )
		oMntSR:setValue("TQB_RAMAL", oParser:telephoneExtension)
	EndIf

	If AttIsMemberOf( oParser, "description" )
		oMntSR:setValue("TQB_DESCSS", oParser:description)
	EndIf

	If AttIsMemberOf( oParser, "serviceType" )
		oMntSR:setValue("TQB_CDSERV", oParser:serviceType)
	EndIf

	If AttIsMemberOf( oParser, "priority" )
		If oParser:priority $ '1/2/3'
			oMntSR:setValue("TQB_PRIORI", oParser:priority)
		Else
			Return { .F., STR0184 } // 'Valor informado do campo prioridade inválido! Favor verificar o campo priority'
		EndIf
	ElseIf Empty( oMntSR:GetValue("TQB_PRIORI") )
		oMntSR:removeField( "TQB_PRIORI" )
	EndIf

	If AttIsMemberOf( oParser, "executor" )
		oMntSR:setValue("TQB_CDEXEC", oParser:executor)
	EndIf

	If cOperation == "finish"
		//--------------------------------------------------------
		//Campos que podem ser alterados somente no encerramento
		//--------------------------------------------------------
		If AttIsMemberOf( oParser, "finish" )
			xValue := StrTokArr( oParser:finish, " ")
			oMntSR:setValue("TQB_DTFECH", Stod(xValue[1]))
			oMntSR:setValue("TQB_HOFECH", xValue[2])
			xValue := nil
		EndIf

		If AttIsMemberOf( oParser, "duration" )
			oMntSR:setValue("TQB_TEMPO", oParser:duration)
		EndIf

		If AttIsMemberOf( oParser, "solution" )
			oMntSR:setValue("TQB_DESCSO", oParser:solution)
		EndIf

	ElseIf cOperation == "feedback"
		//----------------------------------------------------
		//Campos que podem ser alterados somente na pesquisa
		//----------------------------------------------------
		If AttIsMemberOf( oParser, "onTimeService" )
			oMntSR:setValue("TQB_PSAP", oParser:onTimeService)
		EndIf

		If AttIsMemberOf( oParser, "needFeedback" )
			oMntSR:setValue("TQB_PSAN", oParser:needFeedback)
		EndIf

		If AttIsMemberOf( oParser, "onTimeDescription" )
			oMntSR:setValue("TQB_OBSPRA", oParser:onTimeDescription)
		EndIf

		If AttIsMemberOf( oParser, "needFeedback" )
			oMntSR:setValue("TQB_OBSATE", oParser:needFeedback)
		EndIf

	ElseIf cOperation == "order"

		//-----------------------------------------------------
		// carrega campos da ordem de serviço da solicitação
		//-----------------------------------------------------
		If AttIsMemberOf( oParser, "equipment" )
			aAdd( aFieldsOrder, {"TJ_CODBEM" , Padr( oParser:equipment, TamSx3("T9_CODBEM")[1] ) } )
		Else
			aAdd( aFieldsOrder, { "TJ_CODBEM" , "" } )
		EndIf

		aAdd( aFieldsOrder, {"TJ_OBSERVA", IIf( AttIsMemberOf( oParser, "observation"), oParser:observation , "")})
		aAdd( aFieldsOrder, {"TJ_SERVICO", IIf( AttIsMemberOf( oParser, "service" ) , Padr( oParser:service, TamSx3("T4_SERVICO")[1] ) , "")})
		
		If AttIsMemberOf( oParser, "situation" )
			If Upper( oParser:situation ) $ 'L/P/C'
				aAdd( aFieldsOrder, { "TJ_SITUACA", oParser:situation } )
			Else
				Return { .F., STR0185 } //'A situação informada para abetura da O.S. não é válida! Favor informar uma situação válida.'
			EndIf
		Else
			aAdd( aFieldsOrder, { "TJ_SITUACA", "L" } )
		EndIf
		
		If AttIsMemberOf( oParser, "costCenter" )
			If NGIFDBSEEK( 'CTT', oParser:costCenter, 1, .F.  )
				aAdd( aFieldsOrder, {"TJ_CCUSTO" , Padr( oParser:costCenter, TamSx3("CTT_CUSTO")[1] ) })
			Else
				Return { .F., STR0186 } // 'Centro de custo informado não é válido! Favor verificar o conteúdo do campo costCenter'
			EndIf
		Else
			aAdd( aFieldsOrder, { 'TJ_CCUSTO', '' } )
		EndIf

		aAdd( aFieldsOrder, {"TJ_SEQRELA" , IIf( AttIsMemberOf( oParser, "sequence" ) , oParser:sequence  , "000")})
		aAdd( aFieldsOrder, {"TJ_PLANO"   , IIf( AttIsMemberOf( oParser, "sequence" ) , "000001"  , "000000")})

		If AttIsMemberOf( oParser, "location" )
			aAdd( aFieldsOrder, {'TJ_TIPOOS', 'L'})
		EndIf

		If AttIsMemberOf( oParser, "workCenter" )
			aAdd( aFieldsOrder, {"TJ_CENTRAB", Padr( oParser:workCenter, TamSx3("TJ_CENTRAB")[1] )})
		EndIf

		If AttIsMemberOf( oParser, "startDate" )
			xValue := StrTokArr( oParser:startDate, " ")
			aAdd( aFieldsOrder, {"TJ_DTORIGI", Stod(xValue[1])})
			aAdd( aFieldsOrder, {"TJ_HOMPINI", xValue[2]})
			
		Else
			aAdd( aFieldsOrder, {"TJ_DTORIGI", Ctod("") })
			aAdd( aFieldsOrder, {"TJ_HOMPINI", "" })
		EndIf

		If lRepCont .And. AttIsMemberOf( oParser, 'counter' ) .And. Valtype( oParser:counter ) == 'N'
			aAdd( aFieldsOrder, { 'TJ_POSCONT', oParser:counter } )
			aAdd( aFieldsOrder, { 'TJ_HORACO1', xValue[ 2 ] } )
		Else
			aAdd( aFieldsOrder, { 'TJ_POSCONT', 0 } )
		EndIf

		If lRepCont .And. AttIsMemberOf( oParser, 'secondCounter' ) .And. Valtype(oParser:secondCounter) == 'N'
			aAdd( aFieldsOrder, { 'TJ_POSCON2', oParser:secondCounter } )
			aAdd( aFieldsOrder, { 'TJ_HORACO2', xValue[ 2 ] } )
		Else
			aAdd( aFieldsOrder, { 'TJ_POSCON2', 0 } )
		EndIf

		//-----------------------------------------
		// Informações de parada do equipamento
		//-----------------------------------------
		If AttIsMemberOf( oParser, "downTime" )

			xValue := StrTokArr( oParser:downTime, " " )
			If !Empty( xValue[1] ) .And. !Empty( xValue[2] )
				aAdd( aFieldsOrder, {"TJ_DTPRINI", Stod( xValue[1] ) })
				aAdd( aFieldsOrder, {"TJ_HOPRINI", xValue[2] })
			EndIf
			xValue := Nil

		EndIf

		//---------------------------------------------------------------
		// carrega insumos previstos da ordem de serviço da solicitação
		//---------------------------------------------------------------
		If AttIsMemberOf( oParser, "inputs" ) .And. Len( oParser:inputs ) > 0
			//carrega arrays de insumos
			cError := getInputs( oParser:inputs )

			If !Empty( cError )
				Return { .F., cError }
			Else

				aInsert := aClone( aInputs[_FORESEEN_,_INSERT_] )

				For nX:= 1 to Len( aInsert ) //somente insumos não realizados
					aTemp := {}
					aAdd( aTemp, { "TL_TAREFA" , aInsert[nX,_TASK_] } )
					aAdd( aTemp, { "TL_TIPOREG", aInsert[nX,_TYPE_] } )
					aAdd( aTemp, { "TL_CODIGO" , aInsert[nX,_CODE_] } )
					aAdd( aTemp, { "TL_QUANREC", aInsert[nX,_RESOURCEAMOUNT_] } )
					aAdd( aTemp, { "TL_QUANTID", aInsert[nX,_AMOUNT_] } )
					aAdd( aTemp, { "TL_UNIDADE", aInsert[nX,_UNITY_] } )
					aAdd( aTemp, { "TL_DESTINO", aInsert[nX,_DESTINY_] } )
					aAdd( aTemp, { "TL_DTINICI", aInsert[nX,_STARTDATE_] } )
					aAdd( aTemp, { "TL_HOINICI", aInsert[nX,_STARTHOUR_] } )
					aAdd( aTemp, { "TL_DTFIM"  , aInsert[nX,_ENDDATE_] } )
					aAdd( aTemp, { "TL_HOFIM"  , aInsert[nX,_ENDHOUR_] } )
					aAdd( aTemp, { "TL_LOCAL"  , aInsert[nX,_WAREHOUSE_] } )
					aAdd( aTemp, { "TL_USACALE", aInsert[nX,_USECALE_] } )
					aAdd( aTemp, { "TL_SEQTARE", aInsert[nX,_SEQTASK_] } )
					aAdd( aTemp, { "TL_OBSERVA", aInsert[nX,_INPUTNOTE_] } )

					aAdd( aJSON_Inputs, aTemp )
				Next nX
			EndIf
		EndIf

		//-------------------------------------------------
		// carrega etapas da ordem de serviço da solicitação
		//-------------------------------------------------
		If AttIsMemberOf( oParser, "checklist" ) .And. Len( oParser:checklist ) > 0
			For nX:= 1 to Len( oParser:checklist )

				ochecklist := oParser:checklist[nX]
				aTemp := {}
				aAdd( aTemp, { "TQ_TAREFA" , IIf( AttIsMemberOf( ochecklist, "task" ), Padr( ochecklist:task, TamSx3("TQ_TAREFA")[1] ), "" ) } )
				aAdd( aTemp, { "TQ_ETAPA"  , IIf( AttIsMemberOf( ochecklist, "step" ), Padr( ochecklist:step, TamSx3("TQ_ETAPA")[1] ), "" ) } )
				aAdd( aTemp, { "TQ_SEQETA" , IIf( AttIsMemberOf( ochecklist, "sequence" ), Padr( ochecklist:sequence, TamSx3("TQ_SEQETA")[1] ), "" ) } )	

				aAdd( aChecklist, aTemp )

			Next nX
		Else
			aAdd( aChecklist, { } )
		EndIf

		If Len( aJSON_Inputs ) == 0
			aAdd( aJSON_Inputs, { } )
		EndIf

		oMntSR:setValueSO( { { aFieldsOrder, aJSON_Inputs, aChecklist } } )

	EndIf

Return { .T., "" }

//--------------------------------------------------------------------------------
/*/{Protheus.doc}  EqualRequest
Verifica se a inclusão/alteração já ocorreu.Esta verificação deve ocorrer
para não haver duplicidade de registros com códigos diferentes (quando inclusão)
e para evitar que um workflow seja enviado duas vezes.

@param oMntSR, objeto, instância da classe de solicitação MNTSR
@param cOperation, caracter, tipo de operação relacionada as rotas do ws:
		pode ser: "create", "update", "distribute", "finish" ou "feedback"
@param cSolici, caracter, código da solicitação de serviço
@author Maria Elisandra de Paula
@since 06/08/2018
@return string, vazio ou o código da ss já existente com as mesmas características
/*/
//---------------------------------------------------------------------
Static Function EqualRequest( oMntSR, cOperation, cSolici )

	Local cAliasQry := GetNextAlias()
	Local cQuery    := ""
	Local cEqual    := ""
	Local xValue
	Local lMultiple := SuperGetMv( 'MV_NGMULOS', .F., 'S' ) == 'S'
	Local nCodBem   := 0
	Local nHr		:= 0
	Local nDt		:= 0
	Local nServico	:= 0
	Local aFieldsOrder := {}

	printf("service-request: verificando...")

	If cOperation == "order"

		aFieldsOrder := oMntSR:aFieldSo[1, __AFIELDSO_SO__] //será sempre primeira posição pois é inserido apenas uma ordem por vez

		If lMultiple
			cQuery := " SELECT TT7_SOLICI SOLICI, TT7_ORDEM ORDEM "
		Else
			cQuery := " SELECT TQB_SOLICI SOLICI, TQB_ORDEM ORDEM "
		EndIf

		cQuery += " FROM " + RetSqlName("STJ") + " STJ"

		If lMultiple
			cQuery += " JOIN " + RetSqlName("TT7") + " TT7 "
			cQuery += "		ON TT7.TT7_FILIAL = " + ValtoSql(FwxFilial("TT7"))
			cQuery += " 	AND TT7.TT7_ORDEM = STJ.TJ_ORDEM "
			cQuery += " 	AND TT7.TT7_SOLICI = " + ValtoSql( cSolici )
			cQuery += " 	AND TT7.D_E_L_E_T_ = ' ' "
		Else
			cQuery += " JOIN " + RetSqlName("TQB") + " TQB" 
			cQuery += " 	ON TQB.TQB_FILIAL = " + ValtoSql(FwxFilial("TQB"))
			cQuery += " 	AND TQB.TQB_ORDEM = STJ.TJ_ORDEM "
			cQuery += " 	AND TQB.TQB_SOLICI = " + ValtoSql( cSolici )
			cQuery += " 	AND TQB.D_E_L_E_T_ = ' ' "
		EndIf

		cQuery += " WHERE STJ.TJ_FILIAL = " + ValtoSql( FwxFilial("STJ") )

		If (nCodBem	:= aScan(aFieldsOrder,{|x| AllTrim(Upper(X[1])) == "TJ_CODBEM" })) > 0
			cQuery += " AND TJ_CODBEM =  " + ValtoSql( aFieldsOrder[nCodBem, 2] )
		EndIf

		If (nDt := aScan(aFieldsOrder,{|x| AllTrim(Upper(X[1])) == "TJ_DTORIGI" })) > 0
			cQuery += " AND TJ_DTORIGI = " + ValtoSql( aFieldsOrder[nDt, 2] )
		EndIf

		If (nHr	:= aScan(aFieldsOrder,{|x| AllTrim(Upper(X[1])) == "TJ_HOMPINI" })) > 0
			cQuery += " AND TJ_HOMPINI = " + ValtoSql( aFieldsOrder[nHr, 2] )
		EndIf

		If (nServico:= aScan(aFieldsOrder,{|x| AllTrim(Upper(X[1])) == "TJ_SERVICO" })) > 0
			cQuery += " AND TJ_SERVICO = " + ValtoSql( aFieldsOrder[nServico, 2] )
		EndIf

		cQuery += "	AND STJ.D_E_L_E_T_ = ' ' "

	Else

		cQuery := " SELECT TQB_SOLICI SOLICI FROM " + RetSqlName("TQB") + " TQB"
		cQuery += " WHERE TQB.TQB_FILIAL = " + ValtoSql(FwxFilial("TQB"))

		If cOperation == "create"
			//----------------------------------------------------------------
			//Compara campos preenchidos na inclusão e não podem ser alterados
			//----------------------------------------------------------------
			cQuery += "	AND TQB_CODBEM = " + ValToSql(oMntSR:getValue("TQB_CODBEM"))
			cQuery += "	AND TQB_DTABER = " + ValToSql(oMntSR:getValue("TQB_DTABER"))
			cQuery += "	AND TQB_HOABER = " + ValToSql(oMntSR:getValue("TQB_HOABER"))
			cQuery += "	AND TQB_POSCON = " + ValToSql(oMntSR:getValue("TQB_POSCON"))
			cQuery += "	AND TQB_POSCO2 = " + ValToSql(oMntSR:getValue("TQB_POSCO2"))
			cQuery += "	AND TQB_CDSOLI = " + ValToSql(oMntSR:getValue("TQB_CDSOLI"))
			cQuery += " AND TQB_CDSERV = " + ValToSql(oMntSR:getValue("TQB_CDSERV"))

		Else
			cQuery += " AND TQB_SOLICI = " + ValToSql(oMntSR:getValue("TQB_SOLICI"))

			If cOperation == "update"
				cQuery += " AND TQB_RAMAL  = " + ValToSql(oMntSR:getValue("TQB_RAMAL"))
				cQuery += " AND TQB_CDSERV = " + ValToSql(oMntSR:getValue("TQB_CDSERV"))
				cQuery += " AND TQB_PRIORI = " + ValToSql(oMntSR:getValue("TQB_PRIORI"))
				cQuery += " AND TQB_CDEXEC = " + ValToSql(oMntSR:getValue("TQB_CDEXEC"))
			ElseIf cOperation == "distribute"
				cQuery += " AND TQB_SOLUCA = 'D'"
			ElseIf cOperation == "finish"
				cQuery += " AND TQB_SOLUCA = 'E'"
			Elseif cOperation == "feedback"
				cQuery += " AND TQB_PSAP <> ' '"
			EndIf
		EndIf

		cQuery += " AND TQB.D_E_L_E_T_ = ' ' "

	EndIf

	cQuery := ChangeQuery( cQuery )
	dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)

	cEqual := (cAliasQry)->SOLICI

	If !Empty( cEqual )

		If cOperation == "order"
			cEqual := (cAliasQry)->ORDEM
		Else
			//-----------------------------------------
			// Verifica se o campo memo foi alterado
			//-----------------------------------------
			dbSelectArea("TQB")
			dbSetOrder(1)
			If dbSeek(FwxFilial("TQB") + cEqual )

				If NGCADICBASE("TQB_CODMSS","A","TQB",.F.)
					xValue := NGMEMOSYP(TQB->TQB_CODMSS)
				Else
					xValue := TQB->TQB_DESCSS
				EndIf

				If Alltrim(xValue) != Alltrim(oMntSR:getValue("TQB_DESCSS"))// Verifica se o campo memo foi alterado
					cEqual := ""
				EndIf

			EndIf
		EndIf
	EndIf

	(cAliasQry)->(dbCloseArea())

Return cEqual

//----------------------------------------------------------------------
/*/{Protheus.doc} listImgSR
Envia lista de imagens vinculadas a solicitação de serviço

@author	Maria Elisandra de paula
@since 20/08/2018
@param cSolici, caracter, código da solicitação a ser excluída
@param oWs, objeto, webservice
@return array, [1] se obteve sucesso na operação
               [2] vazio ou descrição do erro
/*/
//----------------------------------------------------------------------
Static Function listImgSR( cSolici, oWs )

	Local oMntSR
	Local aResponse := {}

	printf( "service-request: lista imagens")

	oMntSR := MntSR():New()

	// Garante existência da ordem de serviço
	If !NGIFDBSEEK("TQB", cSolici, 1)
		printf("service-request: nao localizada")
		Return .F.
	EndIf

	aResponse := fListImg( cSolici, 'TQB' )

	oWs:SetResponse( FWJsonSerialize( aResponse, .F. ) )
	oWs:SetStatus( 200 )
	oMntSR:Free()

Return .T.

//----------------------------------------------------------------------
/*/{Protheus.doc} delImageSR
Remove uma imagem da solicitação de serviço
do \dirdoc\ e da tabelas AC9 e ACB

@author	Maria Elisandra de paula
@since 21/08/2018
@param cID, caracter, código do objeto no banco do conhecimento
@param oWs, objeto, referencia do ws rest
@return array, [1] se obteve sucesso na operação
               [2] vazio ou descrição do erro
/*/
//----------------------------------------------------------------------
Static Function delImageSR( oWs, cID )

	Local aRet := { .T., "" }
	Local oMntSR

	Printf( "Service request: delImageSR "  + cID )

	oMntSR := MntSR():New()

	If !oMntSR:deleteFile( cID ) .And. Len( oMntSR:getErrorList() ) > 0
		aRet := {.F. , oMntSR:getErrorList()[1] }
	EndIf
Return aRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fSpecialties
Busca especialidades do funcionário

@param cCodFunc, caracter, código do funcionário na ST1
@author	Maria Elisandra de Paula
@since 28/08/2018
@return array, especialidades do funcionário
/*/
//---------------------------------------------------------------------
Static Function fSpecialties( cCodFunc )

	Local aRet := {}
	Local cAliasQry := GetNextAlias()

	BeginSql Alias cAliasQry
		SELECT T2_ESPECIA
		FROM %table:ST2% ST2
		WHERE
			ST2.T2_FILIAL = %xFilial:ST2% AND
			ST2.T2_CODFUNC = %Exp:cCodFunc% AND
			ST2.%NotDel%
	EndSql

	While !( cAliasQry )->( EoF() )
		aAdd( aRet, ( cAliasQry )->T2_ESPECIA )
		( cAliasQry )->(dbSkip())
	EndDo

	( cAliasQry )->(dbCloseArea())

Return aRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fUserQuery
String para usuário de inclusão

@author	Maria Elisandra de Paula
@since 04/10/2018
@return string, utilizado para comparação de usuário
/*/
//---------------------------------------------------------------------
Static Function fUserQuery()

	Local cQuery := " RTRIM( "

	cQuery += " SUBSTRING(TJ_USERLGI, 11,1) || SUBSTRING(TJ_USERLGI, 15,1) ||"
	cQuery += "  SUBSTRING(TJ_USERLGI, 2, 1) || SUBSTRING(TJ_USERLGI, 6, 1) ||"
	cQuery += "  SUBSTRING(TJ_USERLGI, 10,1) || SUBSTRING(TJ_USERLGI, 14,1) ||"
	cQuery += "  SUBSTRING(TJ_USERLGI, 1, 1) || SUBSTRING(TJ_USERLGI, 5, 1) ||"
	cQuery += "  SUBSTRING(TJ_USERLGI, 9, 1) || SUBSTRING(TJ_USERLGI, 13,1) ||"
	cQuery += "  SUBSTRING(TJ_USERLGI, 17,1) || SUBSTRING(TJ_USERLGI, 4, 1) )"

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} fCheckVars
Validações iniciais para rotas
Aciona função que carrega variáveis staticas
Todas as rotas devem passar por essa função

@author	Maria Elisandra de Paula
@since 22/11/2018
@param oWS, objeto, referência ao webservice
@param lSyncVars, boolean, se deve carregar variáveis de sincronismo
@return logic, se obteve sucesso na inicialização do ambiente e usuário válido
/*/
//---------------------------------------------------------------------
Static Function fCheckVars( oWs, lSyncVars )

	Local lRet   := .T.
	Local cError := ''
	Local aNgKey := {}

	Default lSyncVars := .F.

	oWs:ClearResponse()
	oWs:SetContentType( 'application/json' )

	If Select('SM0') == 0 .Or. ;
		Type( 'cEmpAnt' ) != 'C' .Or.;
		Type( 'cFilAnt' ) != 'C' .Or.;
		Type( '__cUserId' ) != 'C' .Or.;
		Empty(cEmpAnt) .Or.;
		Empty(cFilAnt) .Or.;
		Empty(__cUserID)

		lRet := .F.
		cError := STR0178 // "A requisição está inválida. A empresa/filial não foi aberta corretamente"

	EndIf
		
	If lRet

		StartStatics( oWs, lSyncVars ) //inicializa variáveis static

		If lMigrated
			If Empty( cUserGrp )
				cError := "Usuário não cadastrado em nenhum grupo. (Cadastro em MNTA916)"
				lRet := .F.
			EndIf

			If lRet
				aNgKey := fGet1Key()
				If (Empty(aNgKey[2]) .Or. Empty(aNgKey[3]))
					cError := "O parâmetro MV_NG1KEY não está preenchido corretamente."
					lRet := .F.
				EndIf
			EndIf
		EndIf

	EndIf

	If !lRet
		SetRestFault(401, FwhttpEncode( cError ) )
		Printf( cError )
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} PrintPostLog
Realiza operações finais após as operações realizadas nas rotas post

@author	Maria Elisandra de Paula
@since 22/11/2018
@param oWS, objeto, referência ao webservice
@param lRet, boolean, indica se as operações ocorreram com sucesso
@param aRet, array, retorno das operações
				[1] indica se as operações ocorreram com sucesso
				[2] mensagem de erro/sucesso
				[3] Etapas não geradas
				[4] Código de erro MNTNG.
@return logic, se operações foram realizadas com sucesso de acordo com os parâmetros
/*/
//---------------------------------------------------------------------
Static Function PrintPostLog( oWs, lRet, aRet )

	Local nSize     := 0
	Local nCodeRest := 400

	Default aRet := {}

	// Verifica tamanho do array de informações
	nSize := Len( aRet )

	If nSize > 0

		If !aRet[ 1 ]
			lRet := .F.
			If nSize > 3
				nCodeRest := aRet[ 4 ]
			EndIf
			SetRestFault( nCodeRest, EncodeUTF8( aRet[ 2 ] ), , 400 )
			printf( '-------------------------------------------' )
			printf('SetRestFault: ' + cValToChar( nCodeRest ) )
			printf( aRet[ 2 ] )
			printf( '-------------------------------------------' )
		Else
			oWs:SetStatus( 200 )
			If !Empty( aRet[2] )
				oWs:SetResponse( EncodeUtf8( aRet[2] ) )
			Else
				oWs:SetResponse( '{}' )
			EndIf
		EndIf

	ElseIf !lRet
		printf('-------------------------------------------')
		printf('SetRestFault: 500')
		printf("Houve um problema ao executar a requisição.")
		printf('-------------------------------------------')
		SetRestFault( 500, EncodeUTF8(STR0010) )//"Houve um problema ao executar a requisição."
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} CloseTransactions
Realiza operações pós controle de transação

@author	Maria Elisandra de Paula
@since 22/11/2018
@param aRet, array, retorno das operações
				[1] indica se as operações ocorreram com sucesso
@return nil
/*/
//---------------------------------------------------------------------
Static Function CloseTransactions( aRet )

	//Caso tenha sido executado e tenha caído em uma validação
	If len(aRet) > 0 .And. !aRet[1]
		DisarmTransaction()
	EndIf

	//Garante que todos os BeginTran foram liberados
	While inTransact()
		printf('------------ Liberando transacao ------------')
		EndTran()
	Enddo

	//Garante que todos os registro foram liberados
	DBCommitAll( )
	MsUnlockAll( )

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} GetInfoLogin
Recupera informações de usuário e filiais com permissão de acesso

@author	Maria Elisandra de Paula
@since 13/12/2018
@param oWs, objeto, instancia do web service
@return array, [1] se obteve sucesso, [2] filiais do usuário, [3] infos de usuário
/*/
//---------------------------------------------------------------------
Static Function GetInfoLogin( oWs )

	Local nIndex    := 0
	Local aInfoUser := {}
	Local aBranches := {}
	Local aLoadSM0  := {}
	Local aUser     := isUser()
	Local aValid    := {}
	Local aIgnore   := fIgnoreEnt(oWs)
	Local cEnterp   := ''
	Local cBranch   := ''

	If !aUser[1]
		Return { .F., aUser[2] }
	Else
		aInfoUser := aUser[2]
	EndIf

	//Carrega as filiais do usuário respeitando as restrições de acesso
	aBranches := BranchUser( aInfoUser )

	If Empty( aBranches )
		Return { .F., STR0071 } //"Usuário sem permissão de acesso às empresas/filiais no ERP Protheus."
	EndIf

	If aScan( aBranches, '@@@@' ) > 0 // @@@@ significa acesso a todas as filiais

		// Se tiver acesso a todas as empresas/filiais, percorre toda a SM0
		If ValType( aLoadSM0 := FWLoadSM0( .T. ) ) <> "A" .Or. Empty(aLoadSM0)
			Return { .F., STR0072 } //"Não foi possível carregar as empresas/filiais."
		Endif

		aBranches := {}
		For nIndex := 1 To Len( aLoadSM0 )
			aAdd( aBranches, aLoadSM0[ nIndex, 1 ] + aLoadSM0[ nIndex, 2 ] )
		Next nIndex
	
	EndIf

	//Ordena as filiais
	Asort( aBranches )

	For nIndex := 1 To Len( aBranches )

		cEnterp := Substr( aBranches[nIndex], 1, 2 )
		cBranch := Substr( aBranches[nIndex], 3 )

		If Ascan(aIgnore, cEnterp) == 0 .And. ; // descarta filiais do ponto de entrada reject group
			FWFilExist( cEnterp, cBranch  ) .And. ; // verifica se filial existe pois aBranches pode trazer filiais deletadas
			AScan( aValid, aBranches[ nIndex ] ) == 0 //Para não repetir filiais no array (pode ter filiais deletadas com mesmo ID)
			
			aAdd( aValid, aBranches[ nIndex ] )
		
		EndIf

	Next nIndex

Return { .T., aValid, aInfoUser }

//-------------------------------------------------------------------------
/*/{Protheus.doc} BranchUser
Recupera as filiais do usuário considerando o grupo e permissões de acesso

@param aInfoUser, array, informações do usuário
@author Maria Elisandra de Paula
@since 24/09/2019
@version P12
@return array, código das filiais
/*/
//-------------------------------------------------------------------------
Static Function BranchUser( aInfoUser )

	Local aAuxiliar := {}
	Local aReturn   := {}
	Local aGroups   := {}
	Local aBrUser   := {}
	Local aBrGroup  := {}
	Local cGrpRule  := ''
	Local lUser19   := .F.
	Local l156      := .F.
	Local nIndex    := 0
	Local nGroup    := 0

	//--------------------------------------------------
	// cGrpRule - indica a regra de acesso por grupo
	// 1-Usuário prioriza regras do grupo
	// 2-Usuário desconsidera regras do grupo
	// 3-Usuário soma regras do grupo
	//--------------------------------------------------
	cGrpRule  := FWUsrGrpRule( aInfoUser[ 1, 1 ] )

	If cGrpRule $ "2/3"

		lUser19 := fCheckMod( aInfoUser[3] ) //Indica se usuário possui acesso ao SIGAMNT ou SIGAGFR

		//Quando o usuário não possui acesso ao módulo
		If !lUser19 .And. cGrpRule == "2"
			Return aReturn
		EndIf

		aBrUser := aInfoUser[ 2, 6 ] //recupera as filiais do usuário

		If cGrpRule == "2"
			aReturn := aClone( aBrUser )//desconsidera as filiais do grupo
		EndIf

	EndIf

	If cGrpRule $ "1/3"

		//recupera os grupos do usuário - o primeiro grupo tem prioridade
		aGroups := GroupUser( aInfoUser[1][1] )

		If Ascan( aGroups, { |x| x[2] } ) == 0 // nenhum grupo tem acesso ao 19 ou 95

			If cGrpRule == "1" //Prioriza
				Return aReturn
			EndIf

			//Não tem permissão ao 19 ou 95 nas configs de grupo e nem nas configurações de usuário
			If cGrpRule == "3" .And. !lUser19 //soma
				Return aReturn
			EndIf

		EndIf

		//Trecho abaixo busca as filiais dos grupos considerando as permissões de acesso
		For nGroup := 1 to Len( aGroups )

			cGroup := aGroups[ nGroup, 1 ]

			//o primeiro grupo sempre tem prioridade em relação aos acessos
			//FWGrpAcess - retorna strings de 'S' e 'N' dos acessos configurados no SIGACFG/Acessos
			If nGroup == 1 .And. Substr( FWGrpAcess( cGroup ), 156, 1 ) == 'S'
				l156 := .T. // será possível acessar apenas os módulos que estiverem em cada grupo
			EndIf

			If l156 .And. !aGroups[ nGroup, 2 ] // Verifica se o grupo tem acesso ao 19 ou 95
				Loop
			EndIf

			aAuxiliar := FWGrpEmp( cGroup )//Recupera as filiais do grupo

			//Tratamento para não repetir as filiais
			For nIndex := 1 To Len( aAuxiliar )
				If aScan( aBrGroup, Alltrim( aAuxiliar[ nIndex ] ) ) == 0
					aAdd( aBrGroup, Alltrim( aAuxiliar[ nIndex ] ) )
				EndIf
			Next nIndex

		Next nGroup

		aReturn := aClone( aBrGroup )//Considera as filiais do usuário

		If cGrpRule == "3" .And. !( l156 .And. !lUser19 )
			//Soma as filiais do usuario com as filiais do grupo
			For nIndex := 1 to Len( aBrUser )
				//Tratamento para não repetir as filiais
				If aScan( aReturn, Alltrim( aBrUser[ nIndex ] ) ) == 0
					aAdd( aReturn, Alltrim( aBrUser[ nIndex ] ) )
				EndIf

			Next nIndex

		EndIf
	EndIf

Return aReturn

//---------------------------------------------------------------------
/*/{Protheus.doc} GroupUser
Retorna os grupos do usuário e se tem acesso ao sigamnt

@param cUserChk, string, código do usuário
@author Maria Elisandra de Paula
@since 24/09/2019
@version P12
@return array, { [1]código do grupo, [2]se possui acesso ao 19 ou 95 }
/*/
//---------------------------------------------------------------------
Static Function GroupUser( cUserChk )

	Local nIndex   := 0
	Local aReturn  := {}
	Local aGroups  := FWSFUsrGrps( cUserChk ) //recupera os grupos do usuário - o primeiro grupo tem prioridade

	For nIndex := 1 to Len( aGroups )

		//FwGrpMenu - recupera os módulos do grupo
		aAdd( aReturn, { aGroups[ nIndex ], fCheckMod( FwGrpMenu( aGroups[ nIndex ] ) ) } )

	Next nIndex

Return aReturn

//---------------------------------------------------------------------
/*/{Protheus.doc} fCheckMod
Indica se possui acesso ao sigamnt

@param aModulos, array, módulos configurados no sigacfg
@author Maria Elisandra de Paula
@since 24/09/2019
@version P12
@return boolean, se possui acesso ao modulo 19 ou 95
/*/
//---------------------------------------------------------------------
Static Function fCheckMod( aModulos )

	Local nPosMNT := Ascan( aModulos,{ | x | Left( x, 2 ) == '19' } ) // recupera a posição do módulo 19 - SIGAMNT
	Local nPosGFR := 0
	Local lChkMod := .F.

	If nPosMNT > 0
		lChkMod := SubStr( aModulos[ nPosMNT ], 3, 1 ) != 'X' // verifica se 19 está marcado ( 'X' é desmarcado )
	EndIf

	// Caso não possua acesso ao módulo SIGAMNT, verifica se existe o módulo 95 no ambiente
	If !lChkMod .And. ( nPosGFR := Ascan( aModulos,{ | x | Left( x, 2 ) == '95' } ) ) > 0 // recupera a posição do módulo 95 - SIGAGFR
		lChkMod := SubStr( aModulos[ nPosGFR ], 3, 1 ) != 'X' // verifica se 95 está marcado ( 'X' é desmarcado )
	EndIf

Return lChkMod

//---------------------------------------------------------------------
/*/{Protheus.doc} CheckEnvironment
Recupera informações do ambiente para utilização do MntNg

@author	Maria Elisandra de Paula
@since 14/12/2018
@param oWs, objeto, objeto rest
@return logic, indica se obteve sucesso
/*/
//---------------------------------------------------------------------
Static Function CheckEnvironment( oWs )

	Local aBranches   := {}
	Local aInfoLogin
	Local aEnterprise := {}
	Local nBranch     := 0
	Local cResponse   := ""
	Local cJsonResp   := ""

	//--------------------------------
	//Recupera informações do usuário
	//--------------------------------
	aInfoLogin := GetInfoLogin( oWs )
	If !aInfoLogin[1]
		Printf( aInfoLogin[2] )
		SetRestFault( 403, EncodeUtf8(aInfoLogin[2] ) )
		Return .F.
	Else
		aBranches := aInfoLogin[2]
	EndIf

	//------------------------------------------
	//carrega array aEnterprise:
	// [1] - enterprise
	// [2] - array de branches
	//------------------------------------------
	For nBranch := 1 to Len(aBranches)
		nScan := aScan( aEnterprise, {|x| x[1] == SubStr( aBranches[nBranch], 1, 2 ) } )

		If nScan > 0
			Aadd( aEnterprise[nScan,2], SubStr( aBranches[nBranch], 3 ) )
		Else
			aAdd( aEnterprise, { SubStr( aBranches[nBranch], 1, 2 ), { SubStr( aBranches[nBranch], 3, FWSizeFilial( SubStr( aBranches[nBranch], 1, 2 ) ) ) } } )
		EndIf
	Next nBranch

	cJsonResp := StartJob( 'MNTNGCHECK', GetEnvserver(), .T., aEnterprise, ;
							{ lPortalOrigin, lDBOrderOk, lDBRequestOk, aPermissions } )

	cResponse := '{"enterprises":'+ cJsonResp + '}'

	oWs:SetStatus( 200 )
	oWs:SetResponse( FwhttpEncode(cResponse) )

	Printf( 'Check realizado' )

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTNGCHECK
Job que retorna filiais do usuário

@author	Maria Elisandra de Paula
@since 18/04/2022

@param aEnterprise, array, filiais para validação
@param aMainStatics, array, variáveis static
@return string, json de filiais
/*/
//---------------------------------------------------------------------
Function MNTNGCHECK( aEnterprise, aMainStatics )

	Local cJsonResp := ""

	lPortalOrigin      := aMainStatics[1]
	lDBOrderOk         := aMainStatics[2]
	lDBRequestOk       := aMainStatics[3]
	aPermissions       := aMainStatics[4]

	cJsonResp := fGetEnvEnt( aEnterprise )

Return cJsonResp

//---------------------------------------------------------------------
/*/{Protheus.doc} fGetEnvEnt
Validação de filiais do usuário

@author	Maria Elisandra de Paula
@since 18/04/2022

@param aEnterprise, array, filiais para validação
@return string, json de filiais
/*/
//---------------------------------------------------------------------
Static Function fGetEnvEnt( aEnterprise )

	Local oResponse
	Local aAuxiliar   := {}
	Local aResponse   := {}
	Local cEnterprise := ""
	Local nEnterprise := 0
	Local nBranch     := 0

	For nEnterprise := 1 to Len(aEnterprise)

		cEnterprise := aEnterprise[nEnterprise,1]
		aAuxiliar   := aEnterprise[nEnterprise,2]
		aBranches   := {}

		nBranch := 1

		// Abre Empresa/Filial
		If !ConfigEnv2( cEnterprise, aAuxiliar[nBranch] )
			Printf( "Configuracao do ambiente nao realizada para " + cEnterprise + aAuxiliar[nBranch] )
			loop
		EndIf

		oResponse := JsonObject():New()
		oResponse[ "code" ] := cEnterprise
		oResponse[ "name" ] := Alltrim( FWGrpName( cEnterprise ) )
		oResponse[ "requestDatabase" ] := lDBRequestOk
		oResponse[ "orderDatabase" ] := lDBOrderOk

		Aadd( aResponse, oResponse )

		fLogTab() // tabelas sem campos de usuário

	Next nEnterprise

Return FWJsonSerialize( aResponse, .F. )

//---------------------------------------------------------------------
/*/{Protheus.doc} fCheckBase
Verifica se o ambiente possui todos os campos necessários para o MNTNG

@author	Maria Elisandra de Paula
@since 18/12/2018
@param cCheck, string, indica qual verificação: 'order' or 'request' or all
@param lItemized, boolean, se deve retornar todas as tabelas inconsistentes
@return array, lista de tabelas inconsistentes
/*/
//---------------------------------------------------------------------
Static Function fCheckBase( cCheck, lItemized )

	Local aFieldName := {}
	Local nAlias     := 0
	Local aAlias     := {}
	Local aOrder     := { "A2","B1","B2","H4","T0","T1","T5","T6","TF","TG","TH","TP7","TPA","TPC","TPQ","TT9"}
	Local aRequest   := { "TQB", "TQ3", "TQ4", "HB" }
	Local aErrorList := {}
	Local cTable     := ""

	Default lItemized := .F.

	// Se utilizará ocorrencias
	// Obs: As requisições vindas do portal mobile não trafegam as permissões do usuário
	If cCheck != "request" .And. ( lPortalOrigin .Or. fHasPerms('occurrences') )
		aAdd( aOrder, 'T8' )
		aAdd( aOrder, 'TUS' )
		aAdd( aOrder, 'TQ5' )
	EndIf

	If cCheck == "order"

		aAlias := aClone( aOrder ) // Campos para ordem de serviço

	ElseIf cCheck == "request"

		aAlias := aClone( aRequest ) // Campos para solicitação de serviço

	ElseIf cCheck == "all"

		aAlias := aClone( aOrder )

		For nAlias := 1 to Len( aRequest )
			aAdd( aAlias, aRequest[ nAlias ] )
		Next nAlias

	EndIf

	//---------------------------------------------
	// Campos necessários para ordem e solicitação
	//---------------------------------------------
	aAdd( aAlias, "T9"  )
	aAdd( aAlias, "CTT" )
	aAdd( aAlias, "T4"  )
	aAdd( aAlias, "TD"  )
	aAdd( aAlias, "TJ"  )

	// Se utilizará localizações em O.S. ou S.S.
	// Obs: As requisições vindas do portal mobile não trafegam as permissões do usuário
	If lPortalOrigin .Or. fHasPerms('location-order') .Or. fHasPerms('location-ss')
		aAdd( aAlias, "TAF" )
	EndIf

	For nAlias := 1 To Len( aAlias )

		cTable := aAlias[nAlias]

		If Len( aAlias[nAlias] ) == 3
			aFieldName := { "_USERGI","_USERGA" }
		Else
			aFieldName := { "_USERLGI","_USERLGA" }
			cTable := "S" + cTable
		EndIf

		//----------------------------------------
		// Verifica a existência dos campos
		//----------------------------------------
		dbSelectArea( cTable )
		If FieldPos( aAlias[nAlias] + aFieldName[1] ) == 0 .Or. ;
			FieldPos( aAlias[nAlias] + aFieldName[2] ) == 0

			aAdd( aErrorList, cTable )

			If !lItemized
				Exit
			EndIf

		EndIf
	Next nI

	aSort( aErrorList )

Return aErrorList

//---------------------------------------------------------------------
/*/{Protheus.doc} StartStatics
Inicializa variáveis statics

@param oWs, objeto, web service
@param lSyncVars, boolean, se deve carregar as variáveis de sincronismo

@author	Maria Elisandra de Paula
@since 28/01/2019
@return nil
/*/
//---------------------------------------------------------------------
Static Function StartStatics( oWs, lSyncVars )

	Default lSyncVars := .F.

	cUserLog  := RetCodUsr()
	cUserName := UsrRetName( cUserLog )
	aInputs   := { { {}, {}, {} }, { {}, {}, {} } }
	cUserST1  := ""
	cUserTQ4  := ""

	lPortalOrigin      := ValType( oWS:GetHeader( 'source' ) ) == "C"  .And. oWS:GetHeader( 'source' ) == "portal"
	lOrderPermission   := .F.
	lRequestPermission := .F.
	lDBOrderOk         := .F.
	lDBRequestOk       := .F.
	
	lMigrated := ValType( oWS:GetHeader( 'usePortalToLogin' ) ) == 'C' .And. oWS:GetHeader( 'usePortalToLogin' ) == 'false' .And. ChkFile('HP3')

	If !lPortalOrigin
		fLoadPerms( oWS )
	EndIf

	If lSyncVars
		lDBOrderOk := Len( fCheckBase( "order" ) ) == 0
		lDBRequestOk := Len( fCheckBase( "request" ) ) == 0
		GetUserCfg() // Vínculo UserProtheus x ST1 x TQ4 (executante de solicitações)
	EndIf

Return
//---------------------------------------------------------------------
/*/{Protheus.doc} fLoadPerms
Carrega o array aPermissions com permissões do grupo do usuário

@param oWs, objeto, web service
@author	Maria Elisandra de Paula
@since 28/01/2019
@return nil
/*/
//---------------------------------------------------------------------
Static Function fLoadPerms( oWS )

	Local nIndex
	Local aOrder := {'create-order-corr',;
					'create-order-prev',;
					'edit-order-corr',;
					'edit-order-prev',;
					'cancel-order',;
					'finish-order'}

	Local aRequest := {'create-ss',;
					'edit-service-request',;
					'distribute-ss',;
					'finish-ss'}

	Local aAll := fRetPermis()

	//---------------------------------------------------------
	// Carrega aPermissions conforme configuração do usuário
	//---------------------------------------------------------
	If !lMigrated
		aPermissions := fGetPerm2( oWs, aAll )
	Else
		cUserGrp := fGrpUser()
		aPermissions := fGetPermis()
	EndIf

	//-----------------------------------------------
	// Verifica se usuário possui permissões para OS
	//-----------------------------------------------
	For nIndex := 1 to Len( aOrder )
		lOrderPermission := AScan( aPermissions, aOrder[nIndex] ) > 0
		If lOrderPermission 
			Exit
		EndIf
	Next nIndex

	//-----------------------------------------------
	// Verifica se usuário possui permissões para SS
	//-----------------------------------------------
	For nIndex := 1 to Len( aRequest )
		lRequestPermission := AScan( aPermissions, aRequest[nIndex] ) > 0
		If lRequestPermission
			Exit
		EndIf
	Next nIndex

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} RequestIsOk
Validações para solicitações de serviço

@author	Maria Elisandra de Paula
@since 04/02/2019
@return logic, se possui configurações para ss no MNT NG
/*/
//---------------------------------------------------------------------
Static Function RequestIsOk( )

Return lDBRequestOk .And. ; //Campos de usuário estão configurados
	!( SuperGetMv( 'MV_NG1FAC', .F., '2') == '1' ) //Não é ambiente com facilities

//---------------------------------------------------------------------
/*/{Protheus.doc} ValidSync
Validações para sincronismo

@author	Maria Elisandra de Paula
@since 04/02/2019
@return string, descrição do erro
/*/
//---------------------------------------------------------------------
Static Function ValidSync( )

	Local cError := ""

	If !lRequestPermission .And. !lOrderPermission
		If lMigrated
			cError := "As permissões do grupo de usuário não estão definidas. (Defini-las em MNTA916)"
		Else
			cError := STR0150 //"As permissões do grupo de usuário não estão definidas no portal mobile."
		EndIf
	Else
		//----------------------------------
		//pelo menos uma das opções está ok
		//----------------------------------
		If ( lOrderPermission .And. lDBOrderOk ) .Or. ( lRequestPermission .And. RequestIsOk() )
			cError := ""
		Else

			//-------------------------------------------------
			// trecho abaixo trata a mensagem para o usuário
			//-------------------------------------------------
			If lOrderPermission .And. !lDBOrderOk
				cError += STR0151 + ": " + CRLF + STR0152 + CRLF + CRLF //"Para ordens de serviço"# //"Configurar os campos de usuário"
			EndIf

			If lRequestPermission .And. !RequestIsOk( )
				cError += STR0153 + ":" + CRLF //"Para solicitações de serviço
				cError += ErrorForRequest( )

			EndIf

			cError := STR0154  + CRLF + CRLF + cError //"O ambiente não está devidamente configurado"
		EndIf
	EndIf

Return cError

//---------------------------------------------------------------------
/*/{Protheus.doc} ErrorForRequest
Retorna erro para operações de solicitações

@author	Maria Elisandra de Paula
@since 04/02/2019
@return string, descrição do erro
/*/
//---------------------------------------------------------------------
Static Function ErrorForRequest( )

	Local cError := ""

	If !lDBRequestOk
		cError += STR0152 + CRLF //"Configurar os campos de usuário"
	EndIf

	If SuperGetMv( 'MV_NG1FAC', .F., '2') == '1'
		cError += STR0156 + CRLF //"Ajustar parâmetro 'MV_NG1FAC' para '2'"
	EndIf

Return cError

//---------------------------------------------------------------------------
/*/{Protheus.doc} ConfigEnv2
Realiza configurações para empresa/filial e/ou usuário sem utilizar licença
@type function

@author	Maria Elisandra de Paula
@since 08/02/2019

@param  cEnterprise  , String, Código da empresa
@param  cBranch      , String, Código da filial
@param  cUserProtheus, String, Código do usuário para login protheus
@return Boolean      , Se houve a abertura da empresa/filial

@obs quando a empresa e filial não são definidas o usuário é obrigatórios,
nos casos onde o usuário não é definidos a empresa e filial são obrigatórios
/*/
//---------------------------------------------------------------------------
Static Function ConfigEnv2( cEnterprise, cBranch, cUserProtheus )

	Local cUser := cUserProtheus
	Local lRet := .T.

	//---------------------------------------------------------------------------------------------
	// Tratativa realizada para evitar uma falha crítica (error log - SX20 não existe)
	// ao executar o RPCSETENV passando o usuario de Administrador como parametro.
	// Por algum motivo nenhuma empresa/filial é encontrada para realizar a abertura do dicionario
	//---------------------------------------------------------------------------------------------
	If ValType( cUserProtheus ) == "C" .And. cUserProtheus == "Administrador"
		cUser := "Adm"
	EndIf

	Printf( 'Acesso a empresa/filial ' + cEnterprise + cBranch  )

	// Caso a empresa não tenha sido aberta ou for diferente da empresa a ser verificada
	// Limpa o ambiente, liberando a licença e fechando as conexões e abre um ambiente com a nova empresa
	If Type( 'cEmpAnt' ) == 'U' .Or. cEmpAnt != cEnterprise

		RpcClearEnv()
		RpcSetType( 3 ) // Sem utilizar licença
		If !Empty( cEnterprise ) .And. !Empty( cBranch )

			/*
				Realiza a abertura da empresa conforme enviado no parâmetro, para as chamadas onde já se tem o conhecimento
				da empresa e filial que serão utilizadas.
			*/
			lRet := RpcSetEnv( cEnterprise, cBranch, , , 'MNT', 'MNTNG' )

		Else

			/*
				A função abaixo não abre o ambiente, porém é necessário utilizá-la para que as filiais retornadas em FWLoadSM0
				sejam apenas as válidas para o usuário. Não sendo necessário passar o senha, pois o memso já encontra-se autenticado.
			*/
			lRet := RpcSetEnv( '', '', cUser, '', 'MNT', 'MNTNG' )

		EndIf

	ElseIf cFilAnt != cBranch
		// Caso empresa já esteja aberta, altera somente a filial.
		cFilAnt := cBranch
	EndIf

	If lRet
		lDBOrderOk   := Len( fCheckBase( "order" ) ) == 0
		lDBRequestOk := Len( fCheckBase( "request" ) ) == 0
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} WfFinish
Envio de WF de encerramento de OS quando está vinculada a uma SS

@author	Maria Elisandra de Paula
@since 01/08/2019
@param cOrderCode, string, Código da ordem de serviço finalizada
/*/
//---------------------------------------------------------------------
Static Function WfFinish( cOrderCode )

	If AllTrim( SuperGetMV( 'MV_NGSSWRK', .F., 'N' ) ) == 'S'

		dbSelectArea('STJ')
		dbSetOrder(1)
		dbSeek( FwxFilial('STJ') + cOrderCode )

		If AllTrim( SuperGetMV( 'MV_NGMULOS', .F., 'N' ) ) == 'S'
			dbSelectArea('TT7')
			dbSetOrder(2)
			If dbSeek( FwxFilial('TT7') + cOrderCode )
				dbSelectArea('TQB')
				dbSetOrder(1)
				If dbSeek( FwxFilial('TQB') + TT7->TT7_SOLICI )
					Printf( 'Enviando wf para solicitante - ' + TQB->TQB_CDSOLI )
					MNW29502( TQB->TQB_CDSOLI )
				EndIf
			EndIf
		Else
			dbSelectArea('TQB')
			dbSetOrder(4)
			If dbSeek( FwxFilial('TQB') + cOrderCode )
				Printf( 'Enviando wf para solicitante - ' + TQB->TQB_CDSOLI )
				MNW29502( TQB->TQB_CDSOLI )
			EndIf
		EndIf
	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fDateValid
Valida data e hora da finalização

@author	Maria Elisandra de Paula
@since 03/10/2019
@param dDtMRIni, date, data real inicio
@param cHoMRIni, string, hora real inicio
@param dDtMRFim, date, data real fim
@param cHoMRFim, string, hora real fim
@return string, vazio ou descrição do erro
/*/
//---------------------------------------------------------------------
Static Function fDateValid( dDtMRIni, cHoMRIni, dDtMRFim, cHoMRFim )

	Local cError   := ""
	Local aDtHor   := Time2NextDay(IncTime( time(), 0, 5, 0), date())  //incrementa 5 minutos - tolerância
	Local cHrMais5 := DtoS( aDtHor[2] ) + aDtHor[1]

	//Valida data inicial com data final
	If Dtos( dDtMRIni ) + cHoMRIni > Dtos( dDtMRFim ) + cHoMRFim
		cError := STR0158 //"A data e hora fim da manutenção não pode ser maior que a data e hora inicial."
	EndIf

	//Valida data e/ou hora posterior ( soemnte por garantia pois o app já trata essas validações )
	If Empty( cError ) .And. ( Dtos( dDtMRIni ) + cHoMRIni ) > cHrMais5 .Or. ( Dtos( dDtMRFim ) + cHoMRFim ) > cHrMais5
		cError := STR0159 // "A data e hora real fim da manutenção não pode ser maior que a data e hora atual."
	EndIf

Return cError

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} GetUserCfg
Carrega variáveis vinculadas ao usuário

@author	Alexandre Santos
@since 04/03/2020
@return Nil
/*/
//---------------------------------------------------------------------------------------
Static Function GetUserCfg()

	Local cMail     := Trim( UsrRetMail( cUserLog ) )
	Local cAliasST1 := GetNextAlias()
	Local cAliasTQ4 := GetNextAlias()

	// Busca vínculo com funcionário da manutenção - ST1
	BeginSql Alias cAliasST1

		SELECT
			ST1.T1_CODFUNC
		FROM
			%table:ST1% ST1
		WHERE
			UPPER( ST1.T1_EMAIL ) = %exp:Upper( cMail )% AND
			ST1.T1_FILIAL = %xFilial:ST1% AND
			ST1.%NotDel%

	EndSql

	cUserST1 := IIf( ( cAliasST1 )->( !EoF() ), AllTrim( (cAliasST1)->T1_CODFUNC ), '' )

	(cAliasST1)->(dbCloseArea())

	// Busca vínculo com executante de solicitações - TP4
	BeginSql Alias cAliasTQ4

		SELECT
			TQ4.TQ4_CDEXEC
		FROM
			%table:TQ4% TQ4
		WHERE
			UPPER( TQ4.TQ4_EMAIL1 ) = %exp:Upper( cMail )% AND
			TQ4.TQ4_FILIAL = %xFilial:TQ4% AND
			TQ4.%NotDel%

	EndSql

	cUserTQ4 := IIf( (cAliasTQ4)->( !EoF() ), AllTrim( (cAliasTQ4)->TQ4_CDEXEC ), '' )

	(cAliasTQ4)->(dbCloseArea())

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fVersion
Verifica se versão é compatível com outra (por ex.: versão mínima)

@obs [1] Major
	[2] Minor
	[3] Patch
@author	Maria Elisandra de Paula
@since 13/04/2020
@param cVersion, string, version do app
@param [cCompare], string, versão para comparação
@return boolean, se está atualizado
/*/
//---------------------------------------------------------------------
Static Function fVersion( cVersion, cCompare )

	Local aVersionApp := StrTokArr( cVersion, "." )
	Local aVersionMin := {}

	Default cCompare := MINVERSIONAPP

	aVersionMin := StrTokArr( cCompare, "." ) // versão mínima exigida

	// Major do app é superior ao exigido
	If Val(aVersionApp[1]) > Val(aVersionMin[1])
		Return .T.
	EndIf

	// Major do app é a mesma da versão exigida
	If Val(aVersionApp[1]) == Val(aVersionMin[1])

		// Minor do app é superior ao exigido
		If Val(aVersionApp[2]) > Val(aVersionMin[2])
			Return .T.
		EndIf

		// Minor do app é igual ao exigido e patch é igual ou superior
		If Val(aVersionApp[2]) == Val(aVersionMin[2]) .And.;
			Val(aVersionApp[3]) >= Val(aVersionMin[3])
			Return .T.
		EndIf
	EndIf

Return .F.

//----------------------------------------------------------------------------------
/*/{Protheus.doc} QOccurrences
Query para Ocorrências.
@type function

@autor Alexandre Santos
@since 21/07/2020

@param cDate  , Caracter, Data da última sincronização.
@param cAlsST8, Caracter, Tabela utilizada para montagem do arquivo JSON.
@return
/*/
//----------------------------------------------------------------------------------
Static Function QOccurrences( cDate, cAlsST8 )

	Local cWhere  := "%ST8.D_E_L_E_T_ = ' '%"
	Local cField  := "%,'FALSE' AS BLOCKED%"
	Local lBlock  := NGCADICBASE( 'T8_MSBLQL', 'A', 'ST4', .F. )

	If cDate != '0'
		cWhere := '%('  + dateQuery( 'T8_USERLGA' ) + ' >= ' + ValToSQL( cDate ) + ' OR '
		cWhere +=         dateQuery( 'T8_USERLGI' ) + ' >= ' + ValToSQL( cDate ) + ' )%'
	EndIf

	If lBlock
		cField := "%,CASE "
		cField += 	" WHEN ST8.T8_MSBLQL = '1' THEN 'TRUE' "
		cField +=	" ELSE 'FALSE' END AS BLOCKED%"
	EndIf

	BeginSQL Alias cAlsST8

		SELECT
			ST8.T8_CODOCOR,
			ST8.T8_NOME   ,
			ST8.T8_TIPO   ,
			CASE
				WHEN ST8.D_E_L_E_T_ = ' ' THEN ''
				ELSE 'TRUE' END AS IS_DELETED
			%exp:cField%
		FROM
			%table:ST8% ST8
		WHERE
			ST8.T8_FILIAL = %xFilial:ST8% AND
			%exp:cWhere%

	EndSQL

Return

//-----------------------------------------------------------------------------------------
/*/{Protheus.doc} sOccurrences
Gera um JSON contendo as informações de Ocorrências dos tipos Problema, Causa e Solução para
a sincronização com o aplicativo Mobile.
@type function

@author	Alexandre Santos
@since 21/07/2020

@param oWS   , Objeto  , Referência ao webservice.
@param cDate , Caracter, Data da última sincronização.
@return Array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//-----------------------------------------------------------------------------------------
Static Function sOccurrences( oWs, cDate )

	Local cDelete   := ''
	Local cHrIn     := Time()
	Local cSubJSON  := ''
	Local cAlsST8   := GetNextAlias()
	Local nCount    := 0
	Local lFirstST8 := .T.
	Local lFirstD   := .T.
	Local nDelete   := 0
	Local nUpdate   := 0
	Local aFileName := {}
	Local cEntity   := 'occurrences'
	Local aInit     := fInitWrite(oWs, cEntity)
	
	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf

	// Seleciona ocorrências dos tipos PROBLEMA, CAUSA e SOLUÇÃO.
	QOccurrences( cDate, @cAlsST8 )

	Do While (cAlsST8)->( !EoF() )

		// INCLUIR e ALTERAR
		If fCondDel(cAlsST8)

			cSubJSON    := ','

			If lFirstST8
				lFirstST8 := .F.
				cSubJSON  := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"' + NGEscape( (cAlsST8)->T8_CODOCOR ) + '",'
			cSubJSON += '"name":"' + NGEscape( (cAlsST8)->T8_NOME ) + '",'
			cSubJSON += '"type":"' + NGEscape( (cAlsST8)->T8_TIPO ) + '"'

			If Upper( (cAlsST8)->BLOCKED ) != 'FALSE'
				cSubJSON += ',"blocked":true'
			EndIf

			cSubJSON += '}'

			fWriteJson(cSubJSON, nUpdate, oWs)

		// EXCLUIR
		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + NGEscape( (cAlsST8)->T8_CODOCOR ) + '"'

		EndIf

		nCount++

		(cAlsST8)->( dbSkip() )

	EndDo

	(cAlsST8)->( dbCloseArea() )

	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//----------------------------------------------------------------------------------
/*/{Protheus.doc} QExceptionFamily
Query para Excessões de Família para Ocorrências.
@type function

@autor Alexandre Santos
@since 21/07/2020

@param cDate  , Caracter, Data da última sincronização.
@param cAlsTUS, Caracter, Tabela utilizada para montagem do arquivo JSON.
@return
/*/
//----------------------------------------------------------------------------------
Static Function QExceptionFamily( cDate, cAlsTUS )

	Local cWhere  := "%TUS.D_E_L_E_T_ = ' '%"

	If cDate != '0'
		cWhere := '%('  + dateQuery( 'TUS_USERGA' ) + ' >= ' + ValToSQL( cDate ) + ' OR '
		cWhere +=         dateQuery( 'TUS_USERGI' ) + ' >= ' + ValToSQL( cDate ) + ' )%'
	EndIf

	BeginSQL Alias cAlsTUS

		SELECT
			TUS.TUS_CODOCO,
			TUS.TUS_FAMILI,
			CASE
				WHEN TUS.D_E_L_E_T_ = ' ' THEN ''
				ELSE 'TRUE' END AS IS_DELETED
		FROM
			%table:TUS% TUS
		WHERE
			TUS.TUS_FILIAL = %xFilial:TUS% AND
			%exp:cWhere%

	EndSQL

Return

//----------------------------------------------------------------------------------
/*/{Protheus.doc} sExceptionFamily
Gera um JSON contendo as informações de Excessões de Família para a sincronização
com o aplicativo Mobile.
@type function

@author	Alexandre Santos
@since 21/07/2020

@param oWS   , Objeto  , Referência ao webservice.
@param cDate , Caracter, Data da última sincronização.
@return Array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//----------------------------------------------------------------------------------
Static Function sExceptionFamily( oWs, cDate )

	Local cDelete   := ''
	Local cHrIn     := Time()
	Local cSubJSON  := ''
	Local cAlsTUS   := GetNextAlias()
	Local nCount    := 0
	Local lFirstTUS := .T.
	Local lFirstD   := .T.
	Local nDelete   := 0
	Local nUpdate   := 0
	Local aFileName := {}
	Local cEntity   := 'exceptionfamily'
	Local aInit     := fInitWrite(oWs, cEntity)
	
	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf

	// Seleciona Excessões de Família para Ocorrências.
	QExceptionFamily( cDate, @cAlsTUS )

	Do While (cAlsTUS)->( !EoF() )

		// INCLUIR e ALTERAR
		If fCondDel(cAlsTUS)

			cSubJSON := ','

			If lFirstTUS
				lFirstTUS := .F.
				cSubJSON  := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"occurrence":"' + NGEscape( (cAlsTUS)->TUS_CODOCO ) + '",'
			cSubJSON += '"family":"'     + NGEscape( (cAlsTUS)->TUS_FAMILI ) + '"'
			cSubJSON += '}'

			fWriteJson(cSubJSON, nUpdate, oWs)

		// EXCLUIR
		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + NGEscape( (cAlsTUS)->TUS_CODOCO ) + NGEscape( (cAlsTUS)->TUS_FAMILI ) + '"'

		EndIf

		nCount++

		(cAlsTUS)->( dbSkip() )

	EndDo

	(cAlsTUS)->( dbCloseArea() )

	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//----------------------------------------------------------------------------------
/*/{Protheus.doc} QAssociated
Query para Associação entre Ocorrências.
@type function

@autor Alexandre Santos
@since 21/07/2020

@param cDate  , Caracter, Data da última sincronização.
@param cAlsTQ5, Caracter, Tabela utilizada para montagem do arquivo JSON.
@return
/*/
//----------------------------------------------------------------------------------
Static Function QAssociated( cDate, cAlsTQ5 )

	Local cWhere  := "%TQ5.D_E_L_E_T_ = ' '%"

	If cDate != '0'
		cWhere := '%('  + dateQuery( 'TQ5_USERGA' ) + ' >= ' + ValToSQL( cDate ) + ' OR '
		cWhere +=         dateQuery( 'TQ5_USERGI' ) + ' >= ' + ValToSQL( cDate ) + ' )%'
	EndIf

	BeginSQL Alias cAlsTQ5

		SELECT
			TQ5.TQ5_CODOCO,
			TQ5.TQ5_CODOCR,
			CASE
				WHEN TQ5.D_E_L_E_T_ = ' ' THEN ''
				ELSE 'TRUE' END AS IS_DELETED
		FROM
			%table:TQ5% TQ5
		WHERE
			TQ5.TQ5_FILIAL = %xFilial:TQ5% AND
			%exp:cWhere%

	EndSQL

Return

//----------------------------------------------------------------------------------
/*/{Protheus.doc} sAssociated
Gera um JSON contendo as informações de Associação entre Ocorrências para a sincronização
com o aplicativo Mobile.
@type function

@author	Alexandre Santos
@since 21/07/2020

@param oWS   , Objeto  , Referência ao webservice.
@param cDate , Caracter, Data da última sincronização.
@return Array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//----------------------------------------------------------------------------------
Static Function sAssociated( oWs, cDate )

	Local cDelete   := ''
	Local cHrIn     := Time()
	Local cSubJSON  := ''
	Local cAlsTQ5   := GetNextAlias()
	Local nCount    := 0
	Local lFirstTQ5 := .T.
	Local lFirstD   := .T.
	Local nDelete   := 0
	Local nUpdate   := 0
	Local aFileName := {}
	Local cEntity   := 'associated'
	Local aInit     := fInitWrite(oWs, cEntity)
	
	If !aInit[1]
		Return aInit
	Else
		aFileName := aInit[3]
		nDelete   := aInit[4]
		nUpdate   := aInit[5]
	EndIf	

	// Seleciona ASSOCIAÇÃO entre ocorrências
	QAssociated( cDate, @cAlsTQ5 )

	Do While (cAlsTQ5)->( !EoF() )

		// INCLUIR e ALTERAR
		If fCondDel(cAlsTQ5)

			cSubJSON := ','

			If lFirstTQ5
				lFirstTQ5 := .F.
				cSubJSON  := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"occurrence":"' + NGEscape( (cAlsTQ5)->TQ5_CODOCO ) + '",'
			cSubJSON += '"associated":"' + NGEscape( (cAlsTQ5)->TQ5_CODOCR ) + '"'
			cSubJSON += '}'

			fWriteJson(cSubJSON, nUpdate, oWs)

		// EXCLUIR
		Else

			If !lFirstD
				cDelete += ','
			Else
				lFirstD := .F.
			EndIf

			cDelete += '"' + NGEscape( (cAlsTQ5)->TQ5_CODOCO ) + NGEscape( (cAlsTQ5)->TQ5_CODOCR ) + '"'


		EndIf

		nCount++

		(cAlsTQ5)->( dbSkip() )

	EndDo

	(cAlsTQ5)->( dbCloseArea() )

	fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

Return { .T., aFileName }

//----------------------------------------------------------------------------------
/*/{Protheus.doc} InputSTN
Realiza gravação de ocorrências na tabela STN.
@type function

@author	Alexandre Santos
@since 27/07/2020

@param cFilSTN, string, Filial corrente para ocorrências
@param cOrder , string, Ordem de Serviço referente aos insumos.
@param cPlan  , string, Plano de Manutenção referente aos insumos.
@param cTask  , string, Tarefa do insumo relacionado as ocorrencias.
@param cSeque , string, Sequência de inclusão do insumo relacionado as ocorrencias.
@param aOccur , array , Lista com ocorrênciaspara gravação.
						[1] - Problema
						[2] - Causa
						[3] - Solução
						[4] - Observação
@return
/*/
//----------------------------------------------------------------------------------
Static Function InputSTN( cFilSTN, cOrder, cPlan, cTask, cSeque, aOccurrences )

	Local nOcc   := 0

	If !Empty( aOccurrences[_UPDATE_] )

		// Forma de facilitar a codificação e entendimento da matriz.
		aUpdate := aClone( aOccurrences[_UPDATE_] )

		// Gravação das ocorrências na tabela STN.
		For nOcc := 1 To Len( aUpdate )

			dbSelectArea( 'STN' )
			dbSetOrder( 1 ) // TN_FILIAL + TN_ORDEM + TN_PLANO + TN_TAREFA + TN_SEQRELA + TN_CODOCOR + TN_CAUSA + TN_SOLUCAO
			If msSeek( cFilSTN + cOrder + cPlan + cTask + cSeque + aUpdate[nOcc,_PROBLEM_] + aUpdate[nOcc,_KEYCAUSE_] +;
				aUpdate[nOcc,_KEYSOLUTION_] )

				printf( '  - Modificando ocorrencia: ' + Trim( cTask ) + '/' + Trim( cSeque ) )

				RecLock( 'STN', .F. )

					STN->TN_CAUSA   := aUpdate[nOcc,_CAUSE_]
					STN->TN_SOLUCAO := aUpdate[nOcc,_SOLUTION_]
					STN->TN_DESCRIC := aUpdate[nOcc,_OCCURNOTE_]

				STN->( MsUnLock() )

			Else

				// Caso não encontra para alteração, adiciona na lista de inclusão de ocorrências.
				aAdd( aOccurrences[_INSERT_], aUpdate[nOcc] )

			EndIf

		Next nOcc

	EndIf

	If !Empty( aOccurrences[_INSERT_] )

		// Forma de facilitar a codificação e entendimento da matriz.
		aInsert := aClone( aOccurrences[_INSERT_] )

		// Gravação das ocorrências na tabela STN.
		For nOcc := 1 To Len( aInsert )

			printf( '  - Incluindo ocorrencia: ' + Trim( cTask ) + '/' + Trim( cSeque ) + ' ( ' + cValtochar( nOcc ) + ' )' )

			RecLock( 'STN', .T. )

				STN->TN_FILIAL  := cFilSTN
				STN->TN_ORDEM   := cOrder
				STN->TN_PLANO   := cPlan
				STN->TN_TAREFA  := cTask
				STN->TN_SEQRELA := cSeque
				STN->TN_CODOCOR := aInsert[nOcc,_PROBLEM_]
				STN->TN_CAUSA   := aInsert[nOcc,_CAUSE_]
				STN->TN_SOLUCAO := aInsert[nOcc,_SOLUTION_]
				STN->TN_DESCRIC := aInsert[nOcc,_OCCURNOTE_]

			STN->( MsUnLock() )

		Next nOcc

	EndIf

	// Deleção de insumos
	If !Empty( aOccurrences[_DELETE_] )

		// Forma de facilitar a codificação e entendimento da matriz.
		aDelete := aClone( aOccurrences[_DELETE_] )

		For nOcc := 1 To Len( aDelete )

			dbSelectArea( 'STN' )
			dbSetOrder( 1 ) // TN_FILIAL + TN_ORDEM + TN_PLANO + TN_TAREFA + TN_SEQRELA + TN_CODOCOR + TN_CAUSA + TN_SOLUCAO
			If msSeek( cFilSTN + cOrder + cPlan + cTask + cSeque + aDelete[nOcc,_PROBLEM_] + aDelete[nOcc,_KEYCAUSE_] +;
				aDelete[nOcc,_KEYSOLUTION_] )

				printf( '  - Excluindo ocorrencia: ' + Trim( cTask ) + '/' + Trim( cSeque ) )

				RecLock( 'STN', .F. )
				dbDelete()
				STN->( MsUnLock() )

			EndIf

		Next nOcc

	EndIf

Return

//----------------------------------------------------------------------------------
/*/{Protheus.doc} GetOccurrences
Recupera uma lista co mas ocorrências recebidas do app.
@type function

@author	Alexandre Santos
@since 27/07/2020

@param oParser, Object , Objeto JSON contendo a lista de ocorrências enviadas pelo app.
@return Array , Matriz contendo três lista de ocorrências, separadas pelas operações de
inclusão, alteração e exclusão. Cada lista comporta pelas posições:
					[1] - Problema
					[2] - Causa
					[3] - Backup Causa
					[4] - Solução
					[5] - Backup Solução
					[6] - Observação
/*/
//----------------------------------------------------------------------------------
Static Function GetOccurrences( oParser )

	Local nIndex      := 0
	Local aOccurrTemp := {}

	aOccurrences := { {}, {}, {} }

	For nIndex := 1 To Len( oParser )

		aOccurrTemp := Array( 6 )

		// TN_CODOCOR - Problema
		aOccurrTemp[_PROBLEM_] := oParser[nIndex]:problem

		// TN_CAUSA - Causa
		aOccurrTemp[_CAUSE_] := IIf( AttIsMemberOf( oParser[nIndex], 'cause' ), oParser[nIndex]:cause, Space( Len( STN->TN_CAUSA ) ) )

		// Backup TN_CAUSA
		aOccurrTemp[_KEYCAUSE_] := IIf( AttIsMemberOf( oParser[nIndex], 'keyCause' ), oParser[nIndex]:KeyCause, Space( Len( STN->TN_CAUSA ) ) )

		// TN_SOLUCAO - Solução
		aOccurrTemp[_SOLUTION_] := IIf( AttIsMemberOf( oParser[nIndex], 'solution' ), oParser[nIndex]:solution, Space( Len( STN->TN_SOLUCAO ) ) )

		// Backup TN_SOLUCAO
		aOccurrTemp[_KEYSOLUTION_] := IIf( AttIsMemberOf( oParser[nIndex], 'keySolution' ), oParser[nIndex]:KeySolution, Space( Len( STN->TN_SOLUCAO ) ) )

		// Observação
		aOccurrTemp[_OCCURNOTE_] := IIf( AttIsMemberOf( oParser[nIndex], 'note' ), oParser[nIndex]:note, '' )

		// Separa as ocorrências por operação as quais foram acionados.
		Do Case

			// Inclusão
			Case oParser[nIndex]:operation == 'C'

				aAdd( aOccurrences[_INSERT_], aOccurrTemp )

			// Alteração
			Case oParser[nIndex]:operation == 'U'

				aAdd( aOccurrences[_UPDATE_], aOccurrTemp )

			// Exclusão
			Case oParser[nIndex]:operation == 'D'

				aAdd( aOccurrences[_DELETE_], aOccurrTemp )

		EndCase

	Next nIndex

Return aOccurrences

//----------------------------------------------------------------------------------
/*/{Protheus.doc} DeleteRelation
Remove os relacionamento do insumos para efetivar a alteração ou deleção do insumo.
@type function

@author	Alexandre Santos
@since 14/10/2020

@param aTask, array, Lista de insumo em manipulação.
@return
/*/
//----------------------------------------------------------------------------------
Static Function DeleteRelation( aTask )

	Local lIntRM    := Trim( SuperGetMv( 'MV_NGINTER', .F., 'N' ) ) == 'M'
	Local lAglut    := Trim( SuperGetMv( 'MV_NGMNTAS', .F., '2' ) ) == '1'
	Local lUpdSld   := .T.
	Local nSizeISA  := TamSX3( 'TL_ITEMSA' )[1]
	Local nSizeNSA  := TamSX3( 'TL_NUMSA' )[1]

	// Variáveis seguindo o modelo do aHeader da rotina MNTA420.
	Local nPosType  := 2
	Local nPosCode  := 3
	Local nPosAmou  := 7
	Local nPosWare  := 12
	Local nPosRecNo := 14

	Default aTask   := {}

	If STL->TL_TIPOREG $ 'P/T'

		cCodPSC1 := STL->TL_CODIGO
		cCodPTer := ''

		If STL->TL_TIPOREG == 'T'

			// Ira verificar apenas o primeiro Produto Terceiro do parametro
			cCodPTer := IIf( FindFunction( 'NGProdMNT' ), NGProdMNT( 'T' )[1], Trim( GetMV( 'MV_PRODTER' ) ) )
			cCodPSC1 := cCodPTer + Space( Len( SB1->B1_COD ) - Len( cCodPTer ) )

		EndIf

		If STL->TL_TIPOREG == 'P'
			lUpdSld := aScan( aGetIns,{ |x|	Trim( x[nPosType] ) == Trim( STL->TL_TIPOREG ) .And. Trim( x[nPosCode] ) ==;
				Trim( STL->TL_CODIGO ) .And. Trim( x[nPosWare] ) == Trim( STL->TL_LOCAL ) .And. x[13] } ) == 0
		EndIf

		NGDELSC1PR( STJ->TJ_ORDEM, 'OS001', cCodPSC1, IIf( Empty( STL->TL_LOCAL ), NGSEEK( 'SB1', cCodPTer, 1, 'B1_LOCPAD' ), STL->TL_LOCAL ),;
			STL->TL_QUANTID, lUpdSld, lUpdSld, { STL->TL_NUMSC + STL->TL_ITEMSC, 1 }, "SC1->C1_FILIAL == '" + FwxFilial( 'SC1' ) +;
			"' .And. SC1->C1_NUM == '" + STL->TL_NUMSC + "' .And. SC1->C1_ITEM == '" + STL->TL_ITEMSC + "'" )

		RecLock( 'STL', .F. )
			STL->TL_NUMSC  := Space( Len( SC1->C1_NUM ) )
			STL->TL_ITEMSC := Space( Len( SC1->C1_ITEM ) )
		STL->( MsUnLock() )

		GERAOPNEW( cCodPSC1, STL->TL_QUANTID, STJ->TJ_ORDEM, , , , , , , 5 )

	EndIf

	// Deleção de solicitação de armazém
	If NG420CHKSA( STL->TL_TIPOREG )

		dbSelectArea( 'SCP' )
		dbSetOrder( 1 )
		If msSeek( FwxFilial( 'SCP' ) + STL->TL_NUMSA + STL->TL_ITEMSA ) .And. SCP->CP_QUJE <= 0 .And. SCP->CP_PREREQU != 'S' .And.;
			fVldAltSA( STL->( RecNo() ), aGetIns, nPosRecNo, nPosAmou, nPosCode, nPosWare )

			If lIntRM

				// S.A. agluinada
				If lAglut

					If NGMUReques( SCP->( RecNo() ), 'SCP', .F., 5 )

						dbSelectArea( "SCP" )
						dbSetOrder( 1 )
						If msSeek( FwxFilial( 'SCP' ) + STL->TL_NUMSA  )

							Do While SCP->( !EoF() ) .And. SCP->CP_NUM == STL->TL_NUMSA

								If SCP->CP_PREREQU != 'S'

									// Realiza exclusão da S.A. e seus relacionamentos ( SCR ).
									IIf( FindFunction( 'MntDelReq' ), MntDelReq( SCP->CP_NUM, SCP->CP_ITEM, 'SA', .T. ), NGDELETAREG( 'SCP' ) )

									// Limpa valores da requisição do array de insumos.
									If !Empty( aTask ) .And. ( !Empty( aTask[_WHREQUEST_] ) .Or. !Empty( aTask[_WHITEM_] ) )

										aTask[_WHREQUEST_] := Space( nSizeNSA )
										aTask[_WHITEM_]    := Space( nSizeISA )

									EndIf

								EndIf

								SCP->( dbSkip() )

							EndDo

						EndIf

					EndIf

				// S.A. não aglutinada
				Else

					If NGMUReques( SCP->( RecNo() ), 'SCP', .F., 5 )

						// Realiza exclusão da S.A. e seus relacionamentos ( SCR ).
						IIf( FindFunction( 'MntDelReq' ), MntDelReq( SCP->CP_NUM, SCP->CP_ITEM, 'SA', .T. ), NGDELETAREG( 'SCP' ) )

						// Limpa valores da requisição do array de insumos.
						If !Empty( aTask ) .And. ( !Empty( aTask[_WHREQUEST_] ) .Or. !Empty( aTask[_WHITEM_] ) )

							aTask[_WHREQUEST_] := Space( nSizeNSA )
							aTask[_WHITEM_]    := Space( nSizeISA )

						EndIf

					EndIf

				EndIf

			Else

				// Realiza exclusão da S.A. e seus relacionamentos ( SCR ).
				IIf( FindFunction( 'MntDelReq' ), MntDelReq( SCP->CP_NUM, SCP->CP_ITEM, 'SA', .T. ), NGDELETAREG( 'SCP' ) )

				// Limpa valores da requisição do array de insumos.
				If !Empty( aTask ) .And. ( !Empty( aTask[_WHREQUEST_] ) .Or. !Empty( aTask[_WHITEM_] ) )

					aTask[_WHREQUEST_] := Space( nSizeNSA )
					aTask[_WHITEM_]    := Space( nSizeISA )

				EndIf

			EndIf

		EndIf

	EndIf

	// Deleção de bloqueio de ferramentas
	If STL->TL_TIPOREG == 'F'

		dbSelectArea( 'SH9' )
		dbSetOrder( 3 ) // H9_FILIAL + H9_TIPO + H9_FERRAM + H9_DTINI + H9_HRINI
		If msSeek( FwxFilial( 'SH9' ) + 'F' + SubStr( STL->TL_CODIGO, 1, Len( SH9->H9_FERRAM ) ) + dToS( STL->TL_DTINICI ) +;
			STL->TL_HOINICI )

			printf( ' - Deleta bloqueios de Ferramentas' )

			RecLock( 'SH9', .F. )
			dbDelete()
			SH9->( MsUnLock() )

		EndIf

	EndIf

	// Deleção do bloqueio de especialidade.
	dbSelectArea( 'TTY' )
	dbSetOrder( 1 ) // TTY_FILIAL + TTY_ORDEM + TTY_PLANO + TTY_TAREFA + TTY_CODESP + TTY_DTINI + TTY_HRINI
	If msSeek( FwxFilial( 'TTY' ) + STJ->TJ_ORDEM + STJ->TJ_PLANO + STL->TL_TAREFA + STL->TL_CODIGO + dToS( STL->TL_DTINICI ) +;
		STL->TL_HOINICI )

		printf( ' - Deleta bloqueios de especialidade' )
		RecLock( 'TTY', .F. )
		dbDelete()
		TTY->( MsUnLock() )

	EndIf

	// Deleção do bloqueio de funcionário.
	dbSelectArea( 'STK' )
	dbSetOrder( 1 ) // TK_FILIAL + TK_ORDEM + TK_PLANO + TK_TAREFA + TK_CODFUNC + TK_DATAINI + TK_HORAINI
	If msSeek( FwxFilial( 'STK' ) + STJ->TJ_ORDEM + STJ->TJ_PLANO + STL->TL_TAREFA + PadR( STL->TL_CODIGO, Len( STK->TK_CODFUNC ) ) +;
		dToS( STL->TL_DTINICI ) + STL->TL_HOINICI )

		printf( ' - Deleta bloqueio de Funcionario' )
		RecLock( 'STK', .F. )
		dbDelete()
		STK->( MsUnLock() )

	EndIf

	// Deleta todos os Problemas antes de refazer os bloqueios de bens e insumos
	dbSelectArea( 'STA' )
	dbSetOrder( 1 ) // TA_FILIAL + TA_ORDEM + TA_PLANO + TA_TAREFA + TA_TIPOREG + TA_CODIGO + TA_DESCRIC
	If msSeek( FwxFilial( 'STA' ) + STJ->TJ_ORDEM + STJ->TJ_PLANO + STL->TL_TAREFA + STL->TL_TIPOREG + PadR( STL->TL_CODIGO,;
		Len( STA->TA_CODIGO ) ) )

		Do While STA->( !EoF() ) .And. STA->TA_ORDEM == STJ->TJ_ORDEM .And. STA->TA_PLANO == STJ->TJ_PLANO .And.;
			STA->TA_TAREFA == STL->TL_TAREFA .And. STA->TA_TIPOREG == STL->TL_TIPOREG .And. STA->TA_CODIGO == PadR( STL->TL_CODIGO,;
			Len( STA->TA_CODIGO ) )

			printf( " - Deletando registro de problema: ' " + Trim( STA->TA_DESCRIC ) + " ' referente ao bloqueio do insumo" )
			RecLock( 'STA', .F. )
			dbDelete()
			STA->( MsUnLock() )

			STA->( dbSkip() )

		EndDo

	EndIf

Return

//----------------------------------------------------------------------------------
/*/{Protheus.doc} RevMovSto
Realiza estorno de movimentação no estoque referente ao insumo.
@type function

@author	Alexandre Santos
@since 19/10/2020

@param
@return string, Mensagem de erro caso exista.
/*/
//----------------------------------------------------------------------------------
Static Function RevMovSto( )

	Local cError  := ''
	Local aRetSD3 := {}

	If !Empty( STL->TL_NUMSEQ )

	    dbSelectArea( 'SD3' )
	    dbSetOrder( 4 )
	    If msSeek( FwxFilial( 'SD3' ) + STL->TL_NUMSEQ ) .And. SD3->D3_ESTORNO != 'S'

			printf( '  - Gerando estorno do insumo realizado: ' + Trim( STL->TL_TAREFA ) + '/' + Trim( STL->TL_CODIGO ) +;
				' (' + cValToChar( STL->TL_QUANTID ) + ')' )
			
			aRetSD3 := MntGeraD3( 'DE1', , , .T., .F., .T. )

			If !aRetSD3[2]

				cError := aRetSD3[3]
			
			ElseIf NGPRODESP( SD3->D3_COD, .F., 'M' )

	            NGAtuErp( 'SD3', 'INSERT' )

	        EndIf

		EndIf

	EndIf

	/*--------------------------------------------------+
	| Desaloca consumo de memória p/ melhor performance |
	+--------------------------------------------------*/
	aSize( aRetSD3, 0 )
	aRetSD3 := Nil

Return cError

//---------------------------------------------------------------------
/*/{Protheus.doc} checkSA
Carrega os campos de S.A. no array de aInputs
@type function

@author	Alexandre Santos
@since 09/12/2020

@param  cOrder    , string, Número da ordem de serviço.
@param  cPlan     , string, Plano de manutenção.
@param  aInputTemp, array , Detalhes do insumo
@param  cOperat   , string, Operação em processo podendo ser UPDATE ou DELETE.

@return string, mensagem de erro caso houver.
/*/
//---------------------------------------------------------------------
Static Function checkSA( cOrder, cPlan, aInputTemp, cOperat )

	Local aAreaSCP  := SCP->( GetArea() )
	Local aAreaSTL  := STL->( GetArea() )
	Local cError    := ''

	dbSelectArea( 'STL' )
	dbSetOrder( 1 ) // TL_FILIAL + TL_ORDEM + TL_PLANO + TL_TAREFA + TL_TIPOREG + TL_CODIGO + TL_SEQRELA + TL_SEQTARE
	If dbSeek( FwxFilial( 'STL' ) + cOrder + cPlan + aInputTemp[_KEYTASK_] + aInputTemp[_TYPE_] + aInputTemp[_KEYCODE_] +;
		PadR( '0', TamSX3( 'TL_SEQRELA' )[1] ) + aInputTemp[_SEQTASK_] ) .And. !Empty( STL->TL_NUMSA )

		dbSelectArea( 'SCP' )
		dbSetOrder( 1 ) // CP_FILIAL + CP_NUM + CP_ITEM + CP_LOCAL
		If dbSeek( FwxFilial( 'SCP' ) + STL->TL_NUMSA + STL->TL_ITEMSA ) .And. !Empty( SCP->CP_PREREQU )

			// Impede deleção de S.A. com pré-requisição
			If cOperat == 'D'

				/*
					O insumo do tipo X XXXXXXXX com quantidade: XX e tarefa XXXXXX não pode ser excluído da ordem de
					serviço pois está vinculado a uma movimentação interna do estoque.
				*/
				cError := STR0087 + ' ' + NGRetSX3Box( 'TL_TIPOREG', STL->TL_TIPOREG ) + ' ' + Trim( STL->TL_CODIGO ) +;
					' ' + STR0088 + ' ' + cValToChar( STL->TL_QUANTID ) + ' ' + STR0089 + ' ' + Trim( STL->TL_TAREFA ) +;
					STR0162

			ElseIf cOperat == 'U'

				// Impede alteração de campos chave na S.A.
				If aInputTemp[_AMOUNT_] != SCP->CP_QUANT .Or. aInputTemp[_WAREHOUSE_] != SCP->CP_LOCAL

					/*
						O insumo do tipo X XXXXXXXX com quantidade: XX e tarefa XXXXXX não pode ser alterado da ordem de
						serviço pois está vinculado a uma movimentação interna do estoque.
					*/
					cError := STR0087 + ' ' + NGRetSX3Box( 'TL_TIPOREG', STL->TL_TIPOREG ) + ' ' + Trim( STL->TL_CODIGO ) +;
						' ' + STR0088 + ' ' + cValToChar( STL->TL_QUANTID ) + ' ' + STR0089 + ' ' + Trim( STL->TL_TAREFA ) +;
						STR0090

				// Grava valores da S.A. no array aInputTemp
				Else

					aInputTemp[_WHREQUEST_] := STL->TL_NUMSA
					aInputTemp[_WHITEM_]    := STL->TL_ITEMSA

				EndIf

			EndIf

		// Grava valores da S.A. no array aInputTemp
		Else

			aInputTemp[_WHREQUEST_] := STL->TL_NUMSA
			aInputTemp[_WHITEM_]    := STL->TL_ITEMSA

		EndIf

	EndIf

	RestArea( aAreaSTL )
	RestArea( aAreaSCP )

Return cError

//-----------------------------------------------------------------------
/*/{Protheus.doc} fcheckEquip
Valida inconsistências no cadastro do equipamento selecionado para a O.S.
@type function

@author Alexandre Santos
@since 23/12/2020

@param cCode   , string, Código do equipamento.
@param cError  , string, Variavél para tratamento e retorno de erro.

@return boolean, Indica se foi identificado alguma inconsisência no
cadastro do equipamento.
/*/
//-----------------------------------------------------------------------
Static Function fcheckEquip( cCode, cError )

	Local lReturn  := .T.
	Local aAreaST9 := ST9->( GetArea() )
	Local aAreaAll := GetArea()

	dbSelectArea( 'ST9' )
	dbSetOrder( 1 )
	If dbSeek( FwxFilial( 'ST9' ) + cCode )

		If ST9->T9_SITBEM == 'I'

			/*
				Este bem encontra-se inativo.
				Realize um novo sincronismo para atualizar os dados do aplicativo.
			*/
			cError  := STR0167 + STR0170
			lReturn := .F.

		ElseIf ST9->T9_SITBEM == 'T'

			/*
				Este bem encontra-se em outra filial devido a uma tranferência.
				Realize um novo sincronismo para atualizar os dados do aplicativo.
			*/
			cError  := STR0168 + STR0170
			lReturn := .F.

		EndIf

	Else

		/*
			Código não localizado no cadastro de bens.
			Realize um novo sincronismo para atualizar os dados de seu aplicativo.
		*/
		cError  := STR0169 + STR0170
		lReturn := .F.

	EndIf

	RestArea( aAreaAll )
	RestArea( aAreaST9 )

Return lReturn

//-----------------------------------------------------------------------
/*/{Protheus.doc} fcheckMain
Valida inconsistências no cadastro de manutenção selecionada para a O.S.
@type function

@author Alexandre Santos
@since 13/01/2020

@param cCode   , string, Código da manutenção.
@param cServ   , string, Código da serviço.
@param cSeq    , string, Sequência da manutenção.
@param cError  , string, Variavél para tratamento e retorno de erro.

@return boolean, Indica se foi identificado alguma inconsisência no
cadastro do manutenção.
/*/
//-----------------------------------------------------------------------
Static Function fcheckMain( cCode, cServ, cSeq, cError )

	Local lReturn  := .T.
	Local aAreaSTF := STF->( GetArea() )
	Local aAreaST9 := ST9->( GetArea() )
	Local aAreaAll := GetArea()

	dbSelectArea( 'ST9' )
	dbSetOrder( 1 ) // T9_FILIAL + T9_CODBEM
	If dbSeek( FwxFilial( 'ST9' ) + cCode )

		If ST9->T9_SITMAN == 'I'

			/*
				Este bem encontra-se inativo para o processo de manutenção.
				Realize um novo sincronismo para atualizar os dados do aplicativo.
			*/
	   		cError  := STR0175 + STR0170
	   		lReturn := .F.

		Else

			dbSelectArea( 'STF' )
			dbSetOrder( 1 ) // TF_FILIAL + TF_CODBEM + TF_SERVICO + TF_SEQRELA
			If dbSeek( FwxFilial( 'STF' ) + cCode + cServ + cSeq )

				If STF->TF_ATIVO == 'N'

					/*
						Esta manutenção encontra-se inativa.
						Realize um novo sincronismo para atualizar os dados do aplicativo.
					*/
					cError  := STR0173 + STR0170
					lReturn := .F.

				EndIf

			Else

				/*
					Código não localizado no cadastro de manutenção.
					Realize um novo sincronismo para atualizar os dados de seu aplicativo.
				*/
				cError  := STR0174 + STR0170
				lReturn := .F.

			EndIf

		EndIf

	EndIf

	RestArea( aAreaAll )
	RestArea( aAreaST9 )
	RestArea( aAreaSTF )

Return lReturn

//-----------------------------------------------------------------------
/*/{Protheus.doc} fseqTask
Gera valor para o campo TL_SEQTARE quando o insumo é incluso pelo APP.
@type function

@author Alexandre Santos
@since 21/01/2021

@param cOrder  , string, Ordem de serviço.
@param cPlan   , string, Plano de manutenção.
@param cSeqTask, string, Númeração para incremento.

@return string, Valor a ser gravado no campo TL_SEQTARE.
/*/
//-----------------------------------------------------------------------
Static Function fseqTask( cOrder, cPlan, cSeqTask )

	Local cAlsSTL    := GetNextAlias()

	Default cOrder   := ''
	Default cPlan    := ''
	Default cSeqTask := ''

	BeginSQL Alias cAlsSTL

		SELECT TL_SEQTARE 
		FROM %table:STL% 
		WHERE TL_FILIAL = %xFilial:STL% 
			AND TL_ORDEM = %exp:cOrder% 
			AND TL_PLANO = %exp:cPlan% 
			AND %NotDel% 
		ORDER BY TL_SEQTARE DESC

	EndSQL

	cSeqTask := Soma1( IIf( (cAlsSTL)->( !EoF() ), (cAlsSTL)->TL_SEQTARE, cSeqTask ) )

	(cAlsSTL)->( dbCloseArea() )

Return cSeqTask

//-----------------------------------------------------------------------
/*/{Protheus.doc} GeraTemp
Gera uma tabela temporária

@author Maria Elisandra de Paula
@since 20/05/21
@param cQuery, string, consulta a ser executada
@param cEntity, string, arquivo em execução
@return string, alias da temporária
/*/
//-----------------------------------------------------------------------
Static Function GeraTemp( cQuery, cEntity )

	Local cTemp := GetNextAlias()

	dbUseArea( .T., "TOPCONN", TCGenQry( Nil, Nil, cQuery ), cTemp, .T., .T. )

	fLogMntng( cEntity + ': ' + cQuery )

Return cTemp

//-----------------------------------------------------------------------
/*/{Protheus.doc} fLogTab
Verifica tabelas sem campos de usuário

@author Maria Elisandra de Paula
@since 13/09/21
@return nil
/*/
//-----------------------------------------------------------------------
Static Function fLogTab()

	Local cLog   := ''
	Local aCheck := {}
	Local nIndex := 0

	If lPeMntLog .And. ( !lDBOrderOk .Or. !lDBRequestOk )

		aCheck := fCheckBase( 'all', .T. )
		For nIndex := 1 To Len( aCheck )
			cLog += aCheck[nIndex] + '  '
		Next nIndex
		fLogMntng( 'Emp.: ' + cEmpAnt + ' - tabelas sem campos de usuario: ' + cLog )
	EndIf

Return

//-----------------------------------------------------------------------
/*/{Protheus.doc} fLogMntng
Gera logs adicionais para análise

@author Maria Elisandra de Paula
@since 13/09/21
@param cLog, string, mensagem a imprimir
@return nil
/*/
//-----------------------------------------------------------------------
Static Function fLogMntng( cLog )

	If lPeMntLog
		Printf( cLog )
	EndIf

Return

//-----------------------------------------------------------------------
/*/{Protheus.doc} fGetFile
Obtém o conteúdo decodificado de uma requisição

@author Maria Elisandra de Paula
@since 18/04/2022
@param oWS, object, instância do ws
@param cKeyJson, string, indica a chave do objeto json
@return array [1]descrição do erro
			  [2]arquivo decodificado
/*/
//-----------------------------------------------------------------------
Static Function fGetFile( oWS, cKeyJson )

	Local cBinFile := ''
	Local cError   := ''
	Local oJson

	Default cKeyJson := 'image'

	oJson  := JsonObject():New()
	cError := oJson:FromJson( oWS:GetContent() )
	If Empty( cError )
		cBinFile := oJson[cKeyJson]
		cBinFile := Decode64( cBinFile )
	EndIf

	FreeObj( oJson )

Return { cError, cBinFile }

//-----------------------------------------------------------------------
/*/{Protheus.doc} fIgnoreEnt
Busca grupo de empresas que devem ser ignoradas

@param oWs, objeto, instância do ws
@author Maria Elisandra de Paula
@since 20/01/22
@param oWs, objeto, instancia do ws
@return array, empresas que devem ser ignoradas
/*/
//-----------------------------------------------------------------------
Static Function fIgnoreEnt(oWs)

	Local aReturn := {}
	Local xIgnore

	If lPeMntNg
		//------------------------------------------------------------------
		// ID do PE para filtrar as empresas que não devem carregar no app 
		//------------------------------------------------------------------
		xIgnore := ExecBlock("MNTNG",.F.,.F.,{"COMPANY_GROUP_IGNORE", oWs})
		If !Empty(xIgnore)
			aReturn := xIgnore
		EndIf
	EndIf

Return aReturn

//---------------------------------------------------------------------
/*/{Protheus.doc} fEscapaStr
Substitui caracteres que não podem estar contidos no arquivo json

@author Maria Elisandra de Paula
@since 16/05/2022
@param cStr, string , texto que deve ser manipulado
@return string
/*/
//---------------------------------------------------------------------
Static Function fEscapaStr( cStr ) 

	If cStr != Nil

		// substitui caracteres inválidos por espaço
		cStr := StrTran( cStr, CHR(129), ' ')
		cStr := StrTran( cStr, CHR(141), ' ')
		cStr := StrTran( cStr, CHR(143), ' ')
		cStr := StrTran( cStr, CHR(144), ' ')
		cStr := StrTran( cStr, CHR(157), ' ')

		// escape de caracteres válidos
		cStr := StrTran( cStr, '\', '\\' )
		cStr := StrTran( cStr, '"', '\"' )
		cStr := StrTran( cStr, CHR( 13 ) + CHR( 10 ), '\n' )
		cStr := StrTran( cStr, CHR( 10 ), '\n' )
		cStr := StrTran( cStr, CHR( 13 ), '\n' )
		cStr := Alltrim( cStr )

	Else 
		cStr := ' '
	EndIf

Return cStr

//---------------------------------------------------------------------
/*/{Protheus.doc} NGEscape
Escape de string, conversão para encode-Utf8 
e realiza tratamento caso tenha problema

@author Maria Elisandra de Paula
@since 13/05/2022
@param cStr, string, texto que deve ser manipulado
@return string com tratamento
/*/
//---------------------------------------------------------------------
Static Function NGEscape( cStr )

    Local cStrBkp := cStr

	If cStr != Nil .And. !Empty( cStr )

		cStr := FwhttpEncode( fEscapaStr( cStrBkp ) )

		If cStr == Nil .Or. Empty( cStr ) 
			cSTr := fTrataStr( cStrBkp )
			cStr := FwhttpEncode( fEscapaStr( cSTr ) )
		EndIf

	EndIf

    If cStr == Nil
        cStr := ' '
    EndIf

Return cStr

//---------------------------------------------------------------------
/*/{Protheus.doc} fTrataStr
Tratamento de texto com erro ao converter para utf-8

@author Maria Elisandra de Paula
@since 13/05/2022
@param cStr, string, texto que deve ser manipulado
@return string com tratamento
/*/
//---------------------------------------------------------------------
Static Function fTrataStr( cStr )

	Local cConvertid := ''
	Local cRetorno   := ''
	Local cTesta100  := ''
	Local nInicio    := 1
	Local nTam       := Len( cStr )

	While( nInicio <= nTam )

		cTesta100  := Substr( cStr, nInicio, 100 ) 
		cConvertid := EncodeUtf8( cTesta100 )

		If cConvertid == Nil
			cConvertid := fTrataChar( cTesta100 ) // substitui caracter com problema para ' '
		EndIf

		cRetorno += cConvertid
		nInicio += 100

	EndDo

Return cRetorno

//---------------------------------------------------------------------
/*/{Protheus.doc} fTrataChar
Converte caracter com problema para ' '

@author Maria Elisandra de Paula
@since 13/05/2022
@param cStr, string, texto que deve ser manipulado
@return string com tratamento
/*/
//---------------------------------------------------------------------
Static Function fTrataChar( cStr100 )

    Local nX    := 0
	Local cChar := ''

	// teste com cada caracter da string
    For nX := 1 To Len( cStr100 )

        cChar := Substr( cStr100, nX, 1)

        If !Empty( cChar ) .And. EncodeUtf8( cChar ) == Nil
            cStr100 := StrTran( cStr100, cChar, ' ')
        EndIf

    Next nX

Return cStr100

//---------------------------------------------------------------------
/*/{Protheus.doc} fBranches
Retorna um array com código e nome do grupo e filial

@author Maria Elisandra de Paula
@since 28/06/2022
@param aBranches, array, filiais que o usuário tem permissão de acesso
@return array de filiais
/*/
//---------------------------------------------------------------------
Static Function fBranches( aBranches )

	Local oEntity
	Local cEnterprise := ''
	Local cBranch     := ''
	Local nIndex      := 0
	Local aResponse   := {}
	Local aJafoi      := {}
	Local lBranch     := .F. 

	// Info: Conteudo de cada linha do array aBranches é no formato "T3M RJ 02 "
	For nIndex := 1 To Len( aBranches )

		cEnterprise := SubStr( aBranches[nIndex], 1, 2 ) // M0_CODIGO (Ex: T3)
		cBranch := SubStr( aBranches[nIndex], 3    ) // M0_CODFIL (Ex: M SP 01 )

		If Ascan(aJafoi, cEnterprise) == 0

			aadd(aJafoi, cEnterprise)

			If !ConfigEnv2( cEnterprise, cBranch )
				Printf( "Configuracao do ambiente nao realizada" )
				Loop
			EndIf

			If !lDBOrderOk .And. !lDBRequestOk
				Printf( cEnterprise + cBranch + " Falta campos de usuário." )
				Loop
			EndIf

			If lOrderPermission .And. !lDBOrderOk
				Printf( cEnterprise + cBranch + " nao possui os campos de usuario para ordem de servico." )
				Loop
			EndIf

			If lRequestPermission .And. !lOrderPermission .And. !lDBRequestOk
				Printf( cEnterprise + cBranch + " nao possui os campos de usuario para solicitações." )
				Loop
			EndIf

			lBranch := .T.

		EndIf

		If lBranch

			oEntity := Branches():New()
			oEntity:EnterpriseCode      := cEnterprise
			oEntity:BranchCode          := cBranch
			oEntity:EnterpriseName      := Alltrim( FWGrpName( cEnterprise ) )
			oEntity:BranchName          := FWFilName( cEnterprise, cBranch )
			oEntity:Localization        := oEntity:EnterpriseName + ' / ' + oEntity:BranchName

			aAdd( aResponse, oEntity )

		EndIf

	Next nIndex

Return aResponse

//---------------------------------------------------------------------
/*/{Protheus.doc} fDownload
Download de arquivo

@param oWebService, objeto, instância do ws
@param cPath, string, caminho do arquivo
@param cFileName, string, nome do arquivo

@author Marcelo Camargo
@since 14/03/2016
@return boolean, se obteve sucesso
/*/
//---------------------------------------------------------------------
Static Function fDownload( oWebService, cPath, cFileName )
    
	Local xBytes := fReadBytes( cPath )
	
    If Nil == xBytes .Or. FError() != 0 
        Return .F.
    EndIf
	
	xBytes := Encode64(xBytes)

    oWebService:SetContentType( 'application/octet-stream' )
    oWebService:SetHeader( 'Content-Disposition', 'attachment; filename=' + cFileName )
    oWebService:SetHeader( 'Pragma', 'no-cache' )
    oWebService:SetResponse( xBytes )

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fImage
Download de imagem

@param oWebService, objeto, instância do ws
@param cPath, string, caminho do arquivo

@author Marcelo Camargo
@since 14/03/2016
@version P12
@return boolean, se obteve sucesso
/*/
//---------------------------------------------------------------------
Static Function fImage( oWebService, cPath )
    
	Local xBytes := fReadBytes( cPath )
	
    If Nil == xBytes .Or. 0 <> FError()
        Return .F.
    EndIf

    oWebService:SetResponse( '{"image":"' + Encode64(xBytes) + '"}' )

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fReadBytes
Retorna caracteres de um arquivo binário

@param cFileName, string, nome do arquivo
@author Marcelo Camargo
@since 30/08/2016
@return caracteres do arquivo
/*/
//---------------------------------------------------------------------
Static Function fReadBytes( cFileName )
    
	Local nHandler := FOpen( cFileName, FO_READWRITE + FO_SHARED )
    Local nSize    := 0
    Local xBuffer  := ''

    If -1 == nHandler
        Return Nil
    EndIf

    nSize := FSeek( nHandler, 0, FS_END )
    FSeek( nHandler, 0 )
    FRead( nHandler, xBuffer, nSize )
    FClose( nHandler )
Return xBuffer

//---------------------------------------------------------------------
/*/{Protheus.doc} fInitWrite
Grava/envia inicio da entidade para sincronização

@param oWs, object, instância do ws
@param cEntity, string, nome da entidade
@author Maria Elisandra de Paula
@since 21/09/2022
@return array 
	boolean [se operação ocorreu com sucesso]
	string  [mensagem de erro]
	array   [nome dos arquivos criados]
	nUpdate [handler do arquivo de delete]
	nDelete [hanlder do arquivo de update]
/*/
//---------------------------------------------------------------------
Static Function fInitWrite(oWs, cEntity)

	Local aFileName := {}
	Local nDelete   := 0
	Local nUpdate   := 0

	If lNewSync
		oWs:SetResponse(fItemInit(cEntity))
	Else
		aFileName := GenFileName( cEntity )
		nDelete := FCreate( aFileName[ 1 ] )
		nUpdate := FCreate( aFileName[ 2 ] )

		If nDelete == -1 .Or. nUpdate == -1
			Return {.F. , STR0017 + " " + AllTrim( Str( FError() ) ) }//"Falha ao alocar memória:"}
		EndIf

		FWrite( nDelete, '[' )
		FWrite( nUpdate, '[' )
	EndIf

Return {.T., '', aFileName, nDelete, nUpdate}

//---------------------------------------------------------------------
/*/{Protheus.doc} fWriteJson
Grava/envia dados de sincronização

@param cSubJSON, string, mensagem
@param nFile, numérico, handler do arquivo
@param oWs, object, instância do ws
@author Maria Elisandra de Paula
@since 21/09/2022
/*/
//---------------------------------------------------------------------
Static Function fWriteJson(cSubJSON, nFile, oWs)

	If lNewSync
		oWs:SetResponse(cSubJSON)
	Else
		FWrite( nFile, cSubJSON )
	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fEndWrite
Grava/envia dados de sincronização

@param oWs, object, instância do ws
@param cDelete, string, dados para exclusão
@param cEntity, string, nome da entidade
@param nDelete, numeric, handler de delete
@param nUpdate, numeric, handler de update
@param nCount, numeric, quantidade de registros
@param cHrIn, string, hora inicio de sinc da entidade
@author Maria Elisandra de Paula
@since 21/09/2022
/*/
//---------------------------------------------------------------------
Static Function fEndWrite(oWs, cDelete, cEntity, nDelete, nUpdate, nCount, cHrIn)

	If lNewSync
		oWs:SetResponse(']}')
		fJsonDel(oWs, cDelete, cEntity)
	Else
		FWrite( nDelete, cDelete )
		FWrite( nDelete, ']' )
		FWrite( nUpdate, ']' )

		FClose( nDelete )
		FClose( nUpdate )
	EndIf

	printf( cEntity + ': ' + cValtoChar( nCount ) + ' em ' + ElapTime( cHrIn, Time() ) )

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fHeaderArr
Retorna conteúdo de um header

@param oWs, object, instância do ws
@param cValue, string, nome do header
@author Maria Elisandra de Paula
@since 21/09/2022
/*/
//---------------------------------------------------------------------
Static Function fHeaderArr(oWS, cValue)

Return IIf( ValType( oWS:GetHeader( cValue ) ) == "C", StrTokArr( oWS:GetHeader( cValue ) , "|"), {} )

//---------------------------------------------------------------------
/*/{Protheus.doc} fGetSalSb2
Envia saldo de produtos da SB2

@author Maria Elisandra de Paula
@since 29/09/2022
@param oWs, objeto, instância do webservice
@param cproduct, string, código do produgo
@return array, 
		1 [se obteve sucesso na operação]
		2 [mensagem de erro]
/*/
//---------------------------------------------------------------------
Static Function fGetSalSb2( oWs, cProduct )

	Local aAux  := {}
	Local cResp :=  '{"items":[' 
	Local nI    := 0

	If !FindFunction('MntSldSB2')
		Return {.F., FwhttpEncode(STR0203)}// 'O repositório do servidor não está atualizado para a funcionalidade de saldos de produtos.')}
	EndIf

	aAux := MntSldSb2(cProduct)

	If !Empty(aAux)
		For nI := 1 to Len(aAux)
			If nI > 1
				cResp += ','
			EndIf
			cResp += '{"warehouse":"' + aAux[nI,1] + '",'
			cResp += '"quantity":' + cValTochar(aAux[nI,2]) + '}' 
		Next nI
	EndIf

	cResp += ']}'

	oWs:SetStatus( 200 )
	oWs:SetResponse( FwhttpEncode( cResp ) )

Return {.T., ''}

//---------------------------------------------------------------------
/*/{Protheus.doc} fGetSalSbf
Envia saldo de produtos com endereçamento - SBF

@author Maria Elisandra de Paula
@since 29/09/2022
@param oWs, objeto, instância do webservice
@param cproduct, string, código do produto
@param cWarehouse, string, código do local
@return array, 
		1 [se obteve sucesso na operação]
		2 [mensagem de erro]
/*/
//---------------------------------------------------------------------
Static Function fGetSalSbf( oWs, cProduct, cWarehouse )

	Local aAux  := {}
	Local cResp :=  '{"items":[' 
	Local nI    := 0

	If !FindFunction('MntSldSB2')
		Return {.F., FwhttpEncode(STR0203)}// 'O repositório do servidor não está atualizado para a funcionalidade de saldos de produtos.')}
	EndIf

	aAux := MntSldSbf(cProduct, cWarehouse)

	If !Empty(aAux)
		For nI := 1 to Len(aAux)
			If nI > 1
				cResp += ','
			EndIf
			cResp += '{"address":"' + aAux[nI,1] + '",'
			cResp += '"quantity":' + cValTochar(aAux[nI,2]) + '}' 
		Next nI
	EndIf

	cResp += ']}'

	oWs:SetStatus( 200 )
	oWs:SetResponse( FwhttpEncode( cResp ) )

Return {.T., ''}

//---------------------------------------------------------------------
/*/{Protheus.doc} fGetParts
Envia peças de reposição do bem

@author Pedro Henrique Perez Trebilcock
@since 16/10/2023
@param oWs, objeto, instância do rest
@param itemconde, string, código do bem
@return array, 
		1 [se obteve sucesso na operação]
		2 [mensagem de erro]
/*/
//---------------------------------------------------------------------
Static Function fGetParts( oWs, cItemcode )
 
    Local cError := ''
    Local lRet   := .T.
   
 
    dbSelectArea( 'ST9' )
    dbSetOrder( 1 )
    If !MsSeek( FwxFilial( 'ST9' ) + cItemcode )
 
        lRet := .F.
        cError := STR0215 //Bem não localizado
   
    Else
 
        oWs:SetStatus( 200 )
        oWs:SetResponse( FwhttpEncode( fRetParts( cItemcode ) ) )
 
    EndIf
 
 
Return { lRet, cError }

//---------------------------------------------------------------------
/*/{Protheus.doc} fRetParts
Faz query no banco de dados e devolve informação sobre peças de reposição.

@author Pedro Henrique Perez Trebilcock
@since 16/10/2023
@param cItemconde, string, código do bem
@return array, com informações do bem.
/*/
//---------------------------------------------------------------------

static function fRetParts(cItemcode)
 
    Local cAlias := GetNextAlias()
    Local cResp  :=  '{"items":['
    Local nI     := 0
 
    BeginSQL Alias cAlias
 
        SELECT  TPY_CODPRO,
                TPY_QUANTI,
                TPY_CRITIC,
                TPY_QTDGAR,
                TPY_UNIGAR,
                TPY_CONGAR,
                TPY_QTDCON,
                TPY_LOCGAR,
                B1_DESC,
                B1_UM
           
        FROM %table:TPY% TPY
 
        INNER JOIN
 
            %table:SB1% SB1 ON
                SB1.B1_FILIAL = %exp:FwxFilial('SB1')% AND
                TPY.TPY_CODPRO = SB1.B1_COD AND
                SB1.%notDel%
 
        WHERE
           
            TPY.TPY_FILIAL = %exp:FwxFilial('TPY')% AND
            TPY.TPY_CODBEM = %exp:cItemcode% AND
            TPY.%notDel%
 
    EndSQL
       
    While (cAlias)->( !EoF() )
 
        nI++
 
        If nI > 1
            cResp += ','
        EndIf
 
        cResp += '{"product":"' + AllTrim((cAlias)->TPY_CODPRO) + '",'
        cResp += '"name":"' + AllTrim((cAlias)->B1_DESC) + '",'
        cResp += '"quantity":"' + cValToChar((cAlias)->TPY_QUANTI) + '",'
        cResp += '"unity":"' + (cAlias)->B1_UM +'",'
        cResp += '"criticity":"' + (cAlias)->TPY_CRITIC + '",'
        cResp += '"warranty":"' + cValtoChar((cAlias)->TPY_QTDGAR) + '",'
        cResp += '"warrantyUnit":"' + (cAlias)->TPY_UNIGAR + '",'
        cResp += '"counter":"' + (cAlias)->TPY_CONGAR + '",'
        cResp += '"counterQuantity":"' + cValtoChar((cAlias)->TPY_QTDCON) + '",'
        cResp += '"location":"' + AllTrim((cAlias)->TPY_LOCGAR) + '"}'
       
        (cAlias)->(dbSkip())
 
    End
 
    (cAlias)->(dbCloseArea())
 
    cResp += ']}'
 
Return cResp
//---------------------------------------------------------------------
/*/{Protheus.doc} MNTNGInput
Centraliza chamadas do processo de insumos.

@author Alexandre Santos
@since 10/10/2022

@param nProcess, integer, Indica o processo acionado.
							1 - Insumo Realizado.
							2 - PlayStop.
@param cOrder  , string , Ordem de Serviço.
@param cTypeSO , string , Indica o tipo da OS.
@param cBody   , string , JSON que contém os dados do play e stop.

@return undefined
/*/
//---------------------------------------------------------------------
Function MNTNGInput( nProcess, cOrder, cTypeSO, cBody )

	Local xRet

	If nProcess == 1

		/*-------------------------------------+
		| Processamento de insumos realizados. |
		+-------------------------------------*/
		xRet := InputSTLRea( cOrder, cTypeSO )

	ElseIf nProcess == 2

		/*-------------------------------------------+
		| Processamento de aplicação de mão de obra. |
		+-------------------------------------------*/
		xRet := playStop( cBody )

	EndIf

Return xRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fCaseDel
Retorna string de case para controle de deletados

@author Maria Elisandra de Paula
@since 07/10/2022
@param cNickName, string, nome da tabela
@param lLast, boolean, indica se é a última coluna da consulta
@return string
/*/
//---------------------------------------------------------------------
Static Function fCaseDel(cNickName, lLast)
	
	Local cEnd := ', '

	Default lLast := .F.

	If lLast
		cEnd := ' '
	EndIf

Return "CASE WHEN " + cNickName + "." + "D_E_L_E_T_ = ' ' THEN ' ' Else 'true' END AS IS_DELETED " + cEnd
//---------------------------------------------------------------------
/*/{Protheus.doc} fCondDel
Retorna resultado da instrução para controle de deletados
@author Maria Elisandra de Paula
@since 07/10/2022
@param cAliasQry, string, tabela
@return boolean
/*/
//---------------------------------------------------------------------
Static Function fCondDel(cAliasQry)
Return Empty((cAliasQry)->IS_DELETED)

//---------------------------------------------------------------------
/*/{Protheus.doc} fWhereSt9
Condição where para query de equipamentos

@author Maria Elisandra de Paula
@param oWs, objeto, ws corrente
@since 25/01/23
@return string, Condição where para query de equipamentos
/*/
//---------------------------------------------------------------------
Static Function fWhereSt9( oWs )

	Local cQuery := makeFilter( fHeaderArr( oWs, 'equipment' ), "ST9.T9_CODBEM" ) 

	cQuery += fFilterPe( oWs, 'FILTER_EQUIPMENT' )

	cQuery += " AND ST9.T9_SITMAN = 'A' AND ST9.T9_SITBEM = 'A' "

	If lPortalOrigin .And. NGCADICBASE("T9_MSBLQL","A","ST9",.F.)
		cQuery += " AND ST9.T9_MSBLQL <> '1' "
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} fWhereSt6
Condição where para query de família de equipamentos

@author Maria Elisandra de Paula
@param oWs, objeto, ws corrente
@since 25/01/23
@return string, Condição where para query de família de equipamentos
/*/
//---------------------------------------------------------------------
Static Function fWhereSt6( oWs )

	Local cQuery  := makeFilter( fHeaderArr( oWs, 'family' ), "ST6.T6_CODFAMI" )

	cQuery += fFilterPe( oWs, 'FILTER_FAMILY' )

	If lPortalOrigin .And. NGCADICBASE("T6_MSBLQL","A","ST6",.F.)
		cQuery += " AND ST6.T6_MSBLQL <> '1' "
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} fWhereSt4
Condição where para query de serviços

@author Maria Elisandra de Paula
@param oWs, objeto, ws corrente
@since 25/01/23
@return string, Condição where para query de serviços
/*/
//---------------------------------------------------------------------
Static Function fWhereSt4( oWs )

	Local cQuery := makeFilter( fHeaderArr( oWs, 'service' ), "ST4.T4_SERVICO" )
	cQuery += fFilterPe( oWs, 'FILTER_SERVICE' )

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} fWherectt
Condição where para query de cc

@author Maria Elisandra de Paula
@param oWs, objeto, ws corrente
@since 25/01/23
@return string, Condição where para query de cc
/*/
//---------------------------------------------------------------------
Static Function fWhereCtt( oWs )

	Local cQuery := makeFilter( fHeaderArr( oWs, 'costcenter' ), "CTT.CTT_CUSTO" )

	cQuery += fFilterPe( oWs, 'FILTER_COSTCENTER' )

	If lPortalOrigin .And. NGCADICBASE("CTT_MSBLQL","A","CTT",.F.)
		cQuery += " AND CTT.CTT_MSBLQL <> '1' "
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} fWhereSb1
Condição where para query de produtos

@author Maria Elisandra de Paula
@param oWs, objeto, ws corrente
@since 25/01/23
@return string, Condição where para query de produtos
/*/
//---------------------------------------------------------------------
Static Function fWhereSb1( oWs )

	Local cQuery    := makeFilter( fHeaderArr( oWs, 'product' ), "SB1.B1_COD")
	Local aProducts := NGProdMNT()
	Local cProdutos := ""
	Local nX        := 0
	Local nLenProd  := Len( aProducts )

	cQuery += fFilterPe( oWs, 'FILTER_PRODUCT' )

	For nX := 1 To nLenProd

		If nX > 1
			cProdutos += ','
		EndIf
		
		cProdutos += "'" + aProducts[nX] + "'"

	Next nX

	cQuery += " AND SUBSTRING(SB1.B1_COD,1,3) <> 'MOD' " 
	
	If !Empty( cProdutos )
		cQuery += " AND SB1.B1_COD NOT IN (" + cProdutos + ") "
	EndIf

	If SuperGetMV("MV_PRODMOD",.F.,.T.)
		cQuery += "AND SB1.B1_CCCUSTO = ' ' "
	EndIf

	If lPortalOrigin .And. NGCADICBASE("B1_MSBLQL","A","SB1",.F.)
		cQuery += " AND SB1.B1_MSBLQL <> '1' "
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} fWhereSa2
Condição where para query de clientes/terceiros

@author Maria Elisandra de Paula
@param oWs, objeto, ws corrente
@since 25/01/23
@return string, Condição where para query de clientes/terceiros
/*/
//---------------------------------------------------------------------
Static Function fWhereSa2( oWs )

	Local cQuery  := makeFilter( fHeaderArr( oWs, 'thirdpart' ), "SA2.A2_COD" )
	
	cQuery += fFilterPe( oWs, 'FILTER_THIRDPART' )

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} fWhereSh4
Condições where para query de ferramentas

@author Maria Elisandra de Paula
@param oWs, objeto, ws corrente
@since 25/01/23
@return string, Condição where para query de ferramentas
/*/
//---------------------------------------------------------------------
Static Function fWhereSh4( oWs )

	Local cQuery  := makeFilter( fHeaderArr( oWs, 'tool' ), "SH4.H4_CODIGO")
	
	cQuery += fFilterPe( oWs, 'FILTER_TOOL' )

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} fWhereStD
Condições where para query de area

@author Maria Elisandra de Paula
@param oWs, objeto, ws corrente
@since 25/01/23
@return string, Condição where para query de area
/*/
//---------------------------------------------------------------------
Static Function fWhereStD( oWs )

	Local lBlock  := NGCADICBASE("TD_MSBLQL","A","STD",.F.)
	Local cQuery  := makeFilter( fHeaderArr( oWs, 'area' ), "STD.TD_CODAREA" )

	cQuery += fFilterPe( oWs, 'FILTER_AREA' )

	If lPortalOrigin .And. lBlock
		cQuery += " AND STD.TD_MSBLQL <> '1' "
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} fJoinSTJ
Condições para ser utilizado nas querys de ordens de serviço

@author Maria Elisandra de Paula
@param oWs, objeto, ws corrente
@since 02/02/23
@return string, condição join para ser utilizado nas querys de ordens de serviço
/*/
//---------------------------------------------------------------------
Static Function fJoinSTJ( oWs )

	Local aType  := If(ValType(oWS:GetHeader( 'type' )) == "C", StrTokArr( oWS:GetHeader( 'type' ) , "|"), {})
	Local lLocOS := fHasPerms('location-order')

	cQuery := " INNER JOIN " + RetSQLName('ST4') + " ST4 "
	cQuery += "		ON ST4.T4_FILIAL = " + ValToSql( FwxFilial("ST4") )
	cQuery += " 	AND ST4.T4_SERVICO = STJ.TJ_SERVICO "

	cQuery += 		fWhereSt4( oWs )
	cQuery += " AND ST4.D_E_L_E_T_ = ' ' "

	cQuery += " INNER JOIN " + RetSQLName('STE') + " STE "
	cQuery += "     ON TE_FILIAL = " + ValToSql( FwxFilial("STE",) )
	cQuery += "     AND STE.TE_TIPOMAN = ST4.T4_TIPOMAN "
	cQuery += "     AND STE.D_E_L_E_T_ = ' ' "

	cQuery += makeFilter( aType, 'STE.TE_CARACTE' )

	cQuery += " INNER JOIN " + RetSQLName('STD') + " STD "
	cQuery += "	    ON TD_FILIAL = " + ValtoSql( FwxFilial('STD') )
	cQuery += "     AND ST4.T4_CODAREA = STD.TD_CODAREA "
	cQuery += "     AND STD.D_E_L_E_T_ = ' ' "

	// tratamento para considerar filtros de centro de custo
	cQuery += " LEFT JOIN  " + RetSQLName("CTT") + " CTT "
	cQuery += "		ON CTT.CTT_FILIAL = " + ValtoSql( FwxFilial("CTT") )
	cQuery += "		AND CTT.CTT_CUSTO = STJ.TJ_CCUSTO "
	cQuery += fWhereCtt( oWs )
	cQuery += "     AND CTT.D_E_L_E_T_ = ' ' "

	// tratamento para considerar filtros de bens e impedir inconsistencias entre STJ e ST9
	cQuery += " LEFT JOIN " + RetSqlName("ST9") + " ST9 "
	cQuery += " 	ON ST9.T9_FILIAL = " + ValtoSql( FwxFilial("ST9") )
	cQuery += "		AND ST9.T9_CODBEM = STJ.TJ_CODBEM "
	cQuery += fWhereSt9( oWs )
	cQuery += "		AND ST9.D_E_L_E_T_ = ' ' "

	// tratamento para considerar filtros de família de bens e impedir inconsistencias entre STJ e ST9/ST6
	cQuery += " LEFT JOIN " + RetSqlName("ST6") + " ST6 "
	cQuery += "		ON ST6.T6_FILIAL = " + ValtoSql( FwxFilial("ST6") )
	cQuery += "		AND  ST6.T6_CODFAMI = ST9.T9_CODFAMI "
	cQuery += fWhereSt6( oWs )
	cQuery += "		AND ST6.D_E_L_E_T_ = ' ' "

	If lLocOS

		// tratamento para considerar as ordens de localizações
		cQuery += " LEFT JOIN " + RetSqlName("TAF") + " TAF "
		cQuery += "		ON TAF.TAF_FILIAL = " + ValtoSql( FwxFilial("TAF") )
		cQuery += "		AND TAF.TAF_CODNIV = STJ.TJ_CODBEM "
		cQuery += "		AND TAF.D_E_L_E_T_ = ' ' "

	EndIf

	If lMigrated

		cQuery += " LEFT JOIN "+ RetSQLName('HP3') + " HP3_ST4 "
		cQuery += "  ON  HP3_ST4.HP3_FILIAL = " + ValToSQL( FWxFilial( "HP3" ) )
		cQuery += "  AND HP3_ST4.HP3_FILORI = ST4.T4_FILIAL "
		cQuery += "  AND HP3_ST4.HP3_CODGRP = " + ValToSQL( cUserGrp )
		cQuery += "  AND HP3_ST4.HP3_TABLE  = 'ST4' "
		cQuery += "  AND HP3_ST4.HP3_CODE   = ST4.T4_SERVICO"
		cQuery += "  AND HP3_ST4.D_E_L_E_T_ = ' '"

		// trecho que verifica as areas(STD) que não devem ser enviadas
		cQuery += " LEFT JOIN "+ RetSQLName('HP3') + " HP3_STD "
		cQuery += "  ON  HP3_STD.HP3_FILIAL = " + ValToSQL( FWxFilial( "HP3" ) )
		cQuery += "  AND HP3_STD.HP3_FILORI = STD.TD_FILIAL "
		cQuery += "  AND HP3_STD.HP3_CODGRP = " + ValToSQL( cUserGrp )
		cQuery += "  AND HP3_STD.HP3_TABLE  = 'STD' "
		cQuery += "  AND HP3_STD.HP3_CODE   = STD.TD_CODAREA"
		cQuery += "  AND HP3_STD.D_E_L_E_T_ = ' '"

		cQuery += " LEFT JOIN "+ RetSQLName('HP3') + " HP3_ST6 "
		cQuery += "  ON  HP3_ST6.HP3_FILIAL = " + ValToSQL( FWxFilial( "HP3" ) )
		cQuery += "  AND HP3_ST6.HP3_FILORI = ST6.T6_FILIAL "
		cQuery += "  AND HP3_ST6.HP3_CODGRP = " + ValToSQL( cUserGrp )
		cQuery += "  AND HP3_ST6.HP3_TABLE  = 'ST6' "
		cQuery += "  AND HP3_ST6.HP3_CODE   = ST6.T6_CODFAMI"
		cQuery += "  AND HP3_ST6.D_E_L_E_T_ = ' '"

		cQuery += " LEFT JOIN "+ RetSQLName('HP3') + " HP3_CTT "
		cQuery += "  ON  HP3_CTT.HP3_FILIAL = " + ValToSQL( FWxFilial( "HP3" ) )
		cQuery += "  AND HP3_CTT.HP3_FILORI = CTT.CTT_FILIAL "
		cQuery += "  AND HP3_CTT.HP3_CODGRP = " + ValToSQL( cUserGrp )
		cQuery += "  AND HP3_CTT.HP3_TABLE  = 'CTT' "
		cQuery += "  AND HP3_CTT.HP3_CODE   = CTT.CTT_CUSTO"
		cQuery += "  AND HP3_CTT.D_E_L_E_T_ = ' '"

	EndIf

	cQuery += " WHERE STJ.TJ_FILIAL = " + ValtoSql(FwxFilial("STJ"))
	
	// trecho que corresponde às condições left join da tabela HP3 logo acima
	If lMigrated
		cQuery += " AND HP3_ST4.HP3_CODE IS NULL "
		cQuery += " AND HP3_STD.HP3_CODE IS NULL "
		cQuery += " AND HP3_ST6.HP3_CODE IS NULL "
		cQuery += " AND HP3_CTT.HP3_CODE IS NULL "
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} fFilterPe
Verifica se existe ponto de entrada e retorna o conteudo referente ao ID
(utilizar somente para filtros de querys)

@author Maria Elisandra de Paula
@param oWs, objeto, ws corrente
@param cId, string, identificados do ponto de entrada
@since 25/01/23
@return string, conteúdo do PE
/*/
//---------------------------------------------------------------------
Static Function fFilterPe( oWs, cId )

	Local cQuery  := ''
	Local cFilter := ''

	If lPeMntNg
		cFilter := ExecBlock("MNTNG",.F.,.F.,{ cId, oWS })
		If !Empty(cFilter)
			cQuery :=  cFilter
		EndIf
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} Groups
Importa dados de Grupos do portal MNTNG

@author Cristiano Serafim Kair
@since	14/10/2022
@return	Lógico
/*/
//---------------------------------------------------------------------
WsMethod POST Groups WsService Mntng

Return fExecPost('Groups', 'fGroups', Self)

//---------------------------------------------------------------------
/*/{Protheus.doc} Permissions
Importa dados de Permissoes do portal MNTNG

@author Cristiano Serafim Kair
@since	14/10/2022
@return	Lógico
/*/
//---------------------------------------------------------------------
WsMethod POST Permissions WsService Mntng

Return fExecPost('Permissions', 'fPerms', Self)

//---------------------------------------------------------------------
/*/{Protheus.doc} Users
Importa dados de Usuários do portal MNTNG

@author Cristiano Serafim Kair
@since	11/11/2022
@return	Lógico
/*/
//---------------------------------------------------------------------
WsMethod POST Users WsService Mntng

Return fExecPost('Users', 'fUsers', Self)

//---------------------------------------------------------------------
/*/{Protheus.doc} Filters
Aciona importação de Filtros do portal MNTNG

@author Cristiano Serafim Kair
@since	05/12/2022
@return	boolean
/*/
//---------------------------------------------------------------------
WsMethod POST Filters WsService Mntng

Return fExecPost('Filters', 'fFilters', Self)

//---------------------------------------------------------------------
/*/{Protheus.doc} EnvironmentInformation
Importa informações do ambiente obtidos do portal MNTNG

@author Maria Elisandra de paula
@since	16/03/2022
@return	boolean
/*/
//---------------------------------------------------------------------
WsMethod POST EnvironmentInformation WsService Mntng

Return fExecPost('Environment Infos', 'fSet1Key', Self)

//---------------------------------------------------------------------
/*/{Protheus.doc} fExecPost
Executa métodos de migração do portal

@author Maria Elisandra de Paula
@since 21/12/2022
@return	boolean
/*/
//---------------------------------------------------------------------
Static Function fExecPost(cMethod, cFunction,Self)

	Local aRet := fCheckMNTNG()
    Local lRet := aRet[1]
	Local oError
	Local bLastError

	printf( cMethod )

	If !lRet
		PrintPostLog( Self, lRet, aRet )
		Return .F.
	EndIf

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

	Begin Sequence

		Begin Transaction

			lRet := &(cFunction)( Self, '' )

			PrintPostLog( Self, lRet, aRet )

		Recover

			DisarmTransaction()

			Break

		End Transaction

		CloseTransactions( {} )

	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fFilters
Aciona função de gravação dos filtros do portal

@author Maria Elisandra de Paula
@since 21/12/2022
@return	boolean
/*/
//---------------------------------------------------------------------
Static Function fFilters(oWs)

	Local lRet 		:= .F.
    Local cJson 	:= oWs:GetContent()
	Local oParser	:= ''

	If FWJsonDeserialize( cJson, @oParser ) .And. AttIsMemberOf( oParser, 'branch' )

		cEnterprise := DecodeUTF8( oParser:enterprise )
		cBranch 	:= DecodeUTF8( oParser:branch )

		If cEmpAnt != cEnterprise
			lRet := StartJob( 'MNTNGFILTR', GetEnvServer(), .T., cJson, .T. )
		Else
			lRet := MNTNGFILTR( cJson, .F. )
		EndIf

	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fLastAcces
Registra ou recupera último acesso do usuário

@author Cristiano Serafim Kair

@param lGetAccess, lógico, recuperar o último acesso

@since 14/06/2022
@return String, último acesso
/*/
//---------------------------------------------------------------------
Static Function fLastAcces( lGetAccess )

	Default lGetAccess := .F.

	If ChkFile('HP2')

		dbSelectArea( 'HP2' )
		dbSetOrder( 2 ) //HP2_FILIAL+HP2_CODUSR+HP2_CODGRP
		If dbSeek( FWxFilial( 'HP2' ) + cUserLog )

			If lGetAccess

				Return HP2->HP2_ACCESS

			Else

				RecLock( 'HP2', .F. )

				HP2->HP2_ACCESS := DToS( Date() ) + ' ' + Time()

				HP2->(MsUnlock())

			EndIf

		EndIf

	EndIf

Return ''

//---------------------------------------------------------------------
/*/{Protheus.doc} fGroups
Cadastra dados do Portal MNTNG

@type function
@author cristiano.kair
@since 14/10/2022

@param cJson, Caracter, Json com os dados do Portal MNTNG

@return lógico
/*/
//---------------------------------------------------------------------
Static Function fGroups( oWs )

	Local cJson := oWs:GetContent()
	Local oParser
	Local aItems := {}
	Local nItem := 0
	Local oModel := FWLoadModel( 'MNTA915' )
	Local aFields := {}
	Local lRet := .T.
	Local cDescricao := ''

	If FWJsonDeserialize(cJson,@oParser)

		If AttIsMemberOf( oParser, 'items' )

			aItems := oParser:items

			For nItem := 1 To Len( aItems )

				cDescricao := DecodeUTF8( aItems[nItem] )
				aFields := {}

				If !fFoundGrp(cDescricao)

					aAdd( aFields, { 'HP0_DESCRI', Upper(cDescricao), Nil } )
					aAdd( aFields, { 'HP0_TIPO', '2', Nil } )

					FWMVCRotAuto(oModel, 'HP0', 3, { { 'MNTA915_HP0', aFields } } ,,.T. )

				EndIf

			Next nItem

		EndIf

	EndIf

    //Performance
    aSize( aFields, 0 )
    aFields := Nil
    aSize( aItems, 0 )
    aItems := Nil

	//Desativa o modelo de dados
	oModel:DeActivate()

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fPerms
Cadastra dados de Permissões dos Grupos do Portal MNTNG

@type function
@author cristiano.kair
@since 24/10/2022

@param cJson, Caracter, Json com os dados do Portal MNTNG

@return lógico
/*/
//---------------------------------------------------------------------
Static Function fPerms( oWs )

	Local cJson := oWs:GetContent()
	Local oParser
	Local aItems := {}
	Local oModel := FWLoadModel( 'MNTA916' )
	Local aFieldsHP0 := {}
	Local aFieldsHP1 := {}
	Local lRet := .T.
	Local aPermissao := {}
	Local nPermissao := 0
	Local nItem := 0
	Local cDescGrp := ''
	Local cGrupo := ''
	Local cPermissao := ''
	Local nVetorPerm := 0
	Local aCodPermis := fRetPermis()

	If FWJsonDeserialize(cJson,@oParser)

		If AttIsMemberOf( oParser, "items" ) .And. Len( aItems := oParser:items ) > 0

			For nItem := 1 To Len( aItems )

				cDescGrp := DecodeUTF8( aItems[nItem]:group )

				If !fFoundGrp( cDescGrp )
					Loop
				EndIf	

				cGrupo := HP0->HP0_CODIGO

				aAdd( aFieldsHP0, { 'HP0_FILIAL', FWxFilial('HP0'), Nil } )
				aAdd( aFieldsHP0, { 'HP0_CODIGO', cGrupo, Nil } )

				// Deleta todas as Permissões X Grupos antes de incluir.
				dbSelectArea( 'HP1' )
				dbSetOrder( 1 ) // HP1_FILIAL+HP1_CODGRP+HP1_CODPER
				If msSeek( FWxFilial( 'HP1' ) + cGrupo )

					printf( " - Deletando permissoes por grupos previamente registradas do grupo: ' " + Trim( cGrupo ) + " '")

					Do While HP1->( !EoF() ) .And. HP1->HP1_CODGRP == cGrupo
						RecLock( 'HP1', .F. )
						dbDelete()
						HP1->( MsUnLock() )

						HP1->( dbSkip() )

					EndDo

				EndIf

				If AttIsMemberOf( aItems[nItem], "permissions" ) .And. Len( aPermissao := aItems[nItem]:permissions ) > 0

					For nPermissao := 1 To Len( aPermissao )

						cPermissao := DecodeUTF8( aPermissao[nPermissao] )
						nVetorPerm := AScan(aCodPermis, {|x| x[2] == cPermissao })

						If nVetorPerm > 0

							aAdd( aFieldsHP1, {	{ 'HP1_FILIAL', FWxFilial('HP1'), 		   Nil },;
												{ 'HP1_CODGRP', cGrupo, 		  		   Nil },;
												{ 'HP1_CODPER', aCodPermis[nVetorPerm][1], Nil }} )

						EndIf

					Next nPermissao

					FWMVCRotAuto(oModel, 'HP0', 4, { { 'MNTA916_HP0', aFieldsHP0 }, { 'MNTA916_HP1', aFieldsHP1 } } ,,.T. )

					aFieldsHP0 := {}
					aFieldsHP1 := {}

				EndIf

			Next nItem

		EndIf

	EndIf

    // Performance
    aSize( aFieldsHP0, 0 )
    aFieldsHP0 := Nil
    aSize( aFieldsHP1, 0 )
    aFieldsHP1 := Nil
    aSize( aPermissao, 0 )
    aPermissao := Nil
    aSize( aItems, 0 )
    aItems := Nil
    aSize( aCodPermis, 0 )
    aCodPermis := Nil

	//Desativa o modelo de dados
	oModel:DeActivate()

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fUsers
Cadastra dados de Usuários dos Grupos do Portal MNTNG

@type function
@author cristiano.kair
@since 17/11/2022

@param cJson, Caracter, Json com os dados do Portal MNTNG

@return lógico
/*/
//---------------------------------------------------------------------
Static Function fUsers( oWs )

	Local cJson := oWs:GetContent()
	Local oParser
	Local aItems := {}
	Local oModel := FWLoadModel( 'MNTA916' )
	Local aFieldsHP0 := {}
	Local aFieldsHP2 := {}
	Local lRet := .T.
	Local nItem := 0
	Local cGrupo := ''
	Local cUser := ''
	Local cEmail := ''
	Local aEmails := {}
	Local nEmail := 0

	If FWJsonDeserialize(cJson,@oParser)

		If AttIsMemberOf( oParser, "items" ) .And. Len( aItems := oParser:items ) > 0

			For nItem := 1 To Len( aItems )

				cGrupo := DecodeUTF8( aItems[nItem]:group )

				If fFoundGrp( cGrupo )

					If AttIsMemberOf( aItems[nItem], "users" ) .And. Len( aEmails := aItems[nItem]:users ) > 0

						aAdd( aFieldsHP0, { 'HP0_FILIAL', FWxFilial('HP0'), Nil } )
						aAdd( aFieldsHP0, { 'HP0_CODIGO', HP0->HP0_CODIGO, Nil } )
					
						For nEmail := 1 To Len( aEmails )

							cEmail := DecodeUTF8( aEmails[nEmail] )
							psworder(4)
							PswSeek( cEmail )
							cUser := PsWret()[1][1]

							If cUser != ''

								aAdd( aFieldsHP2, {	{ 'HP2_FILIAL', FWxFilial('HP2'), Nil },;
													{ 'HP2_CODGRP', HP0->HP0_CODIGO	, Nil },;
													{ 'HP2_CODUSR', cUser			, Nil }} )

							EndIf

						Next nEmail

					EndIf

					FWMVCRotAuto(oModel, 'HP0', 4, { { 'MNTA916_HP0', aFieldsHP0 }, { 'MNTA916_HP2', aFieldsHP2 } } ,,.T. )

					aFieldsHP0 := {}
					aFieldsHP2 := {}

				EndIf

			Next nItem

		EndIf

	EndIf

    // Performance
    aSize( aFieldsHP0, 0 )
    aFieldsHP0 := Nil
    aSize( aFieldsHP2, 0 )
    aFieldsHP2 := Nil
    aSize( aItems, 0 )
    aItems := Nil
    aSize( aEmails, 0 )
    aEmails := Nil

	//Desativa o modelo de dados
	oModel:DeActivate()//Tratamento realizado para evitar Reference counter overflow.
	oModel:Destroy()
	oModel:=Nil

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTNGFILTR
Cadastra dados de Filtros dos Grupos do Portal MNTNG

@type function
@author cristiano.kair
@since 02/12/2022

@param cJson, Caracter, Json com os dados do Portal MNTNG
@param lDifEnterp, boolean, indica se o processo é dentro de outra thread /job separado

@return lógico
/*/
//---------------------------------------------------------------------
Function MNTNGFILTR( cJson, lDifEnterp )

	Local aFiltros		:= {}
	Local aCodigo		:= {}
	Local aFieldsHP0	:= {}
	Local aFieldsHP3	:= {}
	Local oModel		:= Nil
	Local oParser		:= Nil
	Local lRet			:= .T.
	Local nFiltros		:= 0
	Local nCodigo		:= 0
	Local nVetor		:= 0
	Local nCont			:= 0
	Local cEnterprise	:= ''
	Local cBranch		:= ''
	Local cGrupo		:= ''
	Local cTabela		:= ''
	Local cQryWhere  	:= ''
	Local cValor		:= ''
	Local cAliasQry 	:= ''
	Local cQuery	 	:= ''
	Local aDados		:= {{'ST6','ST6->T6_CODFAMI','T6_CODFAMI','T6_FILIAL'},;
							{'CTT','CTT->CTT_CUSTO','CTT_CUSTO','CTT_FILIAL'},;
							{'STD','STD->TD_CODAREA','TD_CODAREA','TD_FILIAL'},;
							{'ST4','ST4->T4_SERVICO','T4_SERVICO','T4_FILIAL'},;
							{'SBM','SBM->BM_GRUPO','BM_GRUPO','BM_FILIAL'},;
							{'SA2','SA2->A2_COD','A2_COD','A2_FILIAL'},;
							{'SH4','SH4->H4_CODIGO','H4_CODIGO','H4_FILIAL'}}

	If FWJsonDeserialize( cJson, @oParser ) //Transforma JSON em Array e guarda na variável oParser

		If AttIsMemberOf( oParser, "filters" ) .And. Len( aFiltros := oParser:filters ) > 0
			
			cEnterprise := DecodeUTF8( oParser:enterprise )
			cBranch 	:= DecodeUTF8( oParser:branch )
			cGrupo 		:= DecodeUTF8( oParser:group )

			If lDifEnterp

				RpcSetType( 3 )
				RpcSetEnv( cEnterprise, cBranch, Nil, Nil, 'MNT' )

			ElseIf cFilAnt != cBranch

				cFilAnt := cBranch

			EndIf

			oModel := FWLoadModel( 'MNTA917' )

			If fFoundGrp( cGrupo )

				aAdd( aFieldsHP0, { 'HP0_FILIAL', FWxFilial('HP0'), Nil } )
				aAdd( aFieldsHP0, { 'HP0_CODIGO', HP0->HP0_CODIGO, Nil } )

				For nFiltros := 1 To Len( aFiltros )

					aCodigo := aFiltros[nFiltros]:filter
					cTabela := aFiltros[nFiltros]:table
					
					//Pega o código de cada Filtro que passamos no aFiltros e verifica se type é "reject"
					//"reject" indica que apenas aquele Filtro será adicionado na HP3
					If Len( aCodigo ) > 0 .And. aFiltros[nFiltros]:type == 'reject'

						For nCodigo := 1 To Len( aCodigo )

							fAddFilter( @aFieldsHP3, HP0->HP0_CODIGO, cTabela, aCodigo[nCodigo] )

						Next nCodigo

					//Pega o código de cada Filtro que passamos no aFiltros e verifica se type é "filter"
					//"filter" indica que TODOS menos esse Filtro será adicionado na HP3
					ElseIf Len( aCodigo ) > 0 .And. aFiltros[nFiltros]:type == 'filter'

						cAliasQry := GetNextAlias()

						nVetor := AScan(aDados, {|x| x[1] == cTabela })
						cValor	:= &(aDados[nVetor][2])

						For nCont := 1 To Len( aCodigo )
							cQryWhere += ValToSQL( aCodigo[nCont] )
							If nCont <> Len( aCodigo )
								cQryWhere += ','
							EndIf
						Next nCont

						cQuery := " SELECT " + aDados[nVetor][3] + " AS CODE FROM " + RetSqlName( aDados[nVetor][1] )
						cQuery += "	WHERE " + aDados[nVetor][4] + " = " + ValtoSql(xFilial(aDados[nVetor][1]))
						cQuery += " AND " + aDados[nVetor][3] + " NOT IN (" + cQryWhere + ") AND D_E_L_E_T_ = ' '"
						cQuery := ChangeQuery(cQuery)
						dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)

						dbSelectArea(cAliasQry)

						While !(( cAliasQry )->( EoF() ))

							fAddFilter( @aFieldsHP3, HP0->HP0_CODIGO, cTabela, (cAliasQry)->CODE )
							( cAliasQry )->( dbSkip() )

						EndDo

						(cAliasQry)->(dbCloseArea())
						cQryWhere := ''

					EndIf

				Next nFiltros

				FWMVCRotAuto(oModel, 'HP0', 4, { { 'MNTA917_HP0', aFieldsHP0 }, { 'MNTA917_HP3', aFieldsHP3 } } ,,.T. )

				aFieldsHP0 := {}
				aFieldsHP3 := {}

			EndIf

		EndIf

	EndIf

    // Performance
    aSize( aFieldsHP0, 0 )
    aFieldsHP0 := Nil
    aSize( aFieldsHP3, 0 )
    aFieldsHP3 := Nil
    aSize( aFiltros, 0 )
    aFiltros := Nil
    aSize( aCodigo, 0 )
    aCodigo := Nil
    aSize( aDados, 0 )
    aDados := Nil

	//Desativa o modelo de dados
	oModel:DeActivate()//Tratamento realizado para evitar Reference counter overflow.
	oModel:Destroy()
	oModel:=Nil

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fCheckMNTNG
Verifica se o ambiente possui todos os campos necessários para o MNTNG

@type function
@author cristiano.kair
@since 15/12/2022

@return lógico, ambiente OK para tratar descontinuação do portal MNTNG
/*/
//---------------------------------------------------------------------
Static Function fCheckMNTNG()

	Local lRet := FindFunction('MNTA915') .And. ( GetRPORelease() > '12.1.2210' .Or. ChkFile('HP3') )

	If !lRet

		Return { .F., 'Para utilizar a importação dos dados do Aplicativo MNTNG é necessário estar com o ambiente atualizado (Release 12.1.2310)'}

	EndIf

Return { .T., ''}

//---------------------------------------------------------------------
/*/{Protheus.doc} fAddFilter
Adiciona dados no array que grava dados na HP3

@type function
@author cristiano.kair
@since 15/12/2022

@param aFieldsHP3, array, dados a serem gravados
@param cCodgrp, string, código do grupo do usuário
@param cTable, string, tabela relacionada a hp3
@param cCode, string, código do registro

@return Nil
/*/
//---------------------------------------------------------------------
Static Function fAddFilter( aFieldsHP3, cCodgrp, cTable, cCode )

	dbSelectArea( 'HP3' )
	dbSetOrder( 1 ) // HP3_FILIAL+HP3_CODGRP+HP3_TABLE+HP3_CODE
	If !MsSeek( FwXFilial('HP3') + cCodgrp + cTable + cCode )
	
		aAdd( aFieldsHP3, {	{ 'HP3_FILIAL', FwXFilial('HP3'), Nil },;
							{ 'HP3_CODGRP', cCodgrp	 , Nil },;
							{ 'HP3_TABLE' , cTable	 , Nil },;
							{ 'HP3_CODE'  , cCode	 , Nil },;
							{ 'HP3_FILORI', FwXFilial( cTable ), Nil }})

	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fFoundGrp
Verifica a existência de grupo pelo nome
Seleciona o registro na HP0

@author Maria Elisandra de Paula
@since 21/12/2022
@param cDescri,string, nome do grupo
@return boolean
/*/
//---------------------------------------------------------------------
Static Function fFoundGrp(cDescri)

	Local lRet := .F.
	Local cQryAlias := GetNextAlias()

	BeginSql Alias cQryAlias

		SELECT HP0.HP0_CODIGO
		FROM %table:HP0% HP0
		WHERE HP0.HP0_FILIAL = %xFilial:HP0%
			AND UPPER(HP0.HP0_DESCRI) = %exp:Upper(cDescri)%
	EndSql

	If !(cQryAlias)->(Eof())
		DbSelectArea( 'HP0' )
		DbSetOrder( 1 )
		lRet := MsSeek( FwxFilial( 'HP0' ) + (cQryAlias)->HP0_CODIGO )
	EndIf
	(cQryAlias)->(dbCloseArea())

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fGetPermis
Pega as permissões do usuário 

@author Cristiano S Kair
@since 04/01/2023
@return array, permissões do usuário logado
/*/
//---------------------------------------------------------------------
Static Function fGetPermis()

	Local aPermisUsr := {}
	Local cQryAlias  := GetNextAlias()
	Local nVetorPerm := 0
	Local aCodPermis := fRetPermis()

	BeginSql Alias cQryAlias

		SELECT HP1.HP1_CODPER
		FROM %table:HP1% HP1
		INNER JOIN %table:HP2% HP2 ON
				HP2.HP2_FILIAL = HP1.HP1_FILIAL
			AND HP2.HP2_CODGRP = HP1.HP1_CODGRP
			AND HP2.HP2_CODUSR = %exp:cUserLog%
			AND HP2.%NotDel%
		WHERE 	HP1.HP1_FILIAL = %xFilial:HP1%
			AND HP1.%NotDel%

	EndSql

	While !(cQryAlias)->(Eof())

		nVetorPerm := AScan(aCodPermis, {|x| x[1] == (cQryAlias)->(HP1_CODPER) })

		If nVetorPerm > 0
			aAdd( aPermisUsr,  aCodPermis[nVetorPerm][2])
		EndIf

		( cQryAlias )->( dbSkip() )

	EndDo

	(cQryAlias)->( dbCloseArea() )

	aSize( aCodPermis, 0 )
    aCodPermis := Nil

Return aPermisUsr

//---------------------------------------------------------------------
/*/{Protheus.doc} fGrpUser
Retorna grupo do usuário logado

@author Cristiano S Kair
@since 04/01/2023
@return array, permissões do usuário logado
/*/
//---------------------------------------------------------------------
Static Function fGrpUser()

	DbSelectArea('HP2')
	DbSetOrder(2)
	If MsSeek( FwXFilial('HP2') + cUserLog)
		Return HP2->HP2_CODGRP
	EndIf

Return ' '

//---------------------------------------------------------------------
/*/{Protheus.doc} fRetPermis
Retorna código de permissões cadastradas

@author Maria Elisandra de Paula
@since 06/03/2023
@return array, códiogo de permissões
/*/
//---------------------------------------------------------------------
Static Function fRetPermis()

	Local aAux := {{'OS0001','create-order-corr'},; //Incluir O.S. corretiva 
				{'OS0002',	'create-order-prev'},; //Incluir O.S. preventiva
				{'OS0003',	'edit-order-corr'},; //Alterar O.S. corretiva
				{'OS0004',	'edit-order-prev'},; //Alterar O.S. preventiva
				{'OS0005',	'cancel-order'},; //Cancelar O.S.
				{'OS0006',	'finish-order'},; //Finalizar O.S.
				{'OS0007',	'prev-input-product'},; //Prever insumo produto
				{'OS0008',	'prev-input-thirdpart'},; //Prever insumo terceiro
				{'OS0009',	'prev-input-tool'},; //Prever insumo ferramenta
				{'OS0010',	'prev-input-labor'},; //Prever insumo mão-de-obra
				{'OS0011',	'prev-input-specialit'},; //Prever insumo especialidade
				{'OS0012',	'prev-checklist'},; //Prever Checklist
				{'OS0013',	'done-input-product'},; //Realizar insumo produto
				{'OS0014',	'done-input-thirdpart'},; //Realizar insumo terceiro
				{'OS0015',	'done-input-tool'},; //Realizar insumo ferramenta
				{'OS0016',	'done-input-labor'},; //Realizar insumo mão-de-obra
				{'OS0017',	'done-checklist'},; //Realizar Checklist
				{'OS0018',	'occurrences'},; //Ocorrências
				{'OS0019',	'location-order'},; //Ordens de serviço localizações
				{'OS0020',	'onlyThisUser'},; //Somente O.S. relacionadas ao usuário
				{'OS0021',	'onlyUserSpecialties'},; //Somente O.S. relacionadas à especialidade do usuário
				{'SS0001',	'create-ss'},; //Incluir S.S.
				{'SS0002',	'edit-service-request'},; //Alterar S.S.
				{'SS0003',	'distribute-ss'},; //Distribuir S.S.
				{'SS0004',	'finish-ss'},; //Finalizar S.S.
				{'SS0005',	'generate-ss-os'},; //Gerar ordens vinculadas a S.S.
				{'SS0006',	'location-ss'},; //Solicitações de serviço localizações
				{'SS0007',	'onlyUserRelatedRequests'}} //Somente S.S. relacionadas ao usuário

Return aAux

//---------------------------------------------------------------------
/*/{Protheus.doc} fGetPerm2
Retorna as permissões do usuário logado

@author Maria Elisandra de Paula
@param oWs, objeto, instancia do ws
@param aAll, array, todas as permissões
@since 06/03/2023
@return array, código de permissões do usuário
/*/
//---------------------------------------------------------------------
Static Function fGetPerm2( oWs, aAll )
	
	Local nIndex := 0
	Local aPerms := {}

	For nIndex := 1 To Len( aAll )
		If ValType( oWS:GetHeader( aAll[ nIndex,2 ] ) ) == "C" .And. oWS:GetHeader( aAll[ nIndex,2 ] ) == "true"
			aAdd( aPerms, StrTran( aAll[nIndex,2], '_', '-' ) )
		EndIf
	Next nX

	If ValType( oWS:GetHeader( 'By-User' )) == "C" .And. oWS:GetHeader( 'By-User' ) == 'true'
		aAdd( aPerms, 'onlyThisUser' )
	EndIf

	If ValType( oWS:GetHeader( 'By-User-Specialties' )) == "C" .And. oWS:GetHeader( 'By-User-Specialties' ) == 'true'
		aAdd( aPerms, 'onlyUserSpecialties' )
	EndIf

	If ValType( oWS:GetHeader( 'By-User-Related-Requests' )) == "C" .And. oWS:GetHeader( 'By-User-Related-Requests' ) == 'true'
		aAdd( aPerms, 'onlyUserRelatedRequests' )
	EndIf

Return aPerms

//---------------------------------------------------------------------
/*/{Protheus.doc} fSet1Key
Grava parâmetro com informações obtidas pelo portal

@param oWs, objeto, web service

@author Maria Elisandra de Paula
@since 16/03/2023
@return	boolean
/*/
//---------------------------------------------------------------------
Static Function fSet1Key( oWs )

	Local lRet    := .F.
    Local cJson   := oWs:GetContent()
	Local cMingle := ''
	Local cCnpj   := ''
	Local cName   := ''
	Local oParser 

	If FWJsonDeserialize( cJson, @oParser ) ;
		.And. AttIsMemberOf( oParser, 'mingle' );
		.And. AttIsMemberOf( oParser, 'cnpj' );
		.And. AttIsMemberOf( oParser, 'name' )

		cMingle := DecodeUTF8( oParser:mingle )
		cCnpj := DecodeUTF8( oParser:cnpj )
		cName := DecodeUTF8( oParser:name )

		lRet := PUTMV( "MV_NG1KEY", cMingle + ";" + cCnpj + ";" + cName )

	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fGet1Key
Retorna o conteúdo do parâmetro com chaves do MNT NG

@author Maria Elisandra de Paula
@since 21/03/2023
@return	array
	[1]Alias Mingle
	[2]CNPJ
	[3]Nome Fantasia do cliente
/*/
//---------------------------------------------------------------------
Static Function fGet1Key()

	Local cMingle := ''
	Local cName   := ''
	Local cCnpj   := ''
	Local aNg1Key := Strtokarr(SuperGetMv('MV_NG1KEY', .F., ''), ';')

	If Len(aNg1Key) == 3
		cMingle  := Alltrim(aNg1Key[1])
		cCnpj    := Alltrim(aNg1Key[2])
		cName    := Alltrim(aNg1Key[3])
	EndIf

Return {cMingle, cCnpj, cName}

//---------------------------------------------------------------------
/*/{Protheus.doc} fHasPerms
Verifica se usuário possui a devida permissão 

@author Maria Elisandra de Paula
@param cValue, string, nome da permissão
@since 23/03/2023
@return	boolean
/*/
//---------------------------------------------------------------------
Static Function fHasPerms(cValue)
Return ascan( aPermissions, cValue ) > 0

//---------------------------------------------------------------------
/*/{Protheus.doc} fHeaderStr
Retorna conteúdo de um header em string

@param oWs, object, instância do ws
@param cValue, string, nome do header
@return string, conteúdo do header

@author Maria Elisandra de Paula
@since 17/07/2022
/*/
//---------------------------------------------------------------------
Static Function fHeaderStr(oWS, cValue)

	Local cRet := ''

	If ValType( oWS:GetHeader( cValue ) ) == "C"
		cRet := oWS:GetHeader( cValue )
	EndIf

Return cRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fAppCalend
Verifica se app está atualizado para usar calendário

@param oWs, object, instância do ws
@param cValue, string, nome do header
@return boolean, se app é compativel para usar calendário

@author Maria Elisandra de Paula
@since 17/07/2022
/*/
//---------------------------------------------------------------------
Static Function fAppCalend( oWs )

	Local lRet   := .F.
	Local cVsApp := fHeaderStr( oWs, 'version' )

	If !Empty( cVsApp )
		lRet := fVersion( cVsApp, '1.12.0' )
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fVldCalend
Consistência de hora do calendário

@param cCalend, string, calendário do funcionário
@param dDtVld, date, data para validação
@param cHrVld, string, hora para validação
@param cType, string, indica hora inicial ou final ('I' ou 'F')
@return boolean, se app é compativel para usar calendário

@author Maria Elisandra de Paula
@since 17/07/2022
/*/
//---------------------------------------------------------------------
Static Function fVldCalend( cCalend, dDtVld, cHrVld, cType )

	Local xError := NGVALHRCALE( cCalend, dDtVld, cHrVld, cType, .F., .F. )
	Local cError := ''

	If Valtype( xError ) == 'C'
		cError := xError
	ElseIf !xError
		cError := STR0210 // "Horário inválido para o calendário/dia"
	EndIf

Return cError

//--------------------------------------------------------------------------------
/*/{Protheus.doc} fSaveFile
Aciona funções para gravar arquivo no banco de conhecimento

@autor Maria Elisandra de Paula
@since 12/07/2023

@param oSelf, objeto, objeto, instância do webservice
@param cTable, string, 'TQB' ou 'STJ'
@param cItemCode, string, código da ordem de serviço or SS
@param cDescri, string, conteúdo para campo descrição
@param cKeyJson, string, indica a chave do objeto json
@param [cFileExt], string, extensão do arquivo
@param [cItemName], string, nome do arquivo
@return array, [1] se obteve sucesso,
               [2] nome do arquivo ou descrição do erro
			   [3] chave da tabela do banco de conhecimento
/*/
//--------------------------------------------------------------------------------
Static Function fSaveFile( oSelf, cTable, cItemCode, cDescri, cKeyJson, cFileExt, cItemName )

	Local aValid  := {}
	Local aWrite  := {}
	Local aRet    := {}
	Local cKeyAcb := ''
	Local cName   := ''

	Default cFileExt := 'pdf'

	/*------------------------------------------+
	| Verifica se a ordem ou solicitação existe |
	+------------------------------------------*/	
	aValid := fCheckItem( cItemCode, cTable )
	If !aValid[1]
		Return aValid	
	EndIf

	/*-----------------------------------+
	| Pega conteúdo/arquivo em binário   |
	+-----------------------------------*/	
	aRet := fGetFile( oSelf, cKeyJson )
	If !Empty( aRet[1] )
		Return { .F., aRet[1] }
	EndIf

	/*--------------------------------------------------------+
	| Grava o arqruivo no diretório do banco de conhecimento  |
	+--------------------------------------------------------*/
	aWrite := fWriteFile( aRet[2], cItemName, cFileExt )
	If !Empty( aWrite[1] )
		Return { .F., aWrite[1] }
	EndIf

	/*----------------------------------------+
	| Grava informações nas tabelas ACB e AC9 |
	+----------------------------------------*/
	cName := aWrite[2]
	cKeyAcb := fRecordBC( cName, cDescri, cItemCode, cTable )

Return { .T., cName, cKeyAcb }

//-------------------------------------------------------------------
/*/{Protheus.doc} fWriteFile
Grava o conteúdo buffer em um arquivo no servidor

@autor Maria Elisandra de Paula
@since 12/07/2023

@param cContent, string, conteúdo
@param cItemName, string, nome do arquivo
@param cExtension, string, extensão do arquivo
@param nSize, numeric, quantidade de letras para nome do arquivo

@return array, [1] descrição do erro ou vazio
               [2] nome do arquivo
/*/
//-------------------------------------------------------------------
Static Function fWriteFile( cContent, cItemName, cExtension, nSize )

	Local cDocPath  := ''
	Local cFileName := ''
	Local cFilePath := ''
	Local nHandler  := 0
	Local cError    := ''

	Default nSize := 5

	/*--------------------------------------------------------+
	| Diretório no servidor de acordo com sistema operacional |
	+--------------------------------------------------------*/
	If isSRVunix()
		cDocPath := Lower( StrTran( MsDocPath(), '\', '/') )
	Else
		cDocPath := MsDocPath()
	EndIf

	If Empty( cItemName )

		/*--------------------------+
		| Gera um nome para arquivo |
		+---------------------------*/
		cFileName  := NextIdentifier( nSize ) + '.' + cExtension
		While File( cDocPath + cBarra + cFileName ) // Enquanto existirem nomes conflitantes, geramos outro
			cFileName := NextIdentifier( nSize ) + '.' + cExtension
		EndDo

	Else

		cFileName := cItemName

	EndIf

	/*---------------------------+
	| Cria o arquivo no servidor |
	+---------------------------*/
	cFilePath := cDocPath + cBarra + cFileName
	nHandler := FCreate( cFilePath, Nil, Nil, .F. )
	If nHandler == -1
		cError := STR0018 + " " + AllTrim( Str( FError() ) ) // "Erro ao criar arquivo no servidor"
	Else
		FWrite( nHandler, cContent )
		FClose( nHandler )
	EndIf

Return { cError, cFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} fGetDoc
Envia um arquivo de documento da ordem/solicitação (download)

@author Maria Elisandra de paula
@since 12/07/2023

@param oSelf, object, instância do ws
@param cFileName, string, nome do arquivo 
@return	boolean
/*/
//---------------------------------------------------------------------
Static Function fGetDoc( oSelf, cFileName )

	Local cMsDocPath := If(isSRVunix(), Lower(StrTran( MsDocPath(),'\', '/')),MsDocPath())
	Local cFilePath  := cMsDocPath + cBarra + cFileName
	Local aRet       := { .T., '' }
	Local xBytes

	If !File( cFilePath )
		Return { .F., 'Documento não encontrado ' + cFilePath }
	EndIf

	xBytes := fReadBytes( cFilePath )
	If xBytes == Nil .Or. FError() <> 0
		Return { .F., '' }
	EndIf

	oSelf:SetResponse( '{"doc":"' + Encode64(xBytes) + '"}' )

Return aRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fGetDocs
Envia resposta do ws com uma lista de documentos da ordem/solicitação

@author Maria Elisandra de paula
@since 12/07/2023

@param oSelf, object, instância do ws
@param cType, string, indica se é ordem ou solicitação
@param itemCode, string, valor da ordem ou solicitação
@return	boolean
/*/
//---------------------------------------------------------------------
Static Function fGetDocs( oSelf, cType, itemCode )

	Local aResponse := {}
	Local aRet      := { .T., ''}
	Local cTable    := 'TQB'
	Local cFilEnt   := FwxFilial( cTable )
	Local cAliasQry := GetNextAlias()
	Local cCodEnt   := cFilEnt + itemCode
	Local cExt      := ''
	Local oJson
	Local cFileName := ''

	If cType == 'order'

		cTable := 'STJ'

		dbSelectArea( 'STJ' )
		dbSetOrder( 1 )
		If !dbSeek( FwxFilial( 'STJ' ) + itemCode )
			Return {.F., ''}
		EndIf

		cCodEnt := itemCode

	EndIf

	BeginSql Alias cAliasQry
		SELECT ACB.ACB_CODOBJ, ACB.ACB_OBJETO, ACB.ACB_DESCRI
		FROM %table:AC9% AC9
		INNER JOIN %table:ACB% ACB
			ON ACB.ACB_FILIAL = %xFilial:ACB%
			AND ACB.ACB_CODOBJ = AC9.AC9_CODOBJ
		WHERE AC9.AC9_FILIAL = %xFilial:AC9%
			AND AC9.AC9_ENTIDA = %exp:cTable%
			AND AC9.AC9_FILENT = %exp:cFilEnt%
			AND ACB.ACB_OBJETO NOT LIKE ('%.jpg')
			AND AC9.AC9_CODENT = %exp:cCodEnt%
			AND AC9.%NotDel%
			AND ACB.%NotDel%
	EndSql

	While !(( cAliasQry )->( EoF() ))

		cFileName := AllTrim(( cAliasQry )->ACB_OBJETO)

		cExt := Substr( cFileName, At( '.', cFileName ) + 1 )

		oJson := JsonObject():New()
		oJson["fileName"]   := cFileName
		oJson["extension"]  := cExt
		oJson["keyProtheus"] := ( cAliasQry )->ACB_CODOBJ 

		If cTable == 'STJ'
			oJson["itemType"] := 'order'
		Else
			oJson["itemType"] := 'request'
		EndIf

		aAdd( aResponse, oJson )

		FreeObj( oJson )

	( cAliasQry )->( dbSkip() )

	EndDo

	( cAliasQry )->( dbCloseArea() )

	oSelf:SetStatus( 200 )
	oSelf:SetResponse( FwhttpEncode( FWJsonSerialize(  aResponse , .F. ) ) )

Return aRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fDocCreate
Faz upload de um documento e grava no banco de conhecimento

@author Maria Elisandra de paula
@since 12/07/2023

@param oWs, object, instância do ws
@param cItemType, string, tipo da base: order / request
@param cItemCode, string, valor da ordem ou solicitação
@param cItemName, string, nome do arquivo
@return	boolean
/*/
//---------------------------------------------------------------------
Static Function fDocCreate( oWs, cItemType, cItemCode, cItemName )

	Local aSave  := {}
	Local cTable := 'TQB'
	Local cExt   := ''
	Local cDesc  := 'DOCMNTNG ' + DToC( Date() ) + ' ' + Time()
	Local oResp
	
	Default cItemName := cDesc

	If cItemType == 'order'
		cTable := 'STJ'
	EndIf

	cExt := Substr( cItemName, At( '.', cItemName ) + 1 )

	aSave := fSaveFile( oWs, cTable, cItemCode, cDesc, 'doc', cExt, cItemName )

	If !aSave[1]
		Return aSave	
	EndIf

	oResp := JsonObject():New()
	oResp[ "keyProtheus" ] := aSave[3]
	oWs:SetResponse( FwhttpEncode( FWJsonSerialize( oResp , .F. ) ) )

	FreeObj( oResp )

Return { .T., '' }

//---------------------------------------------------------------------
/*/{Protheus.doc} fDeleteAC9
Remove vínculo de um arquivo com a tabela AC9

@author Maria Elisandra de Paula
@since 06/10/23

@param oSelf, objeto, objeto, instância do webservice
@param cItemType, string, tipo da base: order / request
@param cItemCode, string, código da order / request
@param cDocCode, string, ID (código do objeto) da AC9

@return array, [1] se obteve sucesso
               [2] vazio ou descrição do erro
/*/
//---------------------------------------------------------------------
Static Function fDeleteAC9( oSelf, cItemType, cItemCode, cDocCode )

	Local cTable     := ''
	Local cFilKey    := ''
	Local cCodEnt    := ''

	Default cItemType := 'order'

	If cItemType == 'request'
		cTable  := 'TQB'
		cFilKey := FwxFilial('TQB')
		cCodEnt := cFilKey + cItemCode // para TQB o campo AC9_CODENT é gravado com filial
	Else
		cTable  := 'STJ'
		cFilKey := FwxFilial('STJ')
		cCodEnt := cItemCode
	EndIf

	//-----------------------------------------------------
	// Trecho abaixo remove vínculo apenas com a AC9
	// pois o arquivo pode ter vínculo com outra entidade
	//-----------------------------------------------------
	dbSelectArea( 'AC9' )
	dbSetOrder( 1 ) // AC9_FILIAL + AC9_CODOBJ + AC9_ENTIDA + AC9_FILENT + AC9_CODENT
	If dbSeek( FwxFilial('AC9') + cDocCode + cTable + cFilKey + cCodEnt )
		RecLock( 'AC9', .F. )
		dbDelete()
		MsUnlock()
	EndIf

Return { .T., '{}' }

//---------------------------------------------------------------------
/*/{Protheus.doc} fPathBC
Retorna caminho completo do objeto

@param cObject, string, objeto
@return string, caminho completo do objeto

@author Maria Elisandra de Paula
@since 22/09/2023
/*/
//---------------------------------------------------------------------
Static Function fPathBC( cObject )

	Local cMsDocPath := ''
	Local cFilePath  := ''

	If isSRVunix()
		cMsDocPath := StrTran( MsDocPath(),'\', '/')
	Else
		cMsDocPath := MsDocPath()
	EndIf

	cFilePath := Lower( cMsDocPath + cBarra + cObject + '.jpg')

Return cFilePath

//---------------------------------------------------------------------
/*/{Protheus.doc} fBitmap
Busca nome de uma imagem do bem ou funcionário

@param cTable, string, tabela para busca
@return string, caminho completo do objeto

@author Maria Elisandra de Paula
@since 27/09/2023
/*/
//---------------------------------------------------------------------
Static Function fBitmap( cTable )

	Local cField  := ''
	Local cBitmap := ''

	If cTable == 'ST1'
		cField := 'T1_BITMAP'
		cBitmap := ST1->T1_BITMAP
	Else
		cField := 'T9_BITMAP'
		cBitmap := ST9->T9_BITMAP
	EndIf

	If Empty( cBitmap )
		cBitmap := GetSxeNum( cTable, cField )
		ConfirmSX8()
	Else
		fDelBitmap( cBitmap )
	EndIf

Return cBitmap

//---------------------------------------------------------------------
/*/{Protheus.doc} fDelBitmap
Deleta imagem do repositório de imagens

@param cBitmap, string, nome da imagem

@author Maria Elisandra de Paula
@since 27/09/2023
@return nul
/*/
//---------------------------------------------------------------------
Static Function fDelBitmap( cBitmap )

	Local oReposit

	oReposit := FWBmpRep():New()
	If oReposit:OpenRepository()
		If oReposit:ExistBmp( cBitmap )
			oReposit:DeleteBmp( cBitmap )
		EndIf
		oReposit:CloseRepository()
	EndIf
	FreeObj( oReposit )

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fCTempImg
Cria uma arquivo de imagem temporária no repositório do servidor

@param cFilePath, string, caminho completo
@param cBytesImg, string, conteúdo  para gravar

@author Maria Elisandra de Paula
@since 27/09/2023
@return nul
/*/
//---------------------------------------------------------------------
Static Function fCTempImg( cFilePath, cBytesImg )

	Local lRet := .F.
	Local nHandler := FCreate( cFilePath, Nil, Nil, .F. )

	If nHandler == -1
		SetRestFault( 403, EncodeUtf8(STR0018+ " " + AllTrim(Str(FError())) )) // "Erro ao criar arquivo no servidor"
	Else
		FWrite( nHandler, cBytesImg )
		FClose( nHandler )
		lRet := .T.
	EndIf

Return lRet

